1
00:00:00,560 --> 00:00:02,629

bienvenidos de nuevo russ gang si son nuevos

2
00:00:02,629 --> 00:00:02,639
bienvenidos de nuevo russ gang si son nuevos
 

3
00:00:02,639 --> 00:00:04,630
bienvenidos de nuevo russ gang si son nuevos
aquí mi nombre es bogdan y este canal

4
00:00:04,630 --> 00:00:04,640
aquí mi nombre es bogdan y este canal
 

5
00:00:04,640 --> 00:00:05,829
aquí mi nombre es bogdan y este canal
trata sobre

6
00:00:05,829 --> 00:00:05,839
trata sobre
 

7
00:00:05,839 --> 00:00:07,990
trata sobre
el lenguaje de programación rust en el

8
00:00:07,990 --> 00:00:08,000
el lenguaje de programación rust en el
 

9
00:00:08,000 --> 00:00:10,070
el lenguaje de programación rust en el
último video repasamos el capítulo 12 del

10
00:00:10,070 --> 00:00:10,080
último video repasamos el capítulo 12 del
 

11
00:00:10,080 --> 00:00:11,350
último video repasamos el capítulo 12 del
libro de lucha libre

12
00:00:11,350 --> 00:00:11,360
libro de lucha libre
 

13
00:00:11,360 --> 00:00:14,390
libro de lucha libre
en el que creamos un programa cli

14
00:00:14,390 --> 00:00:14,400
en el que creamos un programa cli
 

15
00:00:14,400 --> 00:00:16,470
en el que creamos un programa cli
en este video estamos  repasando el capítulo

16
00:00:16,470 --> 00:00:16,480
en este video estamos  repasando el capítulo
 

17
00:00:16,480 --> 00:00:17,830
en este video estamos  repasando el capítulo
13, específicamente la

18
00:00:17,830 --> 00:00:17,840
13, específicamente la
 

19
00:00:17,840 --> 00:00:20,310
13, específicamente la
parte 1 del capítulo 13, en la que hablaremos

20
00:00:20,310 --> 00:00:20,320
parte 1 del capítulo 13, en la que hablaremos
 

21
00:00:20,320 --> 00:00:21,109
parte 1 del capítulo 13, en la que hablaremos
sobre los

22
00:00:21,109 --> 00:00:21,119
sobre los
 

23
00:00:21,119 --> 00:00:30,550
sobre los
cierres, así que primero vamos a oxidarnos,

24
00:00:30,550 --> 00:00:30,560
cierres, así que primero vamos a oxidarnos,
 

25
00:00:30,560 --> 00:00:33,270
cierres, así que primero vamos a oxidarnos,
¿qué son los cierres? Los cierres

26
00:00:33,270 --> 00:00:33,280
¿qué son los cierres? Los cierres
 

27
00:00:33,280 --> 00:00:34,470
¿qué son los cierres? Los cierres
son como funciones,

28
00:00:34,470 --> 00:00:34,480
son como funciones,
 

29
00:00:34,480 --> 00:00:36,150
son como funciones,
excepto que son anónimas, lo

30
00:00:36,150 --> 00:00:36,160
excepto que son anónimas, lo
 

31
00:00:36,160 --> 00:00:37,830
excepto que son anónimas, lo
que significa que no tienen nombres

32
00:00:37,830 --> 00:00:37,840
que significa que no tienen nombres
 

33
00:00:37,840 --> 00:00:40,150
que significa que no tienen nombres
que puedan.  pueden almacenarse como variables y

34
00:00:40,150 --> 00:00:41,030
que puedan.  pueden almacenarse como variables y
 

35
00:00:41,030 --> 00:00:41,040

 

36
00:00:41,040 --> 00:00:43,270

pasarse, incluso podrían pasarse como

37
00:00:43,270 --> 00:00:43,280
pasarse, incluso podrían pasarse como
 

38
00:00:43,280 --> 00:00:44,150
pasarse, incluso podrían pasarse como
parámetros de entrada

39
00:00:44,150 --> 00:00:44,160
parámetros de entrada
 

40
00:00:44,160 --> 00:00:46,549
parámetros de entrada
a una función y capturan las

41
00:00:46,549 --> 00:00:46,559
a una función y capturan las
 

42
00:00:46,559 --> 00:00:47,590
a una función y capturan las
variables

43
00:00:47,590 --> 00:00:47,600
variables
 

44
00:00:47,600 --> 00:00:50,150
variables
dentro del alcance en el que están

45
00:00:50,150 --> 00:00:50,160
dentro del alcance en el que están
 

46
00:00:50,160 --> 00:00:50,950
dentro del alcance en el que están

47
00:00:50,950 --> 00:00:50,960

 

48
00:00:50,960 --> 00:00:53,029

definidas para comprender mejor los cierres

49
00:00:53,029 --> 00:00:53,039
definidas para comprender mejor los cierres
 

50
00:00:53,039 --> 00:00:54,389
definidas para comprender mejor los cierres
, los usaremos en el siguiente

51
00:00:54,389 --> 00:00:54,399
, los usaremos en el siguiente
 

52
00:00:54,399 --> 00:00:56,470
, los usaremos en el siguiente
ejemplo.  está construyendo un back-

53
00:00:56,470 --> 00:00:56,480
ejemplo.  está construyendo un back-
 

54
00:00:56,480 --> 00:00:58,389
ejemplo.  está construyendo un back-
end para una aplicación de acondicionamiento físico

55
00:00:58,389 --> 00:00:58,399
end para una aplicación de acondicionamiento físico
 

56
00:00:58,399 --> 00:01:00,950
end para una aplicación de acondicionamiento físico
y el back-end está construido en óxido, la

57
00:01:00,950 --> 00:01:00,960
y el back-end está construido en óxido, la
 

58
00:01:00,960 --> 00:01:02,790
y el back-end está construido en óxido, la
aplicación de acondicionamiento físico generará

59
00:01:02,790 --> 00:01:02,800
aplicación de acondicionamiento físico generará
 

60
00:01:02,800 --> 00:01:04,390
aplicación de acondicionamiento físico generará
entrenamientos personalizados para un usuario en

61
00:01:04,390 --> 00:01:04,400
entrenamientos personalizados para un usuario en
 

62
00:01:04,400 --> 00:01:07,109
entrenamientos personalizados para un usuario en
función de varios factores, como su

63
00:01:07,109 --> 00:01:07,910
función de varios factores, como su
 

64
00:01:07,910 --> 00:01:07,920

 

65
00:01:07,920 --> 00:01:11,190

preferencia de entrenamiento de índice de masa corporal de edad  nivel de intensidad e intensidad

66
00:01:11,190 --> 00:01:11,200
preferencia de entrenamiento de índice de masa corporal de edad  nivel de intensidad e intensidad
 

67
00:01:11,200 --> 00:01:12,149
preferencia de entrenamiento de índice de masa corporal de edad  nivel de intensidad e intensidad

68
00:01:12,149 --> 00:01:12,159

 

69
00:01:12,159 --> 00:01:14,310

ahora la implementación de este algoritmo

70
00:01:14,310 --> 00:01:14,320
ahora la implementación de este algoritmo
 

71
00:01:14,320 --> 00:01:15,670
ahora la implementación de este algoritmo
no importa tanto

72
00:01:15,670 --> 00:01:15,680
no importa tanto
 

73
00:01:15,680 --> 00:01:17,270
no importa tanto
lo que importa es que parte de este

74
00:01:17,270 --> 00:01:17,280
lo que importa es que parte de este
 

75
00:01:17,280 --> 00:01:19,510
lo que importa es que parte de este
algoritmo ejecuta un cálculo

76
00:01:19,510 --> 00:01:19,520
algoritmo ejecuta un cálculo
 

77
00:01:19,520 --> 00:01:21,590
algoritmo ejecuta un cálculo
que es costoso y tarda unos

78
00:01:21,590 --> 00:01:21,600
que es costoso y tarda unos
 

79
00:01:21,600 --> 00:01:23,109
que es costoso y tarda unos
segundos en ejecutarse

80
00:01:23,109 --> 00:01:23,119
segundos en ejecutarse
 

81
00:01:23,119 --> 00:01:25,510
segundos en ejecutarse
aquí hemos simulado este cálculo

82
00:01:25,510 --> 00:01:25,520
aquí hemos simulado este cálculo
 

83
00:01:25,520 --> 00:01:26,630
aquí hemos simulado este cálculo
con una función llamada

84
00:01:26,630 --> 00:01:26,640
con una función llamada
 

85
00:01:26,640 --> 00:01:29,749
con una función llamada
simulado costoso  cálculo que

86
00:01:29,749 --> 00:01:29,759
simulado costoso  cálculo que
 

87
00:01:29,759 --> 00:01:30,310
simulado costoso  cálculo que
toma

88
00:01:30,310 --> 00:01:30,320
toma
 

89
00:01:30,320 --> 00:01:32,630
toma
una intensidad y luego imprime

90
00:01:32,630 --> 00:01:32,640
una intensidad y luego imprime
 

91
00:01:32,640 --> 00:01:34,390
una intensidad y luego imprime
calculando lentamente

92
00:01:34,390 --> 00:01:34,400
calculando lentamente
 

93
00:01:34,400 --> 00:01:36,710
calculando lentamente
deja que el hilo duerma durante dos segundos

94
00:01:36,710 --> 00:01:36,720
deja que el hilo duerma durante dos segundos
 

95
00:01:36,720 --> 00:01:38,950
deja que el hilo duerma durante dos segundos
y devuelve la intensidad

96
00:01:38,950 --> 00:01:38,960
y devuelve la intensidad
 

97
00:01:38,960 --> 00:01:41,030
y devuelve la intensidad
ahora aquí en Maine estamos simulando el

98
00:01:41,030 --> 00:01:41,040
ahora aquí en Maine estamos simulando el
 

99
00:01:41,040 --> 00:01:42,230
ahora aquí en Maine estamos simulando el
código que se llamaría

100
00:01:42,230 --> 00:01:42,240
código que se llamaría
 

101
00:01:42,240 --> 00:01:44,870
código que se llamaría
si el usuario quisiera un nuevo entrenamiento llamamos

102
00:01:44,870 --> 00:01:44,880
si el usuario quisiera un nuevo entrenamiento llamamos
 

103
00:01:44,880 --> 00:01:46,710
si el usuario quisiera un nuevo entrenamiento llamamos
generar entrenamiento  que es una

104
00:01:46,710 --> 00:01:46,720
generar entrenamiento  que es una
 

105
00:01:46,720 --> 00:01:48,630
generar entrenamiento  que es una
función que aún no hemos creado

106
00:01:48,630 --> 00:01:48,640
función que aún no hemos creado
 

107
00:01:48,640 --> 00:01:50,310
función que aún no hemos creado
y generar entrenamiento toma dos

108
00:01:50,310 --> 00:01:50,320
y generar entrenamiento toma dos
 

109
00:01:50,320 --> 00:01:52,710
y generar entrenamiento toma dos
parámetros, la intensidad que un usuario ha

110
00:01:52,710 --> 00:01:52,720
parámetros, la intensidad que un usuario ha
 

111
00:01:52,720 --> 00:01:53,670
parámetros, la intensidad que un usuario ha
especificado

112
00:01:53,670 --> 00:01:53,680
especificado
 

113
00:01:53,680 --> 00:01:55,830
especificado
y un número aleatorio para proporcionar algo de

114
00:01:55,830 --> 00:01:55,840
y un número aleatorio para proporcionar algo de
 

115
00:01:55,840 --> 00:01:58,149
y un número aleatorio para proporcionar algo de
variedad al entrenamiento generado

116
00:01:58,149 --> 00:01:58,159
variedad al entrenamiento generado
 

117
00:01:58,159 --> 00:01:59,990
variedad al entrenamiento generado
ahora porque en realidad no estamos construyendo

118
00:01:59,990 --> 00:02:00,000
ahora porque en realidad no estamos construyendo
 

119
00:02:00,000 --> 00:02:01,830
ahora porque en realidad no estamos construyendo
la interfaz en este

120
00:02:01,830 --> 00:02:01,840
la interfaz en este
 

121
00:02:01,840 --> 00:02:04,469
la interfaz en este
ejemplo.  Pasaré en una intensidad simulada de

122
00:02:04,469 --> 00:02:04,479
ejemplo.  Pasaré en una intensidad simulada de
 

123
00:02:04,479 --> 00:02:05,030
ejemplo.  Pasaré en una intensidad simulada de
10

124
00:02:05,030 --> 00:02:05,040
10
 

125
00:02:05,040 --> 00:02:07,109
10
y para el número aleatorio podríamos usar

126
00:02:07,109 --> 00:02:07,119
y para el número aleatorio podríamos usar
 

127
00:02:07,119 --> 00:02:08,949
y para el número aleatorio podríamos usar
la caja de rand y generar un

128
00:02:08,949 --> 00:02:08,959
la caja de rand y generar un
 

129
00:02:08,959 --> 00:02:09,749
la caja de rand y generar un
número aleatorio,

130
00:02:09,749 --> 00:02:09,759
número aleatorio,
 

131
00:02:09,759 --> 00:02:11,510
número aleatorio,
pero de nuevo eso no es  t nuestro enfoque en este

132
00:02:11,510 --> 00:02:11,520
pero de nuevo eso no es  t nuestro enfoque en este
 

133
00:02:11,520 --> 00:02:13,589
pero de nuevo eso no es  t nuestro enfoque en este
ejemplo, por lo que simplemente estableceremos el

134
00:02:13,589 --> 00:02:13,599
ejemplo, por lo que simplemente estableceremos el
 

135
00:02:13,599 --> 00:02:15,350
ejemplo, por lo que simplemente estableceremos el
número aleatorio en un siete codificado de forma rígida; a

136
00:02:15,350 --> 00:02:15,360
número aleatorio en un siete codificado de forma rígida; a
 

137
00:02:15,360 --> 00:02:17,670
número aleatorio en un siete codificado de forma rígida; a
continuación, definiremos la

138
00:02:17,670 --> 00:02:17,680
continuación, definiremos la
 

139
00:02:17,680 --> 00:02:18,869
continuación, definiremos la
función de entrenamiento generada

140
00:02:18,869 --> 00:02:18,879
función de entrenamiento generada
 

141
00:02:18,879 --> 00:02:21,990
función de entrenamiento generada
justo debajo de la función principal de

142
00:02:21,990 --> 00:02:22,000
justo debajo de la función principal de
 

143
00:02:22,000 --> 00:02:23,990
justo debajo de la función principal de
generación de entrenamiento que toma una

144
00:02:23,990 --> 00:02:24,000
generación de entrenamiento que toma una
 

145
00:02:24,000 --> 00:02:25,910
generación de entrenamiento que toma una
intensidad y un número aleatorio

146
00:02:25,910 --> 00:02:25,920
intensidad y un número aleatorio
 

147
00:02:25,920 --> 00:02:28,630
intensidad y un número aleatorio
si la intensidad es inferior a 25

148
00:02:28,630 --> 00:02:28,640
si la intensidad es inferior a 25
 

149
00:02:28,640 --> 00:02:30,710
si la intensidad es inferior a 25
imprimimos hacer x número de flexiones

150
00:02:30,710 --> 00:02:30,720
imprimimos hacer x número de flexiones
 

151
00:02:30,720 --> 00:02:33,030
imprimimos hacer x número de flexiones
y hacer x número de abdominales para calcular

152
00:02:33,030 --> 00:02:33,040
y hacer x número de abdominales para calcular
 

153
00:02:33,040 --> 00:02:34,949
y hacer x número de abdominales para calcular
cuántas flexiones y configuraciones hacer

154
00:02:34,949 --> 00:02:34,959
cuántas flexiones y configuraciones hacer
 

155
00:02:34,959 --> 00:02:37,990
cuántas flexiones y configuraciones hacer
llamamos a nuestro cálculo costoso si la

156
00:02:37,990 --> 00:02:38,000
llamamos a nuestro cálculo costoso si la
 

157
00:02:38,000 --> 00:02:39,910
llamamos a nuestro cálculo costoso si la
intensidad es superior a 25,

158
00:02:39,910 --> 00:02:39,920
intensidad es superior a 25,
 

159
00:02:39,920 --> 00:02:42,710
intensidad es superior a 25,
entonces entramos en la cláusula else aquí

160
00:02:42,710 --> 00:02:42,720
entonces entramos en la cláusula else aquí
 

161
00:02:42,720 --> 00:02:43,030
entonces entramos en la cláusula else aquí
verifique

162
00:02:43,030 --> 00:02:43,040
verifique
 

163
00:02:43,040 --> 00:02:45,750
verifique
nuestro número aleatorio si son exactamente tres

164
00:02:45,750 --> 00:02:45,760
nuestro número aleatorio si son exactamente tres
 

165
00:02:45,760 --> 00:02:47,509
nuestro número aleatorio si son exactamente tres
, imprimamos tomemos un descanso; de lo

166
00:02:47,509 --> 00:02:47,519
, imprimamos tomemos un descanso; de lo
 

167
00:02:47,519 --> 00:02:49,910
, imprimamos tomemos un descanso; de lo
contrario, pronombremos ejecutar x cantidad de

168
00:02:49,910 --> 00:02:49,920
contrario, pronombremos ejecutar x cantidad de
 

169
00:02:49,920 --> 00:02:51,670
contrario, pronombremos ejecutar x cantidad de
minutos y nuevamente para calcular la

170
00:02:51,670 --> 00:02:51,680
minutos y nuevamente para calcular la
 

171
00:02:51,680 --> 00:02:53,110
minutos y nuevamente para calcular la
cantidad de minutos para ejecutar

172
00:02:53,110 --> 00:02:53,120
cantidad de minutos para ejecutar
 

173
00:02:53,120 --> 00:02:55,350
cantidad de minutos para ejecutar
usamos nuestra costosa

174
00:02:55,350 --> 00:02:55,360
usamos nuestra costosa
 

175
00:02:55,360 --> 00:02:56,150
usamos nuestra costosa
función de cálculo

176
00:02:56,150 --> 00:02:56,160
función de cálculo
 

177
00:02:56,160 --> 00:02:57,910
función de cálculo
ahora esto funciona pero podría usar algo de

178
00:02:57,910 --> 00:02:57,920
ahora esto funciona pero podría usar algo de
 

179
00:02:57,920 --> 00:02:59,750
ahora esto funciona pero podría usar algo de
refactorización un problema es  que estamos

180
00:02:59,750 --> 00:02:59,760
refactorización un problema es  que estamos
 

181
00:02:59,760 --> 00:03:01,350
refactorización un problema es  que estamos
llamando a nuestra función costosa

182
00:03:01,350 --> 00:03:01,360
llamando a nuestra función costosa
 

183
00:03:01,360 --> 00:03:03,910
llamando a nuestra función costosa
en varios lugares, por lo que si cambiamos la

184
00:03:03,910 --> 00:03:03,920
en varios lugares, por lo que si cambiamos la
 

185
00:03:03,920 --> 00:03:05,350
en varios lugares, por lo que si cambiamos la
forma en que se llama a la función,

186
00:03:05,350 --> 00:03:05,360
forma en que se llama a la función,
 

187
00:03:05,360 --> 00:03:07,910
forma en que se llama a la función,
por ejemplo, si agregamos otro parámetro,

188
00:03:07,910 --> 00:03:07,920
por ejemplo, si agregamos otro parámetro,
 

189
00:03:07,920 --> 00:03:09,110
por ejemplo, si agregamos otro parámetro,
entonces tenemos que cambiar

190
00:03:09,110 --> 00:03:09,120
entonces tenemos que cambiar
 

191
00:03:09,120 --> 00:03:11,589
entonces tenemos que cambiar
todos los sitios de llamada, también llamamos a nuestra función

192
00:03:11,589 --> 00:03:11,599
todos los sitios de llamada, también llamamos a nuestra función
 

193
00:03:11,599 --> 00:03:12,710
todos los sitios de llamada, también llamamos a nuestra función
costosa.  en

194
00:03:12,710 --> 00:03:12,720
costosa.  en
 

195
00:03:12,720 --> 00:03:15,589
costosa.  en
varias veces innecesariamente, por ejemplo,

196
00:03:15,589 --> 00:03:15,599
varias veces innecesariamente, por ejemplo,
 

197
00:03:15,599 --> 00:03:16,710
varias veces innecesariamente, por ejemplo,
en este bloque

198
00:03:16,710 --> 00:03:16,720
en este bloque
 

199
00:03:16,720 --> 00:03:18,790
en este bloque
si llamamos a nuestra función costosa dos veces

200
00:03:18,790 --> 00:03:18,800
si llamamos a nuestra función costosa dos veces
 

201
00:03:18,800 --> 00:03:21,030
si llamamos a nuestra función costosa dos veces
cuando realmente solo necesitamos llamarla una vez

202
00:03:21,030 --> 00:03:21,040
cuando realmente solo necesitamos llamarla una vez
 

203
00:03:21,040 --> 00:03:23,190
cuando realmente solo necesitamos llamarla una vez
y luego pasar el valor de retorno a

204
00:03:23,190 --> 00:03:23,200
y luego pasar el valor de retorno a
 

205
00:03:23,200 --> 00:03:24,789
y luego pasar el valor de retorno a
ambas declaraciones de impresión

206
00:03:24,789 --> 00:03:24,799
ambas declaraciones de impresión
 

207
00:03:24,799 --> 00:03:26,630
ambas declaraciones de impresión
ahora esto podría estar bien para las

208
00:03:26,630 --> 00:03:26,640
ahora esto podría estar bien para las
 

209
00:03:26,640 --> 00:03:28,470
ahora esto podría estar bien para las
funciones normales, pero recuerde que esto es un

210
00:03:28,470 --> 00:03:28,480
funciones normales, pero recuerde que esto es un
 

211
00:03:28,480 --> 00:03:30,229
funciones normales, pero recuerde que esto es un
costoso  función que tarda dos

212
00:03:30,229 --> 00:03:30,239
costoso  función que tarda dos
 

213
00:03:30,239 --> 00:03:32,550
costoso  función que tarda dos
segundos en ejecutarse, por lo que queremos limitar la

214
00:03:32,550 --> 00:03:32,560
segundos en ejecutarse, por lo que queremos limitar la
 

215
00:03:32,560 --> 00:03:34,470
segundos en ejecutarse, por lo que queremos limitar la
cantidad de veces que llamamos a esta función

216
00:03:34,470 --> 00:03:34,480
cantidad de veces que llamamos a esta función
 

217
00:03:34,480 --> 00:03:37,110
cantidad de veces que llamamos a esta función
tanto como sea posible, arreglemos estos dos

218
00:03:37,110 --> 00:03:37,120
tanto como sea posible, arreglemos estos dos
 

219
00:03:37,120 --> 00:03:37,750
tanto como sea posible, arreglemos estos dos

220
00:03:37,750 --> 00:03:37,760

 

221
00:03:37,760 --> 00:03:39,670

problemas almacenando el resultado de nuestra costosa

222
00:03:39,670 --> 00:03:39,680
problemas almacenando el resultado de nuestra costosa
 

223
00:03:39,680 --> 00:03:41,830
problemas almacenando el resultado de nuestra costosa
llamada de función dentro de una variable,

224
00:03:41,830 --> 00:03:41,840
llamada de función dentro de una variable,
 

225
00:03:41,840 --> 00:03:43,270
llamada de función dentro de una variable,
por lo que crearemos una nueva variable en  la

226
00:03:43,270 --> 00:03:43,280
por lo que crearemos una nueva variable en  la
 

227
00:03:43,280 --> 00:03:44,869
por lo que crearemos una nueva variable en  la
parte superior de nuestra función

228
00:03:44,869 --> 00:03:44,879
parte superior de nuestra función
 

229
00:03:44,879 --> 00:03:50,470
parte superior de nuestra función
lo llamaremos resultado costoso

230
00:03:50,470 --> 00:03:50,480

 

231
00:03:50,480 --> 00:03:52,789

y lo estableceremos igual a nuestra

232
00:03:52,789 --> 00:03:52,799
y lo estableceremos igual a nuestra
 

233
00:03:52,799 --> 00:03:56,710
y lo estableceremos igual a nuestra
llamada de función costosa,

234
00:03:56,710 --> 00:03:56,720

 

235
00:03:56,720 --> 00:03:58,550

luego usaremos nuestra variable en todas nuestras

236
00:03:58,550 --> 00:03:58,560
luego usaremos nuestra variable en todas nuestras
 

237
00:03:58,560 --> 00:04:07,509
luego usaremos nuestra variable en todas nuestras
declaraciones de línea de impresión

238
00:04:07,509 --> 00:04:07,519

 

239
00:04:07,519 --> 00:04:09,509

ahora esto soluciona nuestro

240
00:04:09,509 --> 00:04:09,519
ahora esto soluciona nuestro
 

241
00:04:09,519 --> 00:04:11,670
ahora esto soluciona nuestro
problema de duplicación pero ahora tenemos otro

242
00:04:11,670 --> 00:04:11,680
problema de duplicación pero ahora tenemos otro
 

243
00:04:11,680 --> 00:04:13,910
problema de duplicación pero ahora tenemos otro
estamos llamando a nuestra función costosa en

244
00:04:13,910 --> 00:04:13,920
estamos llamando a nuestra función costosa en
 

245
00:04:13,920 --> 00:04:15,429
estamos llamando a nuestra función costosa en
todos los casos

246
00:04:15,429 --> 00:04:15,439
todos los casos
 

247
00:04:15,439 --> 00:04:17,509
todos los casos
aquí en la parte superior, sin importar lo que se

248
00:04:17,509 --> 00:04:17,519
aquí en la parte superior, sin importar lo que se
 

249
00:04:17,519 --> 00:04:18,629
aquí en la parte superior, sin importar lo que se
ejecute a continuación

250
00:04:18,629 --> 00:04:18,639
ejecute a continuación
 

251
00:04:18,639 --> 00:04:20,310
ejecute a continuación
, llamaremos a nuestra

252
00:04:20,310 --> 00:04:20,320
, llamaremos a nuestra
 

253
00:04:20,320 --> 00:04:22,870
, llamaremos a nuestra
función costosa, pero aquí puede ver que si

254
00:04:22,870 --> 00:04:22,880
función costosa, pero aquí puede ver que si
 

255
00:04:22,880 --> 00:04:24,390
función costosa, pero aquí puede ver que si
el aleatorio  el número es 3

256
00:04:24,390 --> 00:04:24,400
el aleatorio  el número es 3
 

257
00:04:24,400 --> 00:04:26,070
el aleatorio  el número es 3
, no necesitamos nuestra función costosa

258
00:04:26,070 --> 00:04:26,080
, no necesitamos nuestra función costosa
 

259
00:04:26,080 --> 00:04:27,430
, no necesitamos nuestra función costosa
porque simplemente

260
00:04:27,430 --> 00:04:27,440
porque simplemente
 

261
00:04:27,440 --> 00:04:30,310
porque simplemente
imprimimos este texto, lo que queremos es

262
00:04:30,310 --> 00:04:30,320
imprimimos este texto, lo que queremos es
 

263
00:04:30,320 --> 00:04:32,310
imprimimos este texto, lo que queremos es
definir nuestro código en un lugar,

264
00:04:32,310 --> 00:04:32,320
definir nuestro código en un lugar,
 

265
00:04:32,320 --> 00:04:35,270
definir nuestro código en un lugar,
pero solo ejecutarlo cuando sea necesario, así

266
00:04:35,270 --> 00:04:35,280
pero solo ejecutarlo cuando sea necesario, así
 

267
00:04:35,280 --> 00:04:37,189
pero solo ejecutarlo cuando sea necesario, así
que intentemos refactorizar esto

268
00:04:37,189 --> 00:04:37,199
que intentemos refactorizar esto
 

269
00:04:37,199 --> 00:04:39,749
que intentemos refactorizar esto
usando cierres, retrocedamos hasta

270
00:04:39,749 --> 00:04:39,759
usando cierres, retrocedamos hasta
 

271
00:04:39,759 --> 00:04:41,030
usando cierres, retrocedamos hasta
la parte superior  de nuestro programa

272
00:04:41,030 --> 00:04:41,040
la parte superior  de nuestro programa
 

273
00:04:41,040 --> 00:04:43,270
la parte superior  de nuestro programa
y en lugar de definir esta

274
00:04:43,270 --> 00:04:43,280
y en lugar de definir esta
 

275
00:04:43,280 --> 00:04:44,550
y en lugar de definir esta
variable de resultado costoso

276
00:04:44,550 --> 00:04:44,560
variable de resultado costoso
 

277
00:04:44,560 --> 00:04:48,150
variable de resultado costoso
, definiremos un cierre

278
00:04:48,150 --> 00:04:48,160

 

279
00:04:48,160 --> 00:04:50,310

aquí tenemos una variable llamada

280
00:04:50,310 --> 00:04:50,320
aquí tenemos una variable llamada
 

281
00:04:50,320 --> 00:04:52,550
aquí tenemos una variable llamada
cierre costoso que es igual a

282
00:04:52,550 --> 00:04:52,560
cierre costoso que es igual a
 

283
00:04:52,560 --> 00:04:55,030
cierre costoso que es igual a
nuestro cierre ahora recuerde que los cierres son

284
00:04:55,030 --> 00:04:55,040
nuestro cierre ahora recuerde que los cierres son
 

285
00:04:55,040 --> 00:04:56,469
nuestro cierre ahora recuerde que los cierres son
funciones anónimas

286
00:04:56,469 --> 00:04:56,479
funciones anónimas
 

287
00:04:56,479 --> 00:04:58,390
funciones anónimas
y la diferencia entre un cierre y

288
00:04:58,390 --> 00:04:58,400
y la diferencia entre un cierre y
 

289
00:04:58,400 --> 00:05:00,230
y la diferencia entre un cierre y
una función o al menos el  La principal diferencia visual

290
00:05:00,230 --> 00:05:00,240
una función o al menos el  La principal diferencia visual
 

291
00:05:00,240 --> 00:05:00,870
una función o al menos el  La principal diferencia visual

292
00:05:00,870 --> 00:05:00,880

 

293
00:05:00,880 --> 00:05:03,029

es que, en lugar de que los parámetros de entrada estén

294
00:05:03,029 --> 00:05:03,039
es que, en lugar de que los parámetros de entrada estén
 

295
00:05:03,039 --> 00:05:04,629
es que, en lugar de que los parámetros de entrada estén
entre

296
00:05:04,629 --> 00:05:04,639
entre
 

297
00:05:04,639 --> 00:05:06,790
entre
paréntesis, están dentro de estas tuberías verticales,

298
00:05:06,790 --> 00:05:06,800
paréntesis, están dentro de estas tuberías verticales,
 

299
00:05:06,800 --> 00:05:07,749
paréntesis, están dentro de estas tuberías verticales,
por lo que aquí tenemos un

300
00:05:07,749 --> 00:05:07,759
por lo que aquí tenemos un
 

301
00:05:07,759 --> 00:05:10,230
por lo que aquí tenemos un
parámetro de entrada que es num seguido de

302
00:05:10,230 --> 00:05:10,240
parámetro de entrada que es num seguido de
 

303
00:05:10,240 --> 00:05:10,950
parámetro de entrada que es num seguido de
corchetes

304
00:05:10,950 --> 00:05:10,960
corchetes
 

305
00:05:10,960 --> 00:05:13,590
corchetes
que sostienen el cuerpo de nuestro cierre y

306
00:05:13,590 --> 00:05:13,600
que sostienen el cuerpo de nuestro cierre y
 

307
00:05:13,600 --> 00:05:14,790
que sostienen el cuerpo de nuestro cierre y
si nuestro cierre fuera solo

308
00:05:14,790 --> 00:05:14,800
si nuestro cierre fuera solo
 

309
00:05:14,800 --> 00:05:16,629
si nuestro cierre fuera solo
una línea, entonces  ni siquiera necesitamos los

310
00:05:16,629 --> 00:05:16,639
una línea, entonces  ni siquiera necesitamos los
 

311
00:05:16,639 --> 00:05:19,189
una línea, entonces  ni siquiera necesitamos los
corchetes, así que dentro de nuestro cuerpo de cierre

312
00:05:19,189 --> 00:05:19,199
corchetes, así que dentro de nuestro cuerpo de cierre
 

313
00:05:19,199 --> 00:05:21,909
corchetes, así que dentro de nuestro cuerpo de cierre
ejecutamos nuestro cálculo costoso y

314
00:05:21,909 --> 00:05:21,919
ejecutamos nuestro cálculo costoso y
 

315
00:05:21,919 --> 00:05:22,629
ejecutamos nuestro cálculo costoso y
luego

316
00:05:22,629 --> 00:05:22,639
luego
 

317
00:05:22,639 --> 00:05:25,990
luego
devolvemos num finalmente al final necesitamos

318
00:05:25,990 --> 00:05:26,000
devolvemos num finalmente al final necesitamos
 

319
00:05:26,000 --> 00:05:28,790
devolvemos num finalmente al final necesitamos
este semico  lon aquí para terminar la

320
00:05:28,790 --> 00:05:28,800
este semico  lon aquí para terminar la
 

321
00:05:28,800 --> 00:05:29,830
este semico  lon aquí para terminar la
instrucción let

322
00:05:29,830 --> 00:05:29,840
instrucción let
 

323
00:05:29,840 --> 00:05:31,830
instrucción let
tenga en cuenta que nuestra variable de cierre costoso

324
00:05:31,830 --> 00:05:31,840
tenga en cuenta que nuestra variable de cierre costoso
 

325
00:05:31,840 --> 00:05:34,070
tenga en cuenta que nuestra variable de cierre costoso
no está almacenando el valor de retorno de nuestro

326
00:05:34,070 --> 00:05:34,080
no está almacenando el valor de retorno de nuestro
 

327
00:05:34,080 --> 00:05:34,870
no está almacenando el valor de retorno de nuestro
cierre,

328
00:05:34,870 --> 00:05:34,880
cierre,
 

329
00:05:34,880 --> 00:05:37,189
cierre,
sino que está almacenando el cierre en sí mismo

330
00:05:37,189 --> 00:05:37,199
sino que está almacenando el cierre en sí mismo
 

331
00:05:37,199 --> 00:05:39,590
sino que está almacenando el cierre en sí mismo
también tenga en cuenta que el cuerpo de nuestro cierre

332
00:05:39,590 --> 00:05:39,600
también tenga en cuenta que el cuerpo de nuestro cierre
 

333
00:05:39,600 --> 00:05:41,990
también tenga en cuenta que el cuerpo de nuestro cierre
es idéntico al cuerpo de nuestra

334
00:05:41,990 --> 00:05:42,000
es idéntico al cuerpo de nuestra
 

335
00:05:42,000 --> 00:05:43,670
es idéntico al cuerpo de nuestra
función costosa

336
00:05:43,670 --> 00:05:43,680
función costosa
 

337
00:05:43,680 --> 00:05:46,230
función costosa
definida aquí ahora  que nuestro cierre está definido

338
00:05:46,230 --> 00:05:46,240
definida aquí ahora  que nuestro cierre está definido
 

339
00:05:46,240 --> 00:05:47,670
definida aquí ahora  que nuestro cierre está definido
, podemos llamarlo dentro de

340
00:05:47,670 --> 00:05:47,680
, podemos llamarlo dentro de
 

341
00:05:47,680 --> 00:05:54,550
, podemos llamarlo dentro de
nuestras declaraciones de línea de impresión,

342
00:05:54,550 --> 00:05:54,560

 

343
00:05:54,560 --> 00:05:56,230

como puede ver, la sintaxis para llamar a

344
00:05:56,230 --> 00:05:56,240
como puede ver, la sintaxis para llamar a
 

345
00:05:56,240 --> 00:05:58,629
como puede ver, la sintaxis para llamar a
nuestro cierre es similar a la sintaxis para

346
00:05:58,629 --> 00:05:58,639
nuestro cierre es similar a la sintaxis para
 

347
00:05:58,639 --> 00:06:00,150
nuestro cierre es similar a la sintaxis para
llamar a una

348
00:06:00,150 --> 00:06:00,160
llamar a una
 

349
00:06:00,160 --> 00:06:02,469
llamar a una
función, especificamos nuestro nombre de variable que contiene

350
00:06:02,469 --> 00:06:02,479
función, especificamos nuestro nombre de variable que contiene
 

351
00:06:02,479 --> 00:06:03,430
función, especificamos nuestro nombre de variable que contiene
nuestro cierre

352
00:06:03,430 --> 00:06:03,440
nuestro cierre
 

353
00:06:03,440 --> 00:06:06,150
nuestro cierre
seguido de paréntesis y luego pasamos en

354
00:06:06,150 --> 00:06:06,160
seguido de paréntesis y luego pasamos en
 

355
00:06:06,160 --> 00:06:07,590
seguido de paréntesis y luego pasamos en
el  parámetros de entrada

356
00:06:07,590 --> 00:06:07,600
el  parámetros de entrada
 

357
00:06:07,600 --> 00:06:09,590
el  parámetros de entrada
ahora nuestra lógica está definida en un solo lugar

358
00:06:09,590 --> 00:06:09,600
ahora nuestra lógica está definida en un solo lugar
 

359
00:06:09,600 --> 00:06:11,189
ahora nuestra lógica está definida en un solo lugar
y solo estamos llamando a nuestra costosa

360
00:06:11,189 --> 00:06:11,199
y solo estamos llamando a nuestra costosa
 

361
00:06:11,199 --> 00:06:12,150
y solo estamos llamando a nuestra costosa
operación

362
00:06:12,150 --> 00:06:12,160
operación
 

363
00:06:12,160 --> 00:06:14,550
operación
cuando es necesario, pero volvemos con un viejo

364
00:06:14,550 --> 00:06:14,560
cuando es necesario, pero volvemos con un viejo
 

365
00:06:14,560 --> 00:06:15,749
cuando es necesario, pero volvemos con un viejo
problema que es que

366
00:06:15,749 --> 00:06:15,759
problema que es que
 

367
00:06:15,759 --> 00:06:17,670
problema que es que
en este bloque if estamos llamando a nuestra

368
00:06:17,670 --> 00:06:17,680
en este bloque if estamos llamando a nuestra
 

369
00:06:17,680 --> 00:06:19,110
en este bloque if estamos llamando a nuestra
costosa operación

370
00:06:19,110 --> 00:06:19,120
costosa operación
 

371
00:06:19,120 --> 00:06:21,830
costosa operación
dos veces, lo cual no es bueno  ahora podemos solucionar

372
00:06:21,830 --> 00:06:21,840
dos veces, lo cual no es bueno  ahora podemos solucionar
 

373
00:06:21,840 --> 00:06:23,590
dos veces, lo cual no es bueno  ahora podemos solucionar
este problema almacenando el resultado de

374
00:06:23,590 --> 00:06:23,600
este problema almacenando el resultado de
 

375
00:06:23,600 --> 00:06:25,189
este problema almacenando el resultado de
nuestra costosa llamada de cierre

376
00:06:25,189 --> 00:06:25,199
nuestra costosa llamada de cierre
 

377
00:06:25,199 --> 00:06:27,350
nuestra costosa llamada de cierre
en la parte superior de esta declaración if, pero

378
00:06:27,350 --> 00:06:27,360
en la parte superior de esta declaración if, pero
 

379
00:06:27,360 --> 00:06:28,710
en la parte superior de esta declaración if, pero
hay otra forma de resolver este

380
00:06:28,710 --> 00:06:28,720
hay otra forma de resolver este
 

381
00:06:28,720 --> 00:06:29,270
hay otra forma de resolver este
problema

382
00:06:29,270 --> 00:06:29,280
problema
 

383
00:06:29,280 --> 00:06:31,670
problema
que veremos  hable un poco

384
00:06:31,670 --> 00:06:31,680
que veremos  hable un poco
 

385
00:06:31,680 --> 00:06:33,430
que veremos  hable un poco
antes de resolver ese problema,

386
00:06:33,430 --> 00:06:33,440
antes de resolver ese problema,
 

387
00:06:33,440 --> 00:06:34,870
antes de resolver ese problema,
es posible que haya notado que no

388
00:06:34,870 --> 00:06:34,880
es posible que haya notado que no
 

389
00:06:34,880 --> 00:06:36,629
es posible que haya notado que no
teníamos que anotar el tipo de

390
00:06:36,629 --> 00:06:36,639
teníamos que anotar el tipo de
 

391
00:06:36,639 --> 00:06:37,270
teníamos que anotar el tipo de

392
00:06:37,270 --> 00:06:37,280

 

393
00:06:37,280 --> 00:06:39,350

parámetro de entrada de nuestro cierre ni teníamos que

394
00:06:39,350 --> 00:06:39,360
parámetro de entrada de nuestro cierre ni teníamos que
 

395
00:06:39,360 --> 00:06:40,710
parámetro de entrada de nuestro cierre ni teníamos que
anotar el

396
00:06:40,710 --> 00:06:40,720
anotar el
 

397
00:06:40,720 --> 00:06:42,950
anotar el
valor de retorno de nuestro cierre para funciones regulares,

398
00:06:42,950 --> 00:06:42,960
valor de retorno de nuestro cierre para funciones regulares,
 

399
00:06:42,960 --> 00:06:44,790
valor de retorno de nuestro cierre para funciones regulares,
tendríamos que especificar el tipo  de nuestros

400
00:06:44,790 --> 00:06:44,800
tendríamos que especificar el tipo  de nuestros
 

401
00:06:44,800 --> 00:06:45,909
tendríamos que especificar el tipo  de nuestros
parámetros de entrada

402
00:06:45,909 --> 00:06:45,919
parámetros de entrada
 

403
00:06:45,919 --> 00:06:48,070
parámetros de entrada
y el tipo de nuestros valores de retorno y

404
00:06:48,070 --> 00:06:48,080
y el tipo de nuestros valores de retorno y
 

405
00:06:48,080 --> 00:06:49,990
y el tipo de nuestros valores de retorno y
eso se debe a que las funciones son parte de una

406
00:06:49,990 --> 00:06:50,000
eso se debe a que las funciones son parte de una
 

407
00:06:50,000 --> 00:06:51,350
eso se debe a que las funciones son parte de una
interfaz explícita

408
00:06:51,350 --> 00:06:51,360
interfaz explícita
 

409
00:06:51,360 --> 00:06:53,749
interfaz explícita
expuesta a los usuarios, por lo que acordar los

410
00:06:53,749 --> 00:06:53,759
expuesta a los usuarios, por lo que acordar los
 

411
00:06:53,759 --> 00:06:55,110
expuesta a los usuarios, por lo que acordar los
tipos que se pasan

412
00:06:55,110 --> 00:06:55,120
tipos que se pasan
 

413
00:06:55,120 --> 00:06:57,830
tipos que se pasan
y se devuelven es importante,

414
00:06:57,830 --> 00:06:57,840
y se devuelven es importante,
 

415
00:06:57,840 --> 00:06:59,510
y se devuelven es importante,
por otro lado, los cierres suelen ser breves y

416
00:06:59,510 --> 00:06:59,520
por otro lado, los cierres suelen ser breves y
 

417
00:06:59,520 --> 00:07:02,150
por otro lado, los cierres suelen ser breves y
solo relevantes dentro de un estrecho  contexto, por lo que

418
00:07:02,150 --> 00:07:02,160
solo relevantes dentro de un estrecho  contexto, por lo que
 

419
00:07:02,160 --> 00:07:02,550
solo relevantes dentro de un estrecho  contexto, por lo que
el

420
00:07:02,550 --> 00:07:02,560
el
 

421
00:07:02,560 --> 00:07:04,870
el
compilador puede determinar los

422
00:07:04,870 --> 00:07:04,880
compilador puede determinar los
 

423
00:07:04,880 --> 00:07:05,990
compilador puede determinar los
tipos de parámetros de entrada

424
00:07:05,990 --> 00:07:06,000
tipos de parámetros de entrada
 

425
00:07:06,000 --> 00:07:08,230
tipos de parámetros de entrada
y los tipos de retorno. Esto es similar a

426
00:07:08,230 --> 00:07:08,240
y los tipos de retorno. Esto es similar a
 

427
00:07:08,240 --> 00:07:10,150
y los tipos de retorno. Esto es similar a
cómo el compilador puede determinar

428
00:07:10,150 --> 00:07:10,160
cómo el compilador puede determinar
 

429
00:07:10,160 --> 00:07:12,070
cómo el compilador puede determinar
los tipos de la mayoría de las variables.

430
00:07:12,070 --> 00:07:13,749
los tipos de la mayoría de las variables.
 

431
00:07:13,749 --> 00:07:17,430

 

432
00:07:17,430 --> 00:07:17,440

 

433
00:07:17,440 --> 00:07:19,270

a

434
00:07:19,270 --> 00:07:19,280
a
 

435
00:07:19,280 --> 00:07:21,350
a
costa de ser más detallado,

436
00:07:21,350 --> 00:07:21,360
costa de ser más detallado,
 

437
00:07:21,360 --> 00:07:23,189
costa de ser más detallado,
tenga en cuenta que las definiciones de cierre solo pueden

438
00:07:23,189 --> 00:07:23,199
tenga en cuenta que las definiciones de cierre solo pueden
 

439
00:07:23,199 --> 00:07:25,350
tenga en cuenta que las definiciones de cierre solo pueden
tener un tipo concreto inferido

440
00:07:25,350 --> 00:07:25,360
tener un tipo concreto inferido
 

441
00:07:25,360 --> 00:07:27,749
tener un tipo concreto inferido
para cada parámetro de entrada, por ejemplo,

442
00:07:27,749 --> 00:07:27,759
para cada parámetro de entrada, por ejemplo,
 

443
00:07:27,759 --> 00:07:29,110
para cada parámetro de entrada, por ejemplo,
aquí tenemos  tiene una variable llamada

444
00:07:29,110 --> 00:07:29,120
aquí tenemos  tiene una variable llamada
 

445
00:07:29,120 --> 00:07:31,189
aquí tenemos  tiene una variable llamada
cierre de ejemplo que es igual a un

446
00:07:31,189 --> 00:07:31,199
cierre de ejemplo que es igual a un
 

447
00:07:31,199 --> 00:07:33,270
cierre de ejemplo que es igual a un
cierre que toma x

448
00:07:33,270 --> 00:07:33,280
cierre que toma x
 

449
00:07:33,280 --> 00:07:36,150
cierre que toma x
y luego devuelve x ahora porque el

450
00:07:36,150 --> 00:07:36,160
y luego devuelve x ahora porque el
 

451
00:07:36,160 --> 00:07:37,589
y luego devuelve x ahora porque el
cierre se usa

452
00:07:37,589 --> 00:07:37,599
cierre se usa
 

453
00:07:37,599 --> 00:07:40,309
cierre se usa
aquí en la línea 26 con una cadena, el

454
00:07:40,309 --> 00:07:40,319
aquí en la línea 26 con una cadena, el
 

455
00:07:40,319 --> 00:07:41,670
aquí en la línea 26 con una cadena, el
compilador infiere

456
00:07:41,670 --> 00:07:41,680
compilador infiere
 

457
00:07:41,680 --> 00:07:43,830
compilador infiere
que el tipo de parámetro de entrada es una

458
00:07:43,830 --> 00:07:43,840
que el tipo de parámetro de entrada es una
 

459
00:07:43,840 --> 00:07:46,230
que el tipo de parámetro de entrada es una
cadena pero luego justo debajo en la línea

460
00:07:46,230 --> 00:07:46,240
cadena pero luego justo debajo en la línea
 

461
00:07:46,240 --> 00:07:47,270
cadena pero luego justo debajo en la línea
27

462
00:07:47,270 --> 00:07:47,280
27
 

463
00:07:47,280 --> 00:07:50,309
27
llamamos a nuestra variable de cierre de ejemplo

464
00:07:50,309 --> 00:07:50,319
llamamos a nuestra variable de cierre de ejemplo
 

465
00:07:50,319 --> 00:07:53,110
llamamos a nuestra variable de cierre de ejemplo
con un número entero, ahora el compilador se

466
00:07:53,110 --> 00:07:53,120
con un número entero, ahora el compilador se
 

467
00:07:53,120 --> 00:07:53,830
con un número entero, ahora el compilador se
quejará

468
00:07:53,830 --> 00:07:53,840
quejará
 

469
00:07:53,840 --> 00:07:55,350
quejará
y la flecha dirá que tenemos

470
00:07:55,350 --> 00:07:55,360
y la flecha dirá que tenemos
 

471
00:07:55,360 --> 00:07:57,510
y la flecha dirá que tenemos
tipos que no coinciden, esperamos una

472
00:07:57,510 --> 00:07:57,520
tipos que no coinciden, esperamos una
 

473
00:07:57,520 --> 00:07:58,550
tipos que no coinciden, esperamos una
cadena, pero obtenemos

474
00:07:58,550 --> 00:07:58,560
cadena, pero obtenemos
 

475
00:07:58,560 --> 00:08:00,950
cadena, pero obtenemos
un número entero, por lo que la forma en que funciona el compilador

476
00:08:00,950 --> 00:08:00,960
un número entero, por lo que la forma en que funciona el compilador
 

477
00:08:00,960 --> 00:08:02,869
un número entero, por lo que la forma en que funciona el compilador
es que el primer tipo pasó a nuestro

478
00:08:02,869 --> 00:08:02,879
es que el primer tipo pasó a nuestro
 

479
00:08:02,879 --> 00:08:03,670
es que el primer tipo pasó a nuestro
El cierre

480
00:08:03,670 --> 00:08:03,680
El cierre
 

481
00:08:03,680 --> 00:08:06,309
El cierre
será el tipo concreto de nuestros

482
00:08:06,309 --> 00:08:06,319
será el tipo concreto de nuestros
 

483
00:08:06,319 --> 00:08:07,189
será el tipo concreto de nuestros
parámetros de entrada.

484
00:08:07,189 --> 00:08:07,199
parámetros de entrada.
 

485
00:08:07,199 --> 00:08:08,790
parámetros de entrada.
Ahora volvamos al problema de

486
00:08:08,790 --> 00:08:08,800
Ahora volvamos al problema de
 

487
00:08:08,800 --> 00:08:11,029
Ahora volvamos al problema de
llamar a nuestro costoso cierre dos veces

488
00:08:11,029 --> 00:08:11,039
llamar a nuestro costoso cierre dos veces
 

489
00:08:11,039 --> 00:08:13,830
llamar a nuestro costoso cierre dos veces
en este bloque si nuevamente. Podríamos resolver

490
00:08:13,830 --> 00:08:13,840
en este bloque si nuevamente. Podríamos resolver
 

491
00:08:13,840 --> 00:08:15,830
en este bloque si nuevamente. Podríamos resolver
esta función creando una variable en

492
00:08:15,830 --> 00:08:15,840
esta función creando una variable en
 

493
00:08:15,840 --> 00:08:16,710
esta función creando una variable en
la parte superior de nuestro

494
00:08:16,710 --> 00:08:16,720
la parte superior de nuestro
 

495
00:08:16,720 --> 00:08:18,950
la parte superior de nuestro
bloque si y simplemente almacenando el resultado de

496
00:08:18,950 --> 00:08:18,960
bloque si y simplemente almacenando el resultado de
 

497
00:08:18,960 --> 00:08:20,309
bloque si y simplemente almacenando el resultado de
nuestro cierre costoso

498
00:08:20,309 --> 00:08:20,319
nuestro cierre costoso
 

499
00:08:20,319 --> 00:08:22,309
nuestro cierre costoso
y luego usar ese resultado en ambas

500
00:08:22,309 --> 00:08:22,319
y luego usar ese resultado en ambas
 

501
00:08:22,319 --> 00:08:23,990
y luego usar ese resultado en ambas
declaraciones de línea de impresión,

502
00:08:23,990 --> 00:08:24,000
declaraciones de línea de impresión,
 

503
00:08:24,000 --> 00:08:25,830
declaraciones de línea de impresión,
pero vamos a hacer otra cosa,

504
00:08:25,830 --> 00:08:25,840
pero vamos a hacer otra cosa,
 

505
00:08:25,840 --> 00:08:28,070
pero vamos a hacer otra cosa,
lo que haremos es usar el patrón

506
00:08:28,070 --> 00:08:28,080
lo que haremos es usar el patrón
 

507
00:08:28,080 --> 00:08:28,869
lo que haremos es usar el patrón

508
00:08:28,869 --> 00:08:28,879

 

509
00:08:28,879 --> 00:08:31,670

de memorización creando un str  uct que contendrá nuestro

510
00:08:31,670 --> 00:08:31,680
de memorización creando un str  uct que contendrá nuestro
 

511
00:08:31,680 --> 00:08:32,630
de memorización creando un str  uct que contendrá nuestro
cierre

512
00:08:32,630 --> 00:08:32,640
cierre
 

513
00:08:32,640 --> 00:08:35,430
cierre
y el resultado de nuestro cierre aquí

514
00:08:35,430 --> 00:08:35,440
y el resultado de nuestro cierre aquí
 

515
00:08:35,440 --> 00:08:37,110
y el resultado de nuestro cierre aquí
creé una estructura llamada

516
00:08:37,110 --> 00:08:37,120
creé una estructura llamada
 

517
00:08:37,120 --> 00:08:40,070
creé una estructura llamada
cacher justo encima de nuestra función de generación de entrenamiento

518
00:08:40,070 --> 00:08:40,080
cacher justo encima de nuestra función de generación de entrenamiento
 

519
00:08:40,080 --> 00:08:40,870
cacher justo encima de nuestra función de generación de entrenamiento

520
00:08:40,870 --> 00:08:40,880

 

521
00:08:40,880 --> 00:08:43,670

ahora para definir enumeraciones de estructuras o

522
00:08:43,670 --> 00:08:43,680
ahora para definir enumeraciones de estructuras o
 

523
00:08:43,680 --> 00:08:45,269
ahora para definir enumeraciones de estructuras o
incluso parámetros de función

524
00:08:45,269 --> 00:08:45,279
incluso parámetros de función
 

525
00:08:45,279 --> 00:08:47,910
incluso parámetros de función
que usan cierres, necesitamos usar

526
00:08:47,910 --> 00:08:47,920
que usan cierres, necesitamos usar
 

527
00:08:47,920 --> 00:08:48,870
que usan cierres, necesitamos usar
genéricos

528
00:08:48,870 --> 00:08:48,880
genéricos
 

529
00:08:48,880 --> 00:08:51,590
genéricos
y límites de rasgos aquí nuestro caché  Instruir

530
00:08:51,590 --> 00:08:51,600
y límites de rasgos aquí nuestro caché  Instruir
 

531
00:08:51,600 --> 00:08:52,230
y límites de rasgos aquí nuestro caché  Instruir
está usando

532
00:08:52,230 --> 00:08:52,240
está usando
 

533
00:08:52,240 --> 00:08:55,430
está usando
un genérico llamado t y a continuación definimos un

534
00:08:55,430 --> 00:08:55,440
un genérico llamado t y a continuación definimos un
 

535
00:08:55,440 --> 00:08:56,949
un genérico llamado t y a continuación definimos un
límite de rasgo para genérico

536
00:08:56,949 --> 00:08:56,959
límite de rasgo para genérico
 

537
00:08:56,959 --> 00:08:59,590
límite de rasgo para genérico
y el rasgo que estamos usando es fn abreviatura

538
00:08:59,590 --> 00:08:59,600
y el rasgo que estamos usando es fn abreviatura
 

539
00:08:59,600 --> 00:09:00,150
y el rasgo que estamos usando es fn abreviatura
de

540
00:09:00,150 --> 00:09:00,160
de
 

541
00:09:00,160 --> 00:09:02,070
de
función ahora sin entrar en cuál es el

542
00:09:02,070 --> 00:09:02,080
función ahora sin entrar en cuál es el
 

543
00:09:02,080 --> 00:09:04,310
función ahora sin entrar en cuál es el
rasgo fn, solo sepa que lo

544
00:09:04,310 --> 00:09:04,320
rasgo fn, solo sepa que lo
 

545
00:09:04,320 --> 00:09:05,750
rasgo fn, solo sepa que lo
proporciona la biblioteca estándar

546
00:09:05,750 --> 00:09:05,760
proporciona la biblioteca estándar
 

547
00:09:05,760 --> 00:09:07,829
proporciona la biblioteca estándar
y todos los cierres se implementan  uno de los

548
00:09:07,829 --> 00:09:07,839
y todos los cierres se implementan  uno de los
 

549
00:09:07,839 --> 00:09:09,670
y todos los cierres se implementan  uno de los
tres rasgos fn,

550
00:09:09,670 --> 00:09:09,680
tres rasgos fn,
 

551
00:09:09,680 --> 00:09:12,389
tres rasgos fn,
uno de ellos es fn, el otro es fn

552
00:09:12,389 --> 00:09:12,399
uno de ellos es fn, el otro es fn
 

553
00:09:12,399 --> 00:09:13,350
uno de ellos es fn, el otro es fn
mute

554
00:09:13,350 --> 00:09:13,360
mute
 

555
00:09:13,360 --> 00:09:17,269
mute
y el último es fn una vez

556
00:09:17,269 --> 00:09:17,279
y el último es fn una vez
 

557
00:09:17,279 --> 00:09:19,110
y el último es fn una vez
que veremos las diferencias entre

558
00:09:19,110 --> 00:09:19,120
que veremos las diferencias entre
 

559
00:09:19,120 --> 00:09:21,190
que veremos las diferencias entre
estos tres rasgos en un momento,

560
00:09:21,190 --> 00:09:21,200
estos tres rasgos en un momento,
 

561
00:09:21,200 --> 00:09:23,190
estos tres rasgos en un momento,
aquí agregamos tipos a la bandeja fn para

562
00:09:23,190 --> 00:09:23,200
aquí agregamos tipos a la bandeja fn para
 

563
00:09:23,200 --> 00:09:25,030
aquí agregamos tipos a la bandeja fn para
representar el  parámetros

564
00:09:25,030 --> 00:09:25,040
representar el  parámetros
 

565
00:09:25,040 --> 00:09:27,509
representar el  parámetros
de entrada de nuestro cierre, que será un

566
00:09:27,509 --> 00:09:27,519
de entrada de nuestro cierre, que será un
 

567
00:09:27,519 --> 00:09:29,430
de entrada de nuestro cierre, que será un
entero de 32 bits sin signo

568
00:09:29,430 --> 00:09:29,440
entero de 32 bits sin signo
 

569
00:09:29,440 --> 00:09:31,670
entero de 32 bits sin signo
y también los parámetros de salida,

570
00:09:31,670 --> 00:09:31,680
y también los parámetros de salida,
 

571
00:09:31,680 --> 00:09:32,630
y también los parámetros de salida,
que volverán a ser

572
00:09:32,630 --> 00:09:32,640
que volverán a ser
 

573
00:09:32,640 --> 00:09:35,269
que volverán a ser
un entero de 32 bits sin signo, luego en el

574
00:09:35,269 --> 00:09:35,279
un entero de 32 bits sin signo, luego en el
 

575
00:09:35,279 --> 00:09:37,190
un entero de 32 bits sin signo, luego en el
cuerpo de nuestra estructura tenemos

576
00:09:37,190 --> 00:09:37,200
cuerpo de nuestra estructura tenemos
 

577
00:09:37,200 --> 00:09:39,509
cuerpo de nuestra estructura tenemos
t  dos campos, el primero es el cálculo

578
00:09:39,509 --> 00:09:39,519
t  dos campos, el primero es el cálculo
 

579
00:09:39,519 --> 00:09:41,350
t  dos campos, el primero es el cálculo
que almacenará nuestro tipo genérico,

580
00:09:41,350 --> 00:09:41,360
que almacenará nuestro tipo genérico,
 

581
00:09:41,360 --> 00:09:44,070
que almacenará nuestro tipo genérico,
por lo que el cálculo podría ser cualquier cierre que se

582
00:09:44,070 --> 00:09:44,080
por lo que el cálculo podría ser cualquier cierre que se
 

583
00:09:44,080 --> 00:09:44,949
por lo que el cálculo podría ser cualquier cierre que se
encuentre con esta

584
00:09:44,949 --> 00:09:44,959
encuentre con esta
 

585
00:09:44,959 --> 00:09:48,310
encuentre con esta
bandeja enlazada aquí, luego tenemos un

586
00:09:48,310 --> 00:09:48,320
bandeja enlazada aquí, luego tenemos un
 

587
00:09:48,320 --> 00:09:50,710
bandeja enlazada aquí, luego tenemos un
valor que será un

588
00:09:50,710 --> 00:09:50,720
valor que será un
 

589
00:09:50,720 --> 00:09:51,670
valor que será un

590
00:09:51,670 --> 00:09:51,680

 

591
00:09:51,680 --> 00:09:54,230

valor entero de 32 bits opcional porque cuando

592
00:09:54,230 --> 00:09:54,240
valor entero de 32 bits opcional porque cuando
 

593
00:09:54,240 --> 00:09:55,110
valor entero de 32 bits opcional porque cuando
se inicializa nuestro caché

594
00:09:55,110 --> 00:09:55,120
se inicializa nuestro caché
 

595
00:09:55,120 --> 00:09:57,190
se inicializa nuestro caché
va a ser ninguno y

596
00:09:57,190 --> 00:09:57,200
va a ser ninguno y
 

597
00:09:57,200 --> 00:09:59,110
va a ser ninguno y
luego, una vez que llamemos a nuestro

598
00:09:59,110 --> 00:09:59,120
luego, una vez que llamemos a nuestro
 

599
00:09:59,120 --> 00:10:01,590
luego, una vez que llamemos a nuestro
cálculo, almacenaremos el valor de retorno dentro de

600
00:10:01,590 --> 00:10:01,600
cálculo, almacenaremos el valor de retorno dentro de
 

601
00:10:01,600 --> 00:10:02,870
cálculo, almacenaremos el valor de retorno dentro de
nuestro campo de valor.

602
00:10:02,870 --> 00:10:02,880
nuestro campo de valor.
 

603
00:10:02,880 --> 00:10:05,190
nuestro campo de valor.
Tenga en cuenta que las funciones regulares también

604
00:10:05,190 --> 00:10:05,200
Tenga en cuenta que las funciones regulares también
 

605
00:10:05,200 --> 00:10:06,710
Tenga en cuenta que las funciones regulares también
implementan estos tres

606
00:10:06,710 --> 00:10:06,720
implementan estos tres
 

607
00:10:06,720 --> 00:10:09,829
implementan estos tres
rasgos fn para que podamos almacenar una función regular

608
00:10:09,829 --> 00:10:09,839
rasgos fn para que podamos almacenar una función regular
 

609
00:10:09,839 --> 00:10:10,310
rasgos fn para que podamos almacenar una función regular

610
00:10:10,310 --> 00:10:10,320

 

611
00:10:10,320 --> 00:10:13,190

dentro de nuestro campo de cálculo también a

612
00:10:13,190 --> 00:10:13,200
dentro de nuestro campo de cálculo también a
 

613
00:10:13,200 --> 00:10:15,190
dentro de nuestro campo de cálculo también a
continuación.  Pegaré el

614
00:10:15,190 --> 00:10:15,200
continuación.  Pegaré el
 

615
00:10:15,200 --> 00:10:16,949
continuación.  Pegaré el
bloque de implementación para un caché o estructura

616
00:10:16,949 --> 00:10:16,959
bloque de implementación para un caché o estructura
 

617
00:10:16,959 --> 00:10:21,110
bloque de implementación para un caché o estructura
y hablaremos de ello.

618
00:10:21,110 --> 00:10:21,120

 

619
00:10:21,120 --> 00:10:23,269

Bien, analicemos esto. Tenemos nuestro

620
00:10:23,269 --> 00:10:23,279
Bien, analicemos esto. Tenemos nuestro
 

621
00:10:23,279 --> 00:10:24,389
Bien, analicemos esto. Tenemos nuestro
bloque de implementación

622
00:10:24,389 --> 00:10:24,399
bloque de implementación
 

623
00:10:24,399 --> 00:10:27,110
bloque de implementación
para cacher que tiene el mismo

624
00:10:27,110 --> 00:10:27,120
para cacher que tiene el mismo
 

625
00:10:27,120 --> 00:10:28,230
para cacher que tiene el mismo
límite genérico y de rasgos

626
00:10:28,230 --> 00:10:28,240
límite genérico y de rasgos
 

627
00:10:28,240 --> 00:10:30,630
límite genérico y de rasgos
que nuestro caché o estructura y luego la

628
00:10:30,630 --> 00:10:30,640
que nuestro caché o estructura y luego la
 

629
00:10:30,640 --> 00:10:31,590
que nuestro caché o estructura y luego la
primera función

630
00:10:31,590 --> 00:10:31,600
primera función
 

631
00:10:31,600 --> 00:10:34,150
primera función
dentro es  llamada new new es una

632
00:10:34,150 --> 00:10:34,160
dentro es  llamada new new es una
 

633
00:10:34,160 --> 00:10:35,750
dentro es  llamada new new es una
función constructora que toma un

634
00:10:35,750 --> 00:10:35,760
función constructora que toma un
 

635
00:10:35,760 --> 00:10:37,829
función constructora que toma un
cálculo que es del tipo t

636
00:10:37,829 --> 00:10:37,839
cálculo que es del tipo t
 

637
00:10:37,839 --> 00:10:39,910
cálculo que es del tipo t
nuestro cierre y luego crea un nuevo

638
00:10:39,910 --> 00:10:39,920
nuestro cierre y luego crea un nuevo
 

639
00:10:39,920 --> 00:10:41,190
nuestro cierre y luego crea un nuevo
caché que pasa

640
00:10:41,190 --> 00:10:41,200
caché que pasa
 

641
00:10:41,200 --> 00:10:44,069
caché que pasa
el cálculo y establece el valor en

642
00:10:44,069 --> 00:10:44,079
el cálculo y establece el valor en
 

643
00:10:44,079 --> 00:10:44,790
el cálculo y establece el valor en
ninguno

644
00:10:44,790 --> 00:10:44,800
ninguno
 

645
00:10:44,800 --> 00:10:47,910
ninguno
luego tenemos nuestro método de valor y es un

646
00:10:47,910 --> 00:10:47,920
luego tenemos nuestro método de valor y es un
 

647
00:10:47,920 --> 00:10:49,670
luego tenemos nuestro método de valor y es un
método porque el primer parámetro

648
00:10:49,670 --> 00:10:49,680
método porque el primer parámetro
 

649
00:10:49,680 --> 00:10:52,389
método porque el primer parámetro
es una referencia a uno mismo y, de hecho,

650
00:10:52,389 --> 00:10:52,399
es una referencia a uno mismo y, de hecho,
 

651
00:10:52,399 --> 00:10:54,470
es una referencia a uno mismo y, de hecho,
tenemos una referencia mutable a uno mismo,

652
00:10:54,470 --> 00:10:54,480
tenemos una referencia mutable a uno mismo,
 

653
00:10:54,480 --> 00:10:57,590
tenemos una referencia mutable a uno mismo,
el siguiente parámetro es arg, que es el

654
00:10:57,590 --> 00:10:57,600
el siguiente parámetro es arg, que es el
 

655
00:10:57,600 --> 00:11:00,150
el siguiente parámetro es arg, que es el
argumento que pasaremos a nuestro cierre

656
00:11:00,150 --> 00:11:00,160
argumento que pasaremos a nuestro cierre
 

657
00:11:00,160 --> 00:11:02,550
argumento que pasaremos a nuestro cierre
y es un 32 sin firmar  -bit entero el

658
00:11:02,550 --> 00:11:02,560
y es un 32 sin firmar  -bit entero el
 

659
00:11:02,560 --> 00:11:05,110
y es un 32 sin firmar  -bit entero el
tipo de retorno también es un entero de 32 bits sin signo

660
00:11:05,110 --> 00:11:05,120
tipo de retorno también es un entero de 32 bits sin signo
 

661
00:11:05,120 --> 00:11:05,829
tipo de retorno también es un entero de 32 bits sin signo

662
00:11:05,829 --> 00:11:05,839

 

663
00:11:05,839 --> 00:11:08,069

dentro del método de valor.

664
00:11:08,069 --> 00:11:09,590
dentro del método de valor.
 

665
00:11:09,590 --> 00:11:12,710

 

666
00:11:12,710 --> 00:11:13,829

 

667
00:11:13,829 --> 00:11:16,550

 

668
00:11:16,550 --> 00:11:17,509

 

669
00:11:17,509 --> 00:11:17,519

 

670
00:11:17,519 --> 00:11:19,829

cuando creamos nuestro caché por primera vez

671
00:11:19,829 --> 00:11:19,839
cuando creamos nuestro caché por primera vez
 

672
00:11:19,839 --> 00:11:21,269
cuando creamos nuestro caché por primera vez
, se establecerá en none,

673
00:11:21,269 --> 00:11:21,279
, se establecerá en none,
 

674
00:11:21,279 --> 00:11:24,310
, se establecerá en none,
por lo que ejecutaremos esta rama none

675
00:11:24,310 --> 00:11:24,320
por lo que ejecutaremos esta rama none
 

676
00:11:24,320 --> 00:11:26,389
por lo que ejecutaremos esta rama none
dentro del brazo none. Estamos creando una

677
00:11:26,389 --> 00:11:26,399
dentro del brazo none. Estamos creando una
 

678
00:11:26,399 --> 00:11:27,430
dentro del brazo none. Estamos creando una
variable llamada v

679
00:11:27,430 --> 00:11:27,440
variable llamada v
 

680
00:11:27,440 --> 00:11:29,590
variable llamada v
y estableciéndola igual al resultado de

681
00:11:29,590 --> 00:11:29,600
y estableciéndola igual al resultado de
 

682
00:11:29,600 --> 00:11:31,350
y estableciéndola igual al resultado de
llamar a nuestro

683
00:11:31,350 --> 00:11:31,360
llamar a nuestro
 

684
00:11:31,360 --> 00:11:35,030
llamar a nuestro
cierre de cálculo y pasar la variable arg

685
00:11:35,030 --> 00:11:35,040
cierre de cálculo y pasar la variable arg
 

686
00:11:35,040 --> 00:11:37,110
cierre de cálculo y pasar la variable arg
luego estamos mutando el campo de valor

687
00:11:37,110 --> 00:11:37,120
luego estamos mutando el campo de valor
 

688
00:11:37,120 --> 00:11:38,710
luego estamos mutando el campo de valor
del caché o instancia actual

689
00:11:38,710 --> 00:11:38,720
del caché o instancia actual
 

690
00:11:38,720 --> 00:11:42,069
del caché o instancia actual
y configurándolo para que pase v

691
00:11:42,069 --> 00:11:42,079
y configurándolo para que pase v
 

692
00:11:42,079 --> 00:11:44,069
y configurándolo para que pase v
aquí es donde ocurre el almacenamiento en caché estamos

693
00:11:44,069 --> 00:11:44,079
aquí es donde ocurre el almacenamiento en caché estamos
 

694
00:11:44,079 --> 00:11:45,829
aquí es donde ocurre el almacenamiento en caché estamos
almacenando en caché el valor de retorno de nuestro

695
00:11:45,829 --> 00:11:45,839
almacenando en caché el valor de retorno de nuestro
 

696
00:11:45,839 --> 00:11:46,949
almacenando en caché el valor de retorno de nuestro
cálculo

697
00:11:46,949 --> 00:11:46,959
cálculo
 

698
00:11:46,959 --> 00:11:49,110
cálculo
dentro del campo de valor y luego

699
00:11:49,110 --> 00:11:49,120
dentro del campo de valor y luego
 

700
00:11:49,120 --> 00:11:50,710
dentro del campo de valor y luego
simplemente devolvemos

701
00:11:50,710 --> 00:11:50,720
simplemente devolvemos
 

702
00:11:50,720 --> 00:11:53,190
simplemente devolvemos
v next let  Usamos nuestro efectivo o estructura

703
00:11:53,190 --> 00:11:53,200
v next let  Usamos nuestro efectivo o estructura
 

704
00:11:53,200 --> 00:11:55,350
v next let  Usamos nuestro efectivo o estructura
dentro de la función de generación de entrenamiento,

705
00:11:55,350 --> 00:11:55,360
dentro de la función de generación de entrenamiento,
 

706
00:11:55,360 --> 00:11:57,430
dentro de la función de generación de entrenamiento,
pero antes de hacerlo, primero ejecutemos

707
00:11:57,430 --> 00:11:57,440
pero antes de hacerlo, primero ejecutemos
 

708
00:11:57,440 --> 00:12:03,509
pero antes de hacerlo, primero ejecutemos
nuestro programa,

709
00:12:03,509 --> 00:12:03,519

 

710
00:12:03,519 --> 00:12:05,590

como puede ver, nuestro cierre costoso se

711
00:12:05,590 --> 00:12:05,600
como puede ver, nuestro cierre costoso se
 

712
00:12:05,600 --> 00:12:06,710
como puede ver, nuestro cierre costoso se
llamó dos veces

713
00:12:06,710 --> 00:12:06,720
llamó dos veces
 

714
00:12:06,720 --> 00:12:08,949
llamó dos veces
una vez para calcular la cantidad de flexiones

715
00:12:08,949 --> 00:12:08,959
una vez para calcular la cantidad de flexiones
 

716
00:12:08,959 --> 00:12:10,550
una vez para calcular la cantidad de flexiones
y la segunda vez para calcular

717
00:12:10,550 --> 00:12:10,560
y la segunda vez para calcular
 

718
00:12:10,560 --> 00:12:12,870
y la segunda vez para calcular
la cantidad de  sit-ups, hagamos esto

719
00:12:12,870 --> 00:12:12,880
la cantidad de  sit-ups, hagamos esto
 

720
00:12:12,880 --> 00:12:14,710
la cantidad de  sit-ups, hagamos esto
más eficiente envolviendo nuestra

721
00:12:14,710 --> 00:12:14,720
más eficiente envolviendo nuestra
 

722
00:12:14,720 --> 00:12:15,430
más eficiente envolviendo nuestra
definición de cierre

723
00:12:15,430 --> 00:12:15,440
definición de cierre
 

724
00:12:15,440 --> 00:12:27,990
definición de cierre
aquí dentro de nuestra estructura de cajero

725
00:12:27,990 --> 00:12:28,000

 

726
00:12:28,000 --> 00:12:29,750

aquí estamos llamando a la nueva función en

727
00:12:29,750 --> 00:12:29,760
aquí estamos llamando a la nueva función en
 

728
00:12:29,760 --> 00:12:31,829
aquí estamos llamando a la nueva función en
nuestro efectivo o estructura y pasando

729
00:12:31,829 --> 00:12:31,839
nuestro efectivo o estructura y pasando
 

730
00:12:31,839 --> 00:12:34,069
nuestro efectivo o estructura y pasando
nuestro cierre que se establecerá en el

731
00:12:34,069 --> 00:12:34,079
nuestro cierre que se establecerá en el
 

732
00:12:34,079 --> 00:12:35,430
nuestro cierre que se establecerá en el
campo de cálculo

733
00:12:35,430 --> 00:12:35,440
campo de cálculo
 

734
00:12:35,440 --> 00:12:37,670
campo de cálculo
en nuestra estructura de efectivo vamos  cambie nuestro

735
00:12:37,670 --> 00:12:37,680
en nuestra estructura de efectivo vamos  cambie nuestro
 

736
00:12:37,680 --> 00:12:42,870
en nuestra estructura de efectivo vamos  cambie nuestro
nombre de variable a resultado en caché

737
00:12:42,870 --> 00:12:42,880

 

738
00:12:42,880 --> 00:12:44,310

, también querremos hacer que nuestra variable sea

739
00:12:44,310 --> 00:12:44,320
, también querremos hacer que nuestra variable sea
 

740
00:12:44,320 --> 00:12:45,910
, también querremos hacer que nuestra variable sea
mutable porque llamaremos al

741
00:12:45,910 --> 00:12:45,920
mutable porque llamaremos al
 

742
00:12:45,920 --> 00:12:46,790
mutable porque llamaremos al
método de valor

743
00:12:46,790 --> 00:12:46,800
método de valor
 

744
00:12:46,800 --> 00:12:52,389
método de valor
que mutará nuestro caché o estructura,

745
00:12:52,389 --> 00:12:52,399
que mutará nuestro caché o estructura,
 

746
00:12:52,399 --> 00:12:54,230
que mutará nuestro caché o estructura,
luego, en lugar de llamar a un

747
00:12:54,230 --> 00:12:54,240
luego, en lugar de llamar a un
 

748
00:12:54,240 --> 00:12:55,509
luego, en lugar de llamar a un
cierre costoso, llamaremos

749
00:12:55,509 --> 00:12:55,519
cierre costoso, llamaremos
 

750
00:12:55,519 --> 00:13:07,590
cierre costoso, llamaremos
al valor de punto de cachedresult,

751
00:13:07,590 --> 00:13:07,600
al valor de punto de cachedresult,
 

752
00:13:07,600 --> 00:13:13,269
al valor de punto de cachedresult,
sigamos adelante y  Ejecute nuestro programa nuevamente

753
00:13:13,269 --> 00:13:13,279

 

754
00:13:13,279 --> 00:13:15,269

y, como puede ver, esta vez solo

755
00:13:15,269 --> 00:13:15,279
y, como puede ver, esta vez solo
 

756
00:13:15,279 --> 00:13:17,590
y, como puede ver, esta vez solo
llamamos a nuestra

757
00:13:17,590 --> 00:13:17,600
llamamos a nuestra
 

758
00:13:17,600 --> 00:13:20,389
llamamos a nuestra
costosa operación una vez.

759
00:13:20,389 --> 00:13:22,470
costosa operación una vez.
 

760
00:13:22,470 --> 00:13:23,350

 

761
00:13:23,350 --> 00:13:23,360

 

762
00:13:23,360 --> 00:13:25,590

contextos pero hay dos

763
00:13:25,590 --> 00:13:25,600
contextos pero hay dos
 

764
00:13:25,600 --> 00:13:27,910
contextos pero hay dos
problemas que nos impiden hacer este

765
00:13:27,910 --> 00:13:27,920
problemas que nos impiden hacer este
 

766
00:13:27,920 --> 00:13:30,230
problemas que nos impiden hacer este
problema número uno es llamar a nuestro

767
00:13:30,230 --> 00:13:30,240
problema número uno es llamar a nuestro
 

768
00:13:30,240 --> 00:13:32,069
problema número uno es llamar a nuestro
método de valor que devolverá

769
00:13:32,069 --> 00:13:32,079
método de valor que devolverá
 

770
00:13:32,079 --> 00:13:35,190
método de valor que devolverá
el mismo valor sin importar cuál sea el

771
00:13:35,190 --> 00:13:35,200
el mismo valor sin importar cuál sea el
 

772
00:13:35,200 --> 00:13:37,829
el mismo valor sin importar cuál sea el
parámetro de entrada arg, por ejemplo, digamos que

773
00:13:37,829 --> 00:13:37,839
parámetro de entrada arg, por ejemplo, digamos que
 

774
00:13:37,839 --> 00:13:39,910
parámetro de entrada arg, por ejemplo, digamos que
la primera vez que llamamos al método de valor

775
00:13:39,910 --> 00:13:39,920
la primera vez que llamamos al método de valor
 

776
00:13:39,920 --> 00:13:43,110
la primera vez que llamamos al método de valor
pasamos en uno  como el valor de arg

777
00:13:43,110 --> 00:13:43,120
pasamos en uno  como el valor de arg
 

778
00:13:43,120 --> 00:13:44,389
pasamos en uno  como el valor de arg
porque esta es la primera vez que llamamos

779
00:13:44,389 --> 00:13:44,399
porque esta es la primera vez que llamamos
 

780
00:13:44,399 --> 00:13:46,790
porque esta es la primera vez que llamamos
al método de valor self.value

781
00:13:46,790 --> 00:13:46,800
al método de valor self.value
 

782
00:13:46,800 --> 00:13:48,230
al método de valor self.value
se evaluará como none,

783
00:13:48,230 --> 00:13:48,240
se evaluará como none,
 

784
00:13:48,240 --> 00:13:50,150
se evaluará como none,
así que iremos a la rama none y

785
00:13:50,150 --> 00:13:50,160
así que iremos a la rama none y
 

786
00:13:50,160 --> 00:13:51,350
así que iremos a la rama none y
luego llamaremos a nuestro

787
00:13:51,350 --> 00:13:51,360
luego llamaremos a nuestro
 

788
00:13:51,360 --> 00:13:53,910
luego llamaremos a nuestro
cierre con nuestro arg, que

789
00:13:53,910 --> 00:13:53,920
cierre con nuestro arg, que
 

790
00:13:53,920 --> 00:13:55,269
cierre con nuestro arg, que
será igual  a 1.

791
00:13:55,269 --> 00:13:55,279
será igual  a 1.
 

792
00:13:55,279 --> 00:13:57,670
será igual  a 1.
luego tomaremos el valor resultante y

793
00:13:57,670 --> 00:13:57,680
luego tomaremos el valor resultante y
 

794
00:13:57,680 --> 00:13:58,870
luego tomaremos el valor resultante y
lo guardaremos dentro de

795
00:13:58,870 --> 00:13:58,880
lo guardaremos dentro de
 

796
00:13:58,880 --> 00:14:01,670
lo guardaremos dentro de
self.value ahora imagina que llamamos a nuestro

797
00:14:01,670 --> 00:14:01,680
self.value ahora imagina que llamamos a nuestro
 

798
00:14:01,680 --> 00:14:02,150
self.value ahora imagina que llamamos a nuestro
método de valor

799
00:14:02,150 --> 00:14:02,160
método de valor
 

800
00:14:02,160 --> 00:14:04,870
método de valor
nuevamente pero esta vez pasamos 2 como el

801
00:14:04,870 --> 00:14:04,880
nuevamente pero esta vez pasamos 2 como el
 

802
00:14:04,880 --> 00:14:05,590
nuevamente pero esta vez pasamos 2 como el
valor para

803
00:14:05,590 --> 00:14:05,600
valor para
 

804
00:14:05,600 --> 00:14:08,470
valor para
arg esta vez self.value ya existe,

805
00:14:08,470 --> 00:14:08,480
arg esta vez self.value ya existe,
 

806
00:14:08,480 --> 00:14:10,550
arg esta vez self.value ya existe,
así que iremos  en el brazo de suma y simplemente

807
00:14:10,550 --> 00:14:10,560
así que iremos  en el brazo de suma y simplemente
 

808
00:14:10,560 --> 00:14:13,350
así que iremos  en el brazo de suma y simplemente
devuelva el valor almacenado en suma, esto es

809
00:14:13,350 --> 00:14:13,360
devuelva el valor almacenado en suma, esto es
 

810
00:14:13,360 --> 00:14:14,389
devuelva el valor almacenado en suma, esto es
problemático porque

811
00:14:14,389 --> 00:14:14,399
problemático porque
 

812
00:14:14,399 --> 00:14:16,790
problemático porque
r pasa a nuestro cierre, lo que significa

813
00:14:16,790 --> 00:14:16,800
r pasa a nuestro cierre, lo que significa
 

814
00:14:16,800 --> 00:14:18,790
r pasa a nuestro cierre, lo que significa
que podría cambiar el valor resultante

815
00:14:18,790 --> 00:14:18,800
que podría cambiar el valor resultante
 

816
00:14:18,800 --> 00:14:19,430
que podría cambiar el valor resultante
proveniente

817
00:14:19,430 --> 00:14:19,440
proveniente
 

818
00:14:19,440 --> 00:14:21,269
proveniente
de nuestro cierre, pero con nuestra

819
00:14:21,269 --> 00:14:21,279
de nuestro cierre, pero con nuestra
 

820
00:14:21,279 --> 00:14:23,430
de nuestro cierre, pero con nuestra
implementación actual, el valor siempre

821
00:14:23,430 --> 00:14:23,440
implementación actual, el valor siempre
 

822
00:14:23,440 --> 00:14:25,590
implementación actual, el valor siempre
será igual a la re  El resultado de llamar a

823
00:14:25,590 --> 00:14:25,600
será igual a la re  El resultado de llamar a
 

824
00:14:25,600 --> 00:14:27,829
será igual a la re  El resultado de llamar a
nuestro cierre con el argumento pasado

825
00:14:27,829 --> 00:14:27,839
nuestro cierre con el argumento pasado
 

826
00:14:27,839 --> 00:14:29,110
nuestro cierre con el argumento pasado
en la primera llamada

827
00:14:29,110 --> 00:14:29,120
en la primera llamada
 

828
00:14:29,120 --> 00:14:31,350
en la primera llamada
para valorar lo que básicamente digo es que en

829
00:14:31,350 --> 00:14:31,360
para valorar lo que básicamente digo es que en
 

830
00:14:31,360 --> 00:14:33,189
para valorar lo que básicamente digo es que en
lugar de cobrar un valor

831
00:14:33,189 --> 00:14:33,199
lugar de cobrar un valor
 

832
00:14:33,199 --> 00:14:35,590
lugar de cobrar un valor
sin importar el argumento

833
00:14:35,590 --> 00:14:35,600
sin importar el argumento
 

834
00:14:35,600 --> 00:14:36,710
sin importar el argumento
pasado, necesitamos cobrar

835
00:14:36,710 --> 00:14:36,720
pasado, necesitamos cobrar
 

836
00:14:36,720 --> 00:14:39,110
pasado, necesitamos cobrar
un valor por cada argumento que se

837
00:14:39,110 --> 00:14:39,120
un valor por cada argumento que se
 

838
00:14:39,120 --> 00:14:40,790
un valor por cada argumento que se
pasa porque el argumento

839
00:14:40,790 --> 00:14:40,800
pasa porque el argumento
 

840
00:14:40,800 --> 00:14:43,750
pasa porque el argumento
influye en el valor como ejercicio,

841
00:14:43,750 --> 00:14:43,760
influye en el valor como ejercicio,
 

842
00:14:43,760 --> 00:14:45,910
influye en el valor como ejercicio,
puede arreglar esta implementación almacenando un

843
00:14:45,910 --> 00:14:45,920
puede arreglar esta implementación almacenando un
 

844
00:14:45,920 --> 00:14:46,629
puede arreglar esta implementación almacenando un
hashmap en

845
00:14:46,629 --> 00:14:46,639
hashmap en
 

846
00:14:46,639 --> 00:14:48,949
hashmap en
lugar de un solo valor, las claves

847
00:14:48,949 --> 00:14:48,959
lugar de un solo valor, las claves
 

848
00:14:48,959 --> 00:14:50,389
lugar de un solo valor, las claves
del hashmap serán

849
00:14:50,389 --> 00:14:50,399
del hashmap serán
 

850
00:14:50,399 --> 00:14:53,110
del hashmap serán
el argumento pasado al valor y los

851
00:14:53,110 --> 00:14:53,120
el argumento pasado al valor y los
 

852
00:14:53,120 --> 00:14:54,470
el argumento pasado al valor y los
valores en su hashmap

853
00:14:54,470 --> 00:14:54,480
valores en su hashmap
 

854
00:14:54,480 --> 00:14:57,189
valores en su hashmap
serán el resultado de llamar al

855
00:14:57,189 --> 00:14:57,199
serán el resultado de llamar al
 

856
00:14:57,199 --> 00:14:58,069
serán el resultado de llamar al
cierre

857
00:14:58,069 --> 00:14:58,079
cierre
 

858
00:14:58,079 --> 00:15:00,550
cierre
con el argumento entonces  dentro del cuerpo

859
00:15:00,550 --> 00:15:00,560
con el argumento entonces  dentro del cuerpo
 

860
00:15:00,560 --> 00:15:01,670
con el argumento entonces  dentro del cuerpo
de este método de valor

861
00:15:01,670 --> 00:15:01,680
de este método de valor
 

862
00:15:01,680 --> 00:15:04,150
de este método de valor
, deberá buscar el argumento dentro de

863
00:15:04,150 --> 00:15:04,160
, deberá buscar el argumento dentro de
 

864
00:15:04,160 --> 00:15:05,110
, deberá buscar el argumento dentro de
su mapa hash

865
00:15:05,110 --> 00:15:05,120
su mapa hash
 

866
00:15:05,120 --> 00:15:07,829
su mapa hash
y, si existe un valor para ese argumento,

867
00:15:07,829 --> 00:15:07,839
y, si existe un valor para ese argumento,
 

868
00:15:07,839 --> 00:15:09,110
y, si existe un valor para ese argumento,
simplemente devuelva

869
00:15:09,110 --> 00:15:09,120
simplemente devuelva
 

870
00:15:09,120 --> 00:15:11,590
simplemente devuelva
el valor y, si no existe, ejecute

871
00:15:11,590 --> 00:15:11,600
el valor y, si no existe, ejecute
 

872
00:15:11,600 --> 00:15:13,829
el valor y, si no existe, ejecute
su cálculo costoso y almacene el

873
00:15:13,829 --> 00:15:13,839
su cálculo costoso y almacene el
 

874
00:15:13,839 --> 00:15:14,550
su cálculo costoso y almacene el
resultado

875
00:15:14,550 --> 00:15:14,560
resultado
 

876
00:15:14,560 --> 00:15:16,790
resultado
dentro  su mapa hash El segundo problema

877
00:15:16,790 --> 00:15:16,800
dentro  su mapa hash El segundo problema
 

878
00:15:16,800 --> 00:15:18,949
dentro  su mapa hash El segundo problema
con nuestra implementación de caché

879
00:15:18,949 --> 00:15:18,959
con nuestra implementación de caché
 

880
00:15:18,959 --> 00:15:21,350
con nuestra implementación de caché
es que estamos usando tipos codificados, por

881
00:15:21,350 --> 00:15:21,360
es que estamos usando tipos codificados, por
 

882
00:15:21,360 --> 00:15:22,710
es que estamos usando tipos codificados, por
ejemplo, estamos diciendo que nuestro

883
00:15:22,710 --> 00:15:22,720
ejemplo, estamos diciendo que nuestro
 

884
00:15:22,720 --> 00:15:25,189
ejemplo, estamos diciendo que nuestro
cierre debe aceptar un número entero y

885
00:15:25,189 --> 00:15:25,199
cierre debe aceptar un número entero y
 

886
00:15:25,199 --> 00:15:26,470
cierre debe aceptar un número entero y
devolver un número entero

887
00:15:26,470 --> 00:15:26,480
devolver un número entero
 

888
00:15:26,480 --> 00:15:28,949
devolver un número entero
y nuestro valor también debe ser un número entero

889
00:15:28,949 --> 00:15:28,959
y nuestro valor también debe ser un número entero
 

890
00:15:28,959 --> 00:15:29,590
y nuestro valor también debe ser un número entero

891
00:15:29,590 --> 00:15:29,600

 

892
00:15:29,600 --> 00:15:32,069

para solucionar esto, simplemente puede usar valores genéricos en

893
00:15:32,069 --> 00:15:32,079
para solucionar esto, simplemente puede usar valores genéricos en
 

894
00:15:32,079 --> 00:15:32,710
para solucionar esto, simplemente puede usar valores genéricos en
lugar

895
00:15:32,710 --> 00:15:32,720
lugar
 

896
00:15:32,720 --> 00:15:34,870
lugar
de valores codificados. Lo último de lo que

897
00:15:34,870 --> 00:15:34,880
de valores codificados. Lo último de lo que
 

898
00:15:34,880 --> 00:15:36,629
de valores codificados. Lo último de lo que
quiero hablar es de capturar el

899
00:15:36,629 --> 00:15:36,639
quiero hablar es de capturar el
 

900
00:15:36,639 --> 00:15:38,389
quiero hablar es de capturar el
entorno con cierres, a

901
00:15:38,389 --> 00:15:38,399
entorno con cierres, a
 

902
00:15:38,399 --> 00:15:41,189
entorno con cierres, a
diferencia de las funciones, los cierres tienen acceso a las

903
00:15:41,189 --> 00:15:41,199
diferencia de las funciones, los cierres tienen acceso a las
 

904
00:15:41,199 --> 00:15:42,069
diferencia de las funciones, los cierres tienen acceso a las
variables

905
00:15:42,069 --> 00:15:42,079
variables
 

906
00:15:42,079 --> 00:15:43,990
variables
que se definen dentro del  alcance en el

907
00:15:43,990 --> 00:15:44,000
que se definen dentro del  alcance en el
 

908
00:15:44,000 --> 00:15:45,829
que se definen dentro del  alcance en el
que se define el cierre

909
00:15:45,829 --> 00:15:45,839
que se define el cierre
 

910
00:15:45,839 --> 00:15:47,749
que se define el cierre
aquí hay un ejemplo simple en la parte superior

911
00:15:47,749 --> 00:15:47,759
aquí hay un ejemplo simple en la parte superior
 

912
00:15:47,759 --> 00:15:48,870
aquí hay un ejemplo simple en la parte superior
tenemos una variable llamada

913
00:15:48,870 --> 00:15:48,880
tenemos una variable llamada
 

914
00:15:48,880 --> 00:15:51,590
tenemos una variable llamada
x que es igual a cuatro luego tenemos un

915
00:15:51,590 --> 00:15:51,600
x que es igual a cuatro luego tenemos un
 

916
00:15:51,600 --> 00:15:53,350
x que es igual a cuatro luego tenemos un
cierre llamado igual a x

917
00:15:53,350 --> 00:15:53,360
cierre llamado igual a x
 

918
00:15:53,360 --> 00:15:55,749
cierre llamado igual a x
que toma una variable llamada z y

919
00:15:55,749 --> 00:15:55,759
que toma una variable llamada z y
 

920
00:15:55,759 --> 00:15:57,509
que toma una variable llamada z y
luego devuelve un booleano

921
00:15:57,509 --> 00:15:57,519
luego devuelve un booleano
 

922
00:15:57,519 --> 00:15:59,110
luego devuelve un booleano
el booleano va  para ser igual a esta

923
00:15:59,110 --> 00:15:59,120
el booleano va  para ser igual a esta
 

924
00:15:59,120 --> 00:16:00,949
el booleano va  para ser igual a esta
expresión, z es igual

925
00:16:00,949 --> 00:16:00,959
expresión, z es igual
 

926
00:16:00,959 --> 00:16:03,590
expresión, z es igual
a x ahora, aunque x se define

927
00:16:03,590 --> 00:16:03,600
a x ahora, aunque x se define
 

928
00:16:03,600 --> 00:16:05,110
a x ahora, aunque x se define
fuera de nuestro cierre,

929
00:16:05,110 --> 00:16:05,120
fuera de nuestro cierre,
 

930
00:16:05,120 --> 00:16:07,430
fuera de nuestro cierre,
nuestro cierre todavía tiene acceso a x

931
00:16:07,430 --> 00:16:07,440
nuestro cierre todavía tiene acceso a x
 

932
00:16:07,440 --> 00:16:09,030
nuestro cierre todavía tiene acceso a x
porque ambos están definidos dentro del

933
00:16:09,030 --> 00:16:09,040
porque ambos están definidos dentro del
 

934
00:16:09,040 --> 00:16:09,990
porque ambos están definidos dentro del
mismo ámbito,

935
00:16:09,990 --> 00:16:10,000
mismo ámbito,
 

936
00:16:10,000 --> 00:16:11,990
mismo ámbito,
entonces definimos una variable llamada y y la

937
00:16:11,990 --> 00:16:12,000
entonces definimos una variable llamada y y la
 

938
00:16:12,000 --> 00:16:13,749
entonces definimos una variable llamada y y la
establecemos también igual  a cuatro

939
00:16:13,749 --> 00:16:13,759
establecemos también igual  a cuatro
 

940
00:16:13,759 --> 00:16:16,710
establecemos también igual  a cuatro
finalmente llamamos a nuestro cierre pasando y

941
00:16:16,710 --> 00:16:16,720
finalmente llamamos a nuestro cierre pasando y
 

942
00:16:16,720 --> 00:16:18,470
finalmente llamamos a nuestro cierre pasando y
la llamada a nuestro cierre está envuelta

943
00:16:18,470 --> 00:16:18,480
la llamada a nuestro cierre está envuelta
 

944
00:16:18,480 --> 00:16:20,310
la llamada a nuestro cierre está envuelta
dentro de una macro de aserción

945
00:16:20,310 --> 00:16:20,320
dentro de una macro de aserción
 

946
00:16:20,320 --> 00:16:22,629
dentro de una macro de aserción
que entrará en pánico si la

947
00:16:22,629 --> 00:16:22,639
que entrará en pánico si la
 

948
00:16:22,639 --> 00:16:23,590
que entrará en pánico si la
función de la torre de llamadas da

949
00:16:23,590 --> 00:16:23,600
función de la torre de llamadas da
 

950
00:16:23,600 --> 00:16:26,069
función de la torre de llamadas da
como resultado falso, así que sigamos adelante y ejecutemos nuestro

951
00:16:26,069 --> 00:16:26,079
como resultado falso, así que sigamos adelante y ejecutemos nuestro
 

952
00:16:26,079 --> 00:16:28,710
como resultado falso, así que sigamos adelante y ejecutemos nuestro
programa

953
00:16:28,710 --> 00:16:28,720

 

954
00:16:28,720 --> 00:16:31,670

y como puede ver, no entramos en pánico ahora

955
00:16:31,670 --> 00:16:31,680
y como puede ver, no entramos en pánico ahora
 

956
00:16:31,680 --> 00:16:33,509
y como puede ver, no entramos en pánico ahora
, veamos qué sucedería si usáramos una

957
00:16:33,509 --> 00:16:33,519
, veamos qué sucedería si usáramos una
 

958
00:16:33,519 --> 00:16:34,230
, veamos qué sucedería si usáramos una
función en

959
00:16:34,230 --> 00:16:34,240
función en
 

960
00:16:34,240 --> 00:16:36,710
función en
lugar de un cierre, así que cambiaremos nuestro

961
00:16:36,710 --> 00:16:37,670
lugar de un cierre, así que cambiaremos nuestro
 

962
00:16:37,670 --> 00:16:37,680

 

963
00:16:37,680 --> 00:16:41,829

cierre igual a x en una función

964
00:16:41,829 --> 00:16:41,839

 

965
00:16:41,839 --> 00:16:43,910

aquí, puede ver algunas líneas onduladas rojas

966
00:16:43,910 --> 00:16:43,920
aquí, puede ver algunas líneas onduladas rojas
 

967
00:16:43,920 --> 00:16:45,910
aquí, puede ver algunas líneas onduladas rojas
debajo de x y si i  desplace el cursor sobre usted puede

968
00:16:45,910 --> 00:16:45,920
debajo de x y si i  desplace el cursor sobre usted puede
 

969
00:16:45,920 --> 00:16:47,030
debajo de x y si i  desplace el cursor sobre usted puede
ver que el error

970
00:16:47,030 --> 00:16:47,040
ver que el error
 

971
00:16:47,040 --> 00:16:49,509
ver que el error
no puede capturar el entorno dinámico dentro de

972
00:16:49,509 --> 00:16:49,519
no puede capturar el entorno dinámico dentro de
 

973
00:16:49,519 --> 00:16:50,470
no puede capturar el entorno dinámico dentro de
una función,

974
00:16:50,470 --> 00:16:50,480
una función,
 

975
00:16:50,480 --> 00:16:52,710
una función,
use un cierre en su lugar, por lo que el compilador en

976
00:16:52,710 --> 00:16:52,720
use un cierre en su lugar, por lo que el compilador en
 

977
00:16:52,720 --> 00:16:54,230
use un cierre en su lugar, por lo que el compilador en
realidad nos dice que usemos

978
00:16:54,230 --> 00:16:54,240
realidad nos dice que usemos
 

979
00:16:54,240 --> 00:16:56,550
realidad nos dice que usemos
un cierre en lugar de una función porque los

980
00:16:56,550 --> 00:16:56,560
un cierre en lugar de una función porque los
 

981
00:16:56,560 --> 00:16:58,230
un cierre en lugar de una función porque los
cierres pueden capturar su

982
00:16:58,230 --> 00:16:58,240
cierres pueden capturar su
 

983
00:16:58,240 --> 00:16:58,949
cierres pueden capturar su

984
00:16:58,949 --> 00:16:58,959

 

985
00:16:58,959 --> 00:17:01,189

entorno, tienen que usar memoria adicional  para almacenar

986
00:17:01,189 --> 00:17:01,199
entorno, tienen que usar memoria adicional  para almacenar
 

987
00:17:01,199 --> 00:17:02,310
entorno, tienen que usar memoria adicional  para almacenar
ese contexto,

988
00:17:02,310 --> 00:17:02,320
ese contexto,
 

989
00:17:02,320 --> 00:17:04,069
ese contexto,
pero debido a que las funciones no capturan

990
00:17:04,069 --> 00:17:04,079
pero debido a que las funciones no capturan
 

991
00:17:04,079 --> 00:17:06,069
pero debido a que las funciones no capturan
su entorno, no incurren en la

992
00:17:06,069 --> 00:17:06,079
su entorno, no incurren en la
 

993
00:17:06,079 --> 00:17:07,429
su entorno, no incurren en la
misma sobrecarga.

994
00:17:07,429 --> 00:17:09,189
misma sobrecarga.
 

995
00:17:09,189 --> 00:17:10,870

 

996
00:17:10,870 --> 00:17:13,110

 

997
00:17:13,110 --> 00:17:14,549

 

998
00:17:14,549 --> 00:17:17,590

 

999
00:17:17,590 --> 00:17:18,870

 

1000
00:17:18,870 --> 00:17:18,880

 

1001
00:17:18,880 --> 00:17:21,909

o tomando prestadas inmutablemente estas tres

1002
00:17:21,909 --> 00:17:21,919
o tomando prestadas inmutablemente estas tres
 

1003
00:17:21,919 --> 00:17:23,669
o tomando prestadas inmutablemente estas tres
formas de capturar el entorno

1004
00:17:23,669 --> 00:17:23,679
formas de capturar el entorno
 

1005
00:17:23,679 --> 00:17:26,069
formas de capturar el entorno
están codificadas en los rasgos de función de los que

1006
00:17:26,069 --> 00:17:26,079
están codificadas en los rasgos de función de los que
 

1007
00:17:26,079 --> 00:17:27,350
están codificadas en los rasgos de función de los que
hablamos anteriormente,

1008
00:17:27,350 --> 00:17:27,360
hablamos anteriormente,
 

1009
00:17:27,360 --> 00:17:30,470
hablamos anteriormente,
que son fn una vez f y mu y

1010
00:17:30,470 --> 00:17:30,480
que son fn una vez f y mu y
 

1011
00:17:30,480 --> 00:17:33,270
que son fn una vez f y mu y
fn fn una vez  toma posesión de las

1012
00:17:33,270 --> 00:17:33,280
fn fn una vez  toma posesión de las
 

1013
00:17:33,280 --> 00:17:34,870
fn fn una vez  toma posesión de las
variables dentro del

1014
00:17:34,870 --> 00:17:34,880
variables dentro del
 

1015
00:17:34,880 --> 00:17:36,710
variables dentro del
entorno de las clausuras, la parte del nombre

1016
00:17:36,710 --> 00:17:36,720
entorno de las clausuras, la parte del nombre
 

1017
00:17:36,720 --> 00:17:38,630
entorno de las clausuras, la parte del nombre
representa el hecho de que las clausuras

1018
00:17:38,630 --> 00:17:38,640
representa el hecho de que las clausuras
 

1019
00:17:38,640 --> 00:17:40,230
representa el hecho de que las clausuras
no pueden tomar posesión de las mismas

1020
00:17:40,230 --> 00:17:40,240
no pueden tomar posesión de las mismas
 

1021
00:17:40,240 --> 00:17:42,150
no pueden tomar posesión de las mismas
variables más de una vez,

1022
00:17:42,150 --> 00:17:42,160
variables más de una vez,
 

1023
00:17:42,160 --> 00:17:43,990
variables más de una vez,
por lo que estas clausuras solo pueden

1024
00:17:43,990 --> 00:17:44,000
por lo que estas clausuras solo pueden
 

1025
00:17:44,000 --> 00:17:45,510
por lo que estas clausuras solo pueden
llamarse unas fn mu

1026
00:17:45,510 --> 00:17:45,520
llamarse unas fn mu
 

1027
00:17:45,520 --> 00:17:48,549
llamarse unas fn mu
toma valores prestados de forma mutable y fn

1028
00:17:48,549 --> 00:17:48,559
toma valores prestados de forma mutable y fn
 

1029
00:17:48,559 --> 00:17:51,029
toma valores prestados de forma mutable y fn
toma prestados valores de forma inmutable  cuando crea

1030
00:17:51,029 --> 00:17:51,039
toma prestados valores de forma inmutable  cuando crea
 

1031
00:17:51,039 --> 00:17:52,870
toma prestados valores de forma inmutable  cuando crea
un cierre, el óxido infiere cuál de estos

1032
00:17:52,870 --> 00:17:52,880
un cierre, el óxido infiere cuál de estos
 

1033
00:17:52,880 --> 00:17:54,070
un cierre, el óxido infiere cuál de estos
rasgos usar en

1034
00:17:54,070 --> 00:17:54,080
rasgos usar en
 

1035
00:17:54,080 --> 00:17:56,630
rasgos usar en
función de cómo usa los valores dentro

1036
00:17:56,630 --> 00:17:56,640
función de cómo usa los valores dentro
 

1037
00:17:56,640 --> 00:17:58,230
función de cómo usa los valores dentro
del entorno de cierres

1038
00:17:58,230 --> 00:17:58,240
del entorno de cierres
 

1039
00:17:58,240 --> 00:18:00,230
del entorno de cierres
, sin embargo, podríamos obligar al cierre a

1040
00:18:00,230 --> 00:18:00,240
, sin embargo, podríamos obligar al cierre a
 

1041
00:18:00,240 --> 00:18:02,710
, sin embargo, podríamos obligar al cierre a
tomar posesión de los valores que usa

1042
00:18:02,710 --> 00:18:02,720
tomar posesión de los valores que usa
 

1043
00:18:02,720 --> 00:18:05,270
tomar posesión de los valores que usa
dentro de su entorno usando la

1044
00:18:05,270 --> 00:18:05,280
dentro de su entorno usando la
 

1045
00:18:05,280 --> 00:18:05,909
dentro de su entorno usando la
palabra

1046
00:18:05,909 --> 00:18:05,919
palabra
 

1047
00:18:05,919 --> 00:18:08,070
palabra
clave move delante del  cierre esto es principalmente

1048
00:18:08,070 --> 00:18:08,080
clave move delante del  cierre esto es principalmente
 

1049
00:18:08,080 --> 00:18:09,590
clave move delante del  cierre esto es principalmente
útil cuando está pasando un cierre

1050
00:18:09,590 --> 00:18:09,600
útil cuando está pasando un cierre
 

1051
00:18:09,600 --> 00:18:10,470
útil cuando está pasando un cierre
de un hilo

1052
00:18:10,470 --> 00:18:10,480
de un hilo
 

1053
00:18:10,480 --> 00:18:12,470
de un hilo
a otro hilo, por lo que también puede pasar

1054
00:18:12,470 --> 00:18:12,480
a otro hilo, por lo que también puede pasar
 

1055
00:18:12,480 --> 00:18:14,310
a otro hilo, por lo que también puede pasar
la propiedad de las variables de un

1056
00:18:14,310 --> 00:18:14,320
la propiedad de las variables de un
 

1057
00:18:14,320 --> 00:18:14,789
la propiedad de las variables de un
hilo

1058
00:18:14,789 --> 00:18:14,799
hilo
 

1059
00:18:14,799 --> 00:18:17,029
hilo
a otro hilo, por ejemplo, en este

1060
00:18:17,029 --> 00:18:17,039
a otro hilo, por ejemplo, en este
 

1061
00:18:17,039 --> 00:18:19,029
a otro hilo, por ejemplo, en este
caso x es igual a un vector

1062
00:18:19,029 --> 00:18:19,039
caso x es igual a un vector
 

1063
00:18:19,039 --> 00:18:21,750
caso x es igual a un vector
, tenemos nuestro cierre  lo que no cambia,

1064
00:18:21,750 --> 00:18:21,760
, tenemos nuestro cierre  lo que no cambia,
 

1065
00:18:21,760 --> 00:18:22,789
, tenemos nuestro cierre  lo que no cambia,
luego imprimimos

1066
00:18:22,789 --> 00:18:22,799
luego imprimimos
 

1067
00:18:22,799 --> 00:18:25,990
luego imprimimos
x y luego tenemos y igual a un

1068
00:18:25,990 --> 00:18:26,000
x y luego tenemos y igual a un
 

1069
00:18:26,000 --> 00:18:26,950
x y luego tenemos y igual a un
vector también

1070
00:18:26,950 --> 00:18:26,960
vector también
 

1071
00:18:26,960 --> 00:18:28,950
vector también
y luego llamamos a nuestro cierre nuevamente

1072
00:18:28,950 --> 00:18:28,960
y luego llamamos a nuestro cierre nuevamente
 

1073
00:18:28,960 --> 00:18:31,110
y luego llamamos a nuestro cierre nuevamente
pasando y y afirmando

1074
00:18:31,110 --> 00:18:31,120
pasando y y afirmando
 

1075
00:18:31,120 --> 00:18:33,750
pasando y y afirmando
que retu  ahora es cierto porque dentro de

1076
00:18:33,750 --> 00:18:33,760
que retu  ahora es cierto porque dentro de
 

1077
00:18:33,760 --> 00:18:34,549
que retu  ahora es cierto porque dentro de
nuestro cierre

1078
00:18:34,549 --> 00:18:34,559
nuestro cierre
 

1079
00:18:34,559 --> 00:18:37,590
nuestro cierre
solo estamos evaluando x contra z,

1080
00:18:37,590 --> 00:18:37,600
solo estamos evaluando x contra z,
 

1081
00:18:37,600 --> 00:18:40,150
solo estamos evaluando x contra z,
no estamos tomando posesión de x dentro de

1082
00:18:40,150 --> 00:18:40,160
no estamos tomando posesión de x dentro de
 

1083
00:18:40,160 --> 00:18:41,029
no estamos tomando posesión de x dentro de
nuestro cierre,

1084
00:18:41,029 --> 00:18:41,039
nuestro cierre,
 

1085
00:18:41,039 --> 00:18:43,350
nuestro cierre,
pero nuevamente podríamos forzar el cierre para que

1086
00:18:43,350 --> 00:18:43,360
pero nuevamente podríamos forzar el cierre para que
 

1087
00:18:43,360 --> 00:18:44,390
pero nuevamente podríamos forzar el cierre para que
tome

1088
00:18:44,390 --> 00:18:44,400
tome
 

1089
00:18:44,400 --> 00:18:46,870
tome
posesión especificando la palabra clave mover delante

1090
00:18:46,870 --> 00:18:46,880
posesión especificando la palabra clave mover delante
 

1091
00:18:46,880 --> 00:18:50,710
posesión especificando la palabra clave mover delante
de nuestra definición de cierre

1092
00:18:50,710 --> 00:18:50,720

 

1093
00:18:50,720 --> 00:18:53,669

ahora nuestro cierre  toma posesión de x

1094
00:18:53,669 --> 00:18:53,679
ahora nuestro cierre  toma posesión de x
 

1095
00:18:53,679 --> 00:18:54,070
ahora nuestro cierre  toma posesión de x
y

1096
00:18:54,070 --> 00:18:54,080
y
 

1097
00:18:54,080 --> 00:18:56,310
y
recibimos un error en nuestra declaración de impresión

1098
00:18:56,310 --> 00:18:56,320
recibimos un error en nuestra declaración de impresión
 

1099
00:18:56,320 --> 00:18:58,390
recibimos un error en nuestra declaración de impresión
debajo de la definición de nuestro cierre

1100
00:18:58,390 --> 00:18:58,400
debajo de la definición de nuestro cierre
 

1101
00:18:58,400 --> 00:19:00,310
debajo de la definición de nuestro cierre
si paso el mouse sobre los garabatos rojos,

1102
00:19:00,310 --> 00:19:00,320
si paso el mouse sobre los garabatos rojos,
 

1103
00:19:00,320 --> 00:19:01,590
si paso el mouse sobre los garabatos rojos,
puede ver que dice

1104
00:19:01,590 --> 00:19:01,600
puede ver que dice
 

1105
00:19:01,600 --> 00:19:04,230
puede ver que dice
que estamos usando un valor prestado después de que se

1106
00:19:04,230 --> 00:19:04,240
que estamos usando un valor prestado después de que se
 

1107
00:19:04,240 --> 00:19:04,950
que estamos usando un valor prestado después de que se
ha movido

1108
00:19:04,950 --> 00:19:04,960
ha movido
 

1109
00:19:04,960 --> 00:19:07,350
ha movido
esto tiene sentido porque arriba  nuestro

1110
00:19:07,350 --> 00:19:07,360
esto tiene sentido porque arriba  nuestro
 

1111
00:19:07,360 --> 00:19:09,270
esto tiene sentido porque arriba  nuestro
cierre toma posesión de x,

1112
00:19:09,270 --> 00:19:09,280
cierre toma posesión de x,
 

1113
00:19:09,280 --> 00:19:12,150
cierre toma posesión de x,
por lo que no podemos usar x después de que se haya movido

1114
00:19:12,150 --> 00:19:12,160
por lo que no podemos usar x después de que se haya movido
 

1115
00:19:12,160 --> 00:19:13,029
por lo que no podemos usar x después de que se haya movido
aquí abajo, de acuerdo,

1116
00:19:13,029 --> 00:19:13,039
aquí abajo, de acuerdo,
 

1117
00:19:13,039 --> 00:19:14,789
aquí abajo, de acuerdo,
eso concluye la primera parte del

1118
00:19:14,789 --> 00:19:14,799
eso concluye la primera parte del
 

1119
00:19:14,799 --> 00:19:16,870
eso concluye la primera parte del
capítulo 13 en el que cubrimos los

1120
00:19:16,870 --> 00:19:16,880
capítulo 13 en el que cubrimos los
 

1121
00:19:16,880 --> 00:19:19,029
capítulo 13 en el que cubrimos los
cierres, ahora sé que los cierres pueden ser

1122
00:19:19,029 --> 00:19:19,039
cierres, ahora sé que los cierres pueden ser
 

1123
00:19:19,039 --> 00:19:20,470
cierres, ahora sé que los cierres pueden ser
difíciles de digerir

1124
00:19:20,470 --> 00:19:20,480
difíciles de digerir
 

1125
00:19:20,480 --> 00:19:22,230
difíciles de digerir
y no los analizamos todos.  las

1126
00:19:22,230 --> 00:19:22,240
y no los analizamos todos.  las
 

1127
00:19:22,240 --> 00:19:24,070
y no los analizamos todos.  las
formas posibles de usar cierres,

1128
00:19:24,070 --> 00:19:24,080
formas posibles de usar cierres,
 

1129
00:19:24,080 --> 00:19:25,909
formas posibles de usar cierres,
así que si desea ver otro video

1130
00:19:25,909 --> 00:19:25,919
así que si desea ver otro video
 

1131
00:19:25,919 --> 00:19:28,150
así que si desea ver otro video
sobre cierres con más ejemplos,

1132
00:19:28,150 --> 00:19:28,160
sobre cierres con más ejemplos,
 

1133
00:19:28,160 --> 00:19:30,470
sobre cierres con más ejemplos,
comente a continuación y, por supuesto, si

1134
00:19:30,470 --> 00:19:30,480
comente a continuación y, por supuesto, si
 

1135
00:19:30,480 --> 00:19:31,510
comente a continuación y, por supuesto, si
disfruta este video,

1136
00:19:31,510 --> 00:19:31,520
disfruta este video,
 

1137
00:19:31,520 --> 00:19:33,350
disfruta este video,
asegúrese de darle un pulgar hacia arriba en el

1138
00:19:33,350 --> 00:19:33,360
asegúrese de darle un pulgar hacia arriba en el
 

1139
00:19:33,360 --> 00:19:34,630
asegúrese de darle un pulgar hacia arriba en el
próximo video.  oing

1140
00:19:34,630 --> 00:19:34,640
próximo video.  oing
 

1141
00:19:34,640 --> 00:19:36,870
próximo video.  oing
iteradores así que si quieres ser notificado

1142
00:19:36,870 --> 00:19:36,880
iteradores así que si quieres ser notificado
 

1143
00:19:36,880 --> 00:19:37,990
iteradores así que si quieres ser notificado
de eso, asegúrate

1144
00:19:37,990 --> 00:19:38,000
de eso, asegúrate
 

1145
00:19:38,000 --> 00:19:40,870
de eso, asegúrate
de presionar suscribirte y con eso te veré

1146
00:19:40,870 --> 00:19:40,880
de presionar suscribirte y con eso te veré
 

1147
00:19:40,880 --> 00:19:41,590
de presionar suscribirte y con eso te veré

1148
00:19:41,590 --> 00:19:41,600

 

1149
00:19:41,600 --> 00:19:52,470

en el próximo

1150
00:19:52,470 --> 00:19:52,480
en el próximo
 

1151
00:19:52,480 --> 00:19:54,559
en el próximo

