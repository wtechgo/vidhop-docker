1
00:00:00,560 --> 00:00:02,629

willkommen zurück, russ gang, wenn du neu

2
00:00:02,629 --> 00:00:02,639
willkommen zurück, russ gang, wenn du neu
 

3
00:00:02,639 --> 00:00:04,630
willkommen zurück, russ gang, wenn du neu
hier bist, mein name ist bogdan und auf diesem kanal

4
00:00:04,630 --> 00:00:04,640
hier bist, mein name ist bogdan und auf diesem kanal
 

5
00:00:04,640 --> 00:00:05,829
hier bist, mein name ist bogdan und auf diesem kanal
dreht sich alles um

6
00:00:05,829 --> 00:00:05,839
dreht sich alles um
 

7
00:00:05,839 --> 00:00:07,990
dreht sich alles um
die rust-programmiersprache

8
00:00:07,990 --> 00:00:10,070
die rust-programmiersprache
 

9
00:00:10,070 --> 00:00:11,350

 

10
00:00:11,350 --> 00:00:14,390

 

11
00:00:14,390 --> 00:00:14,400

 

12
00:00:14,400 --> 00:00:16,470

Gehen wir Kapitel

13
00:00:16,470 --> 00:00:16,480
Gehen wir Kapitel
 

14
00:00:16,480 --> 00:00:17,830
Gehen wir Kapitel
13 durch, insbesondere

15
00:00:17,830 --> 00:00:17,840
13 durch, insbesondere
 

16
00:00:17,840 --> 00:00:20,310
13 durch, insbesondere
Teil 1 von Kapitel 13, in dem wir über Closures sprechen werden.

17
00:00:20,310 --> 00:00:20,320
Teil 1 von Kapitel 13, in dem wir über Closures sprechen werden.
 

18
00:00:20,320 --> 00:00:21,109
Teil 1 von Kapitel 13, in dem wir über Closures sprechen werden.

19
00:00:21,109 --> 00:00:21,119

 

20
00:00:21,119 --> 00:00:30,550

Lassen Sie uns also zunächst einmal etwas einrosten.

21
00:00:30,550 --> 00:00:30,560
Lassen Sie uns also zunächst einmal etwas einrosten.
 

22
00:00:30,560 --> 00:00:33,270
Lassen Sie uns also zunächst einmal etwas einrosten.
Was sind Closures? Closures

23
00:00:33,270 --> 00:00:33,280
Was sind Closures? Closures
 

24
00:00:33,280 --> 00:00:34,470
Was sind Closures? Closures
sind wie Funktionen,

25
00:00:34,470 --> 00:00:34,480
sind wie Funktionen,
 

26
00:00:34,480 --> 00:00:36,150
sind wie Funktionen,
außer dass sie anonym sind, was bedeutet,

27
00:00:36,150 --> 00:00:36,160
außer dass sie anonym sind, was bedeutet,
 

28
00:00:36,160 --> 00:00:37,830
außer dass sie anonym sind, was bedeutet,
dass sie keine Namen haben, die

29
00:00:37,830 --> 00:00:37,840
dass sie keine Namen haben, die
 

30
00:00:37,840 --> 00:00:40,150
dass sie keine Namen haben, die
sie haben könnten  als Variablen gespeichert und

31
00:00:40,150 --> 00:00:40,160
sie haben könnten  als Variablen gespeichert und
 

32
00:00:40,160 --> 00:00:41,030
sie haben könnten  als Variablen gespeichert und
weitergegeben werden,

33
00:00:41,030 --> 00:00:41,040
weitergegeben werden,
 

34
00:00:41,040 --> 00:00:43,270
weitergegeben werden,
sie könnten sogar als Eingabeparameter

35
00:00:43,270 --> 00:00:43,280
sie könnten sogar als Eingabeparameter
 

36
00:00:43,280 --> 00:00:44,150
sie könnten sogar als Eingabeparameter

37
00:00:44,150 --> 00:00:44,160

 

38
00:00:44,160 --> 00:00:46,549

an eine Funktion übergeben werden, und sie erfassen die

39
00:00:46,549 --> 00:00:46,559
an eine Funktion übergeben werden, und sie erfassen die
 

40
00:00:46,559 --> 00:00:47,590
an eine Funktion übergeben werden, und sie erfassen die
Variablen

41
00:00:47,590 --> 00:00:47,600
Variablen
 

42
00:00:47,600 --> 00:00:50,150
Variablen
innerhalb des Bereichs, in dem sie

43
00:00:50,150 --> 00:00:50,160
innerhalb des Bereichs, in dem sie
 

44
00:00:50,160 --> 00:00:50,950
innerhalb des Bereichs, in dem sie
definiert sind,

45
00:00:50,950 --> 00:00:50,960
definiert sind,
 

46
00:00:50,960 --> 00:00:53,029
definiert sind,
um Closures besser zu verstehen.

47
00:00:53,029 --> 00:00:53,039
um Closures besser zu verstehen.
 

48
00:00:53,039 --> 00:00:54,389
um Closures besser zu verstehen.
Wir verwenden sie im folgenden

49
00:00:54,389 --> 00:00:54,399
Wir verwenden sie im folgenden
 

50
00:00:54,399 --> 00:00:56,470
Wir verwenden sie im folgenden
Beispiel.  Wenn Sie ein Back-

51
00:00:56,470 --> 00:00:56,480
Beispiel.  Wenn Sie ein Back-
 

52
00:00:56,480 --> 00:00:58,389
Beispiel.  Wenn Sie ein Back-
End für eine Fitness-App erstellen

53
00:00:58,389 --> 00:00:58,399
End für eine Fitness-App erstellen
 

54
00:00:58,399 --> 00:01:00,950
End für eine Fitness-App erstellen
und das Back-End in Rust integriert ist,

55
00:01:00,950 --> 00:01:00,960
und das Back-End in Rust integriert ist,
 

56
00:01:00,960 --> 00:01:02,790
und das Back-End in Rust integriert ist,
generiert die Fitness-App angepasste

57
00:01:02,790 --> 00:01:02,800
generiert die Fitness-App angepasste
 

58
00:01:02,800 --> 00:01:04,390
generiert die Fitness-App angepasste
Workouts für einen Benutzer,

59
00:01:04,390 --> 00:01:04,400
Workouts für einen Benutzer,
 

60
00:01:04,400 --> 00:01:07,109
Workouts für einen Benutzer,
basierend auf verschiedenen Faktoren wie dem Alter des

61
00:01:07,109 --> 00:01:07,119
basierend auf verschiedenen Faktoren wie dem Alter des
 

62
00:01:07,119 --> 00:01:07,910
basierend auf verschiedenen Faktoren wie dem Alter des
Body-Mass-

63
00:01:07,910 --> 00:01:07,920
Body-Mass-
 

64
00:01:07,920 --> 00:01:11,190
Body-Mass-
Index-Trainings  renz und intensitätsniveau

65
00:01:11,190 --> 00:01:11,200
Index-Trainings  renz und intensitätsniveau
 

66
00:01:11,200 --> 00:01:12,149
Index-Trainings  renz und intensitätsniveau

67
00:01:12,149 --> 00:01:12,159

 

68
00:01:12,159 --> 00:01:14,310

jetzt spielt die implementierung dieses algorithmus

69
00:01:14,310 --> 00:01:14,320
jetzt spielt die implementierung dieses algorithmus
 

70
00:01:14,320 --> 00:01:15,670
jetzt spielt die implementierung dieses algorithmus
keine so große rolle,

71
00:01:15,670 --> 00:01:15,680
keine so große rolle,
 

72
00:01:15,680 --> 00:01:17,270
keine so große rolle,
was zählt ist, dass ein teil dieses

73
00:01:17,270 --> 00:01:17,280
was zählt ist, dass ein teil dieses
 

74
00:01:17,280 --> 00:01:19,510
was zählt ist, dass ein teil dieses
algorithmus eine berechnung durchführt

75
00:01:19,510 --> 00:01:19,520
algorithmus eine berechnung durchführt
 

76
00:01:19,520 --> 00:01:21,590
algorithmus eine berechnung durchführt
, die teuer ist und ein paar sekunden dauert

77
00:01:21,590 --> 00:01:23,109
, die teuer ist und ein paar sekunden dauert
 

78
00:01:23,109 --> 00:01:25,510

 

79
00:01:25,510 --> 00:01:26,630

 

80
00:01:26,630 --> 00:01:26,640

 

81
00:01:26,640 --> 00:01:29,749

Berechnung, die

82
00:01:29,749 --> 00:01:30,310
Berechnung, die
 

83
00:01:30,310 --> 00:01:30,320

 

84
00:01:30,320 --> 00:01:32,630

eine Intensität aufnimmt und dann eine

85
00:01:32,630 --> 00:01:32,640
eine Intensität aufnimmt und dann eine
 

86
00:01:32,640 --> 00:01:34,390
eine Intensität aufnimmt und dann eine
langsame Berechnung ausgibt,

87
00:01:34,390 --> 00:01:34,400
langsame Berechnung ausgibt,
 

88
00:01:34,400 --> 00:01:36,710
langsame Berechnung ausgibt,
lässt den Thread für zwei Sekunden schlafen

89
00:01:36,710 --> 00:01:36,720
lässt den Thread für zwei Sekunden schlafen
 

90
00:01:36,720 --> 00:01:38,950
lässt den Thread für zwei Sekunden schlafen
und gibt die Intensität zurück

91
00:01:38,950 --> 00:01:41,030
und gibt die Intensität zurück
 

92
00:01:41,030 --> 00:01:42,230

 

93
00:01:42,230 --> 00:01:44,870

 

94
00:01:44,870 --> 00:01:44,880

 

95
00:01:44,880 --> 00:01:46,710

Dies ist eine

96
00:01:46,710 --> 00:01:46,720
Dies ist eine
 

97
00:01:46,720 --> 00:01:48,630
Dies ist eine
Funktion, die wir noch nicht erstellt haben

98
00:01:48,630 --> 00:01:48,640
Funktion, die wir noch nicht erstellt haben
 

99
00:01:48,640 --> 00:01:50,310
Funktion, die wir noch nicht erstellt haben
und die ein Training generiert. Sie verwendet zwei

100
00:01:50,310 --> 00:01:50,320
und die ein Training generiert. Sie verwendet zwei
 

101
00:01:50,320 --> 00:01:52,710
und die ein Training generiert. Sie verwendet zwei
Parameter, die Intensität, die ein Benutzer

102
00:01:52,710 --> 00:01:52,720
Parameter, die Intensität, die ein Benutzer
 

103
00:01:52,720 --> 00:01:53,670
Parameter, die Intensität, die ein Benutzer
angegeben hat,

104
00:01:53,670 --> 00:01:53,680
angegeben hat,
 

105
00:01:53,680 --> 00:01:55,830
angegeben hat,
und eine Zufallszahl, um

106
00:01:55,830 --> 00:01:55,840
und eine Zufallszahl, um
 

107
00:01:55,840 --> 00:01:58,149
und eine Zufallszahl, um
dem generierten Training jetzt etwas Abwechslung zu verleihen,

108
00:01:58,149 --> 00:01:58,159
dem generierten Training jetzt etwas Abwechslung zu verleihen,
 

109
00:01:58,159 --> 00:01:59,990
dem generierten Training jetzt etwas Abwechslung zu verleihen,
da wir

110
00:01:59,990 --> 00:02:00,000
da wir
 

111
00:02:00,000 --> 00:02:01,830
da wir
in diesem Beispiel nicht wirklich das Frontend

112
00:02:01,830 --> 00:02:01,840
in diesem Beispiel nicht wirklich das Frontend
 

113
00:02:01,840 --> 00:02:04,469
in diesem Beispiel nicht wirklich das Frontend
erstellen.  Ich gebe eine simulierte Intensität von

114
00:02:04,469 --> 00:02:04,479
erstellen.  Ich gebe eine simulierte Intensität von
 

115
00:02:04,479 --> 00:02:05,030
erstellen.  Ich gebe eine simulierte Intensität von
10 ein

116
00:02:05,030 --> 00:02:05,040
10 ein
 

117
00:02:05,040 --> 00:02:07,109
10 ein
und für die Zufallszahl könnten wir

118
00:02:07,109 --> 00:02:07,119
und für die Zufallszahl könnten wir
 

119
00:02:07,119 --> 00:02:08,949
und für die Zufallszahl könnten wir
die Zufallszahl verwenden und tatsächlich eine Zufallszahl erzeugen,

120
00:02:08,949 --> 00:02:09,749
die Zufallszahl verwenden und tatsächlich eine Zufallszahl erzeugen,
 

121
00:02:09,749 --> 00:02:09,759

 

122
00:02:09,759 --> 00:02:11,510

aber auch das ist nein  Um uns in diesem

123
00:02:11,510 --> 00:02:11,520
aber auch das ist nein  Um uns in diesem
 

124
00:02:11,520 --> 00:02:13,589
aber auch das ist nein  Um uns in diesem
Beispiel darauf zu konzentrieren, setzen wir die Zufallszahl einfach

125
00:02:13,589 --> 00:02:13,599
Beispiel darauf zu konzentrieren, setzen wir die Zufallszahl einfach
 

126
00:02:13,599 --> 00:02:15,350
Beispiel darauf zu konzentrieren, setzen wir die Zufallszahl einfach
auf eine fest codierte

127
00:02:15,350 --> 00:02:15,360
auf eine fest codierte
 

128
00:02:15,360 --> 00:02:17,670
auf eine fest codierte
Sieben. Als Nächstes definieren wir die generierte

129
00:02:17,670 --> 00:02:17,680
Sieben. Als Nächstes definieren wir die generierte
 

130
00:02:17,680 --> 00:02:18,869
Sieben. Als Nächstes definieren wir die generierte
Trainingsfunktion

131
00:02:18,869 --> 00:02:18,879
Trainingsfunktion
 

132
00:02:18,879 --> 00:02:21,990
Trainingsfunktion
direkt unter der Hauptgenerierungs-

133
00:02:21,990 --> 00:02:22,000
direkt unter der Hauptgenerierungs-
 

134
00:02:22,000 --> 00:02:23,990
direkt unter der Hauptgenerierungs-
Trainingsfunktion, die eine

135
00:02:23,990 --> 00:02:24,000
Trainingsfunktion, die eine
 

136
00:02:24,000 --> 00:02:25,910
Trainingsfunktion, die eine
Intensität und eine Zufallszahl enthält,

137
00:02:25,910 --> 00:02:25,920
Intensität und eine Zufallszahl enthält,
 

138
00:02:25,920 --> 00:02:28,630
Intensität und eine Zufallszahl enthält,
wenn die Intensität weniger als 25 beträgt  Wir

139
00:02:28,630 --> 00:02:28,640
wenn die Intensität weniger als 25 beträgt  Wir
 

140
00:02:28,640 --> 00:02:30,710
wenn die Intensität weniger als 25 beträgt  Wir
drucken do x Anzahl Liegestütze

141
00:02:30,710 --> 00:02:30,720
drucken do x Anzahl Liegestütze
 

142
00:02:30,720 --> 00:02:33,030
drucken do x Anzahl Liegestütze
und x Anzahl Sit-Ups aus, um herauszufinden,

143
00:02:33,030 --> 00:02:33,040
und x Anzahl Sit-Ups aus, um herauszufinden,
 

144
00:02:33,040 --> 00:02:34,949
und x Anzahl Sit-Ups aus, um herauszufinden,
wie viele Liegestütze und Setups zu machen sind.

145
00:02:34,949 --> 00:02:34,959
wie viele Liegestütze und Setups zu machen sind.
 

146
00:02:34,959 --> 00:02:37,990
wie viele Liegestütze und Setups zu machen sind.
Wir nennen unsere teure Berechnung. Wenn die

147
00:02:37,990 --> 00:02:38,000
Wir nennen unsere teure Berechnung. Wenn die
 

148
00:02:38,000 --> 00:02:39,910
Wir nennen unsere teure Berechnung. Wenn die
Intensität über 25 liegt

149
00:02:39,910 --> 00:02:39,920
Intensität über 25 liegt
 

150
00:02:39,920 --> 00:02:42,710
Intensität über 25 liegt
, gehen wir hier zur Else-Klausel über

151
00:02:42,710 --> 00:02:42,720
, gehen wir hier zur Else-Klausel über
 

152
00:02:42,720 --> 00:02:43,030
, gehen wir hier zur Else-Klausel über
Überprüfen Sie

153
00:02:43,030 --> 00:02:43,040
Überprüfen Sie
 

154
00:02:43,040 --> 00:02:45,750
Überprüfen Sie
unsere Zufallszahl, wenn es genau drei ist, geben

155
00:02:45,750 --> 00:02:45,760
unsere Zufallszahl, wenn es genau drei ist, geben
 

156
00:02:45,760 --> 00:02:47,509
unsere Zufallszahl, wenn es genau drei ist, geben
wir sie aus, machen Sie eine Pause,

157
00:02:47,509 --> 00:02:47,519
wir sie aus, machen Sie eine Pause,
 

158
00:02:47,519 --> 00:02:49,910
wir sie aus, machen Sie eine Pause,
andernfalls pronomen wir run x Anzahl der

159
00:02:49,910 --> 00:02:49,920
andernfalls pronomen wir run x Anzahl der
 

160
00:02:49,920 --> 00:02:51,670
andernfalls pronomen wir run x Anzahl der
Minuten und erneut, um die

161
00:02:51,670 --> 00:02:51,680
Minuten und erneut, um die
 

162
00:02:51,680 --> 00:02:53,110
Minuten und erneut, um die
Anzahl der Minuten zu berechnen, verwenden

163
00:02:53,110 --> 00:02:53,120
Anzahl der Minuten zu berechnen, verwenden
 

164
00:02:53,120 --> 00:02:55,350
Anzahl der Minuten zu berechnen, verwenden
wir unsere teure Berechnungsfunktion

165
00:02:55,350 --> 00:02:55,360
wir unsere teure Berechnungsfunktion
 

166
00:02:55,360 --> 00:02:56,150
wir unsere teure Berechnungsfunktion
,

167
00:02:56,150 --> 00:02:56,160
,
 

168
00:02:56,160 --> 00:02:57,910
,
jetzt funktioniert es, aber es könnte

169
00:02:57,910 --> 00:02:57,920
jetzt funktioniert es, aber es könnte
 

170
00:02:57,920 --> 00:02:59,750
jetzt funktioniert es, aber es könnte
eine Überarbeitung erfordern  dass wir

171
00:02:59,750 --> 00:02:59,760
eine Überarbeitung erfordern  dass wir
 

172
00:02:59,760 --> 00:03:01,350
eine Überarbeitung erfordern  dass wir
unsere teure Funktion

173
00:03:01,350 --> 00:03:01,360
unsere teure Funktion
 

174
00:03:01,360 --> 00:03:03,910
unsere teure Funktion
an mehreren Stellen aufrufen. Wenn wir also die

175
00:03:03,910 --> 00:03:03,920
an mehreren Stellen aufrufen. Wenn wir also die
 

176
00:03:03,920 --> 00:03:05,350
an mehreren Stellen aufrufen. Wenn wir also die
Art und Weise ändern, wie die Funktion aufgerufen wird,

177
00:03:05,350 --> 00:03:05,360
Art und Weise ändern, wie die Funktion aufgerufen wird,
 

178
00:03:05,360 --> 00:03:07,910
Art und Weise ändern, wie die Funktion aufgerufen wird,
zum Beispiel wenn wir einen weiteren Parameter hinzufügen, müssen

179
00:03:07,910 --> 00:03:07,920
zum Beispiel wenn wir einen weiteren Parameter hinzufügen, müssen
 

180
00:03:07,920 --> 00:03:09,110
zum Beispiel wenn wir einen weiteren Parameter hinzufügen, müssen
wir

181
00:03:09,110 --> 00:03:09,120
wir
 

182
00:03:09,120 --> 00:03:11,589
wir
alle Aufrufseiten ändern, auch wir rufen unsere

183
00:03:11,589 --> 00:03:11,599
alle Aufrufseiten ändern, auch wir rufen unsere
 

184
00:03:11,599 --> 00:03:12,710
alle Aufrufseiten ändern, auch wir rufen unsere
teuren Funktionen auf  on

185
00:03:12,710 --> 00:03:12,720
teuren Funktionen auf  on
 

186
00:03:12,720 --> 00:03:15,589
teuren Funktionen auf  on
unnötigerweise mehrmals, zum Beispiel

187
00:03:15,589 --> 00:03:15,599
unnötigerweise mehrmals, zum Beispiel
 

188
00:03:15,599 --> 00:03:16,710
unnötigerweise mehrmals, zum Beispiel
in diesem if-Block

189
00:03:16,710 --> 00:03:16,720
in diesem if-Block
 

190
00:03:16,720 --> 00:03:18,790
in diesem if-Block
rufen wir unsere teure Funktion zweimal auf,

191
00:03:18,790 --> 00:03:18,800
rufen wir unsere teure Funktion zweimal auf,
 

192
00:03:18,800 --> 00:03:21,030
rufen wir unsere teure Funktion zweimal auf,
wenn wir sie wirklich nur einmal aufrufen müssen,

193
00:03:21,030 --> 00:03:21,040
wenn wir sie wirklich nur einmal aufrufen müssen,
 

194
00:03:21,040 --> 00:03:23,190
wenn wir sie wirklich nur einmal aufrufen müssen,
und übergeben dann den Rückgabewert an

195
00:03:23,190 --> 00:03:23,200
und übergeben dann den Rückgabewert an
 

196
00:03:23,200 --> 00:03:24,789
und übergeben dann den Rückgabewert an
diese beiden print-Anweisungen.

197
00:03:24,789 --> 00:03:24,799
diese beiden print-Anweisungen.
 

198
00:03:24,799 --> 00:03:26,630
diese beiden print-Anweisungen.
Dies könnte für normale Funktionen in Ordnung sein,

199
00:03:26,630 --> 00:03:26,640
Dies könnte für normale Funktionen in Ordnung sein,
 

200
00:03:26,640 --> 00:03:28,470
Dies könnte für normale Funktionen in Ordnung sein,
aber denken Sie daran, dass dies

201
00:03:28,470 --> 00:03:28,480
aber denken Sie daran, dass dies
 

202
00:03:28,480 --> 00:03:30,229
aber denken Sie daran, dass dies
teuer ist  Funktion, deren

203
00:03:30,229 --> 00:03:30,239
teuer ist  Funktion, deren
 

204
00:03:30,239 --> 00:03:32,550
teuer ist  Funktion, deren
Ausführung zwei Sekunden dauert, daher möchten wir die

205
00:03:32,550 --> 00:03:32,560
Ausführung zwei Sekunden dauert, daher möchten wir die
 

206
00:03:32,560 --> 00:03:34,470
Ausführung zwei Sekunden dauert, daher möchten wir die
Anzahl der Aufrufe dieser Funktion

207
00:03:34,470 --> 00:03:34,480
Anzahl der Aufrufe dieser Funktion
 

208
00:03:34,480 --> 00:03:37,110
Anzahl der Aufrufe dieser Funktion
so oft wie möglich begrenzen. Lassen Sie uns diese beiden Probleme beheben,

209
00:03:37,110 --> 00:03:37,120
so oft wie möglich begrenzen. Lassen Sie uns diese beiden Probleme beheben,
 

210
00:03:37,120 --> 00:03:37,750
so oft wie möglich begrenzen. Lassen Sie uns diese beiden Probleme beheben,

211
00:03:37,750 --> 00:03:37,760

 

212
00:03:37,760 --> 00:03:39,670

indem wir das Ergebnis unseres

213
00:03:39,670 --> 00:03:39,680
indem wir das Ergebnis unseres
 

214
00:03:39,680 --> 00:03:41,830
indem wir das Ergebnis unseres
teuren Funktionsaufrufs in einer Variablen speichern,

215
00:03:41,830 --> 00:03:41,840
teuren Funktionsaufrufs in einer Variablen speichern,
 

216
00:03:41,840 --> 00:03:43,270
teuren Funktionsaufrufs in einer Variablen speichern,
sodass wir eine neue Variable erstellen  Am

217
00:03:43,270 --> 00:03:43,280
sodass wir eine neue Variable erstellen  Am
 

218
00:03:43,280 --> 00:03:44,869
sodass wir eine neue Variable erstellen  Am
Anfang unserer Funktion nennen

219
00:03:44,869 --> 00:03:44,879
Anfang unserer Funktion nennen
 

220
00:03:44,879 --> 00:03:50,470
Anfang unserer Funktion nennen
wir es teures Ergebnis

221
00:03:50,470 --> 00:03:50,480

 

222
00:03:50,480 --> 00:03:52,789

und setzen es gleich unserem teuren

223
00:03:52,789 --> 00:03:52,799
und setzen es gleich unserem teuren
 

224
00:03:52,799 --> 00:03:56,710
und setzen es gleich unserem teuren
Funktionsaufruf.

225
00:03:56,710 --> 00:03:56,720

 

226
00:03:56,720 --> 00:03:58,550

Dann verwenden wir unsere Variable in allen unseren

227
00:03:58,550 --> 00:03:58,560
Dann verwenden wir unsere Variable in allen unseren
 

228
00:03:58,560 --> 00:04:07,509
Dann verwenden wir unsere Variable in allen unseren
Druckzeilenanweisungen.

229
00:04:07,509 --> 00:04:07,519

 

230
00:04:07,519 --> 00:04:09,509

Jetzt ist unser Duplizierungsproblem

231
00:04:09,509 --> 00:04:09,519
Jetzt ist unser Duplizierungsproblem
 

232
00:04:09,519 --> 00:04:11,670
Jetzt ist unser Duplizierungsproblem
behoben, aber jetzt haben wir ein anderes  Problem,

233
00:04:11,670 --> 00:04:11,680
behoben, aber jetzt haben wir ein anderes  Problem,
 

234
00:04:11,680 --> 00:04:13,910
behoben, aber jetzt haben wir ein anderes  Problem,
wir rufen unsere teure Funktion in

235
00:04:13,910 --> 00:04:13,920
wir rufen unsere teure Funktion in
 

236
00:04:13,920 --> 00:04:15,429
wir rufen unsere teure Funktion in
jedem einzelnen Fall

237
00:04:15,429 --> 00:04:15,439
jedem einzelnen Fall
 

238
00:04:15,439 --> 00:04:17,509
jedem einzelnen Fall
hier oben auf, egal was

239
00:04:17,509 --> 00:04:17,519
hier oben auf, egal was
 

240
00:04:17,519 --> 00:04:18,629
hier oben auf, egal was
unten ausgeführt wird,

241
00:04:18,629 --> 00:04:18,639
unten ausgeführt wird,
 

242
00:04:18,639 --> 00:04:20,310
unten ausgeführt wird,
wir werden unsere teure Funktion aufrufen,

243
00:04:20,310 --> 00:04:20,320
wir werden unsere teure Funktion aufrufen,
 

244
00:04:20,320 --> 00:04:22,870
wir werden unsere teure Funktion aufrufen,
aber hier können Sie sehen, dass dies

245
00:04:22,870 --> 00:04:22,880
aber hier können Sie sehen, dass dies
 

246
00:04:22,880 --> 00:04:24,390
aber hier können Sie sehen, dass dies
zufällig ist  Nummer 3 ist

247
00:04:24,390 --> 00:04:24,400
zufällig ist  Nummer 3 ist
 

248
00:04:24,400 --> 00:04:26,070
zufällig ist  Nummer 3 ist
, brauchen wir unsere teure Funktion nicht,

249
00:04:26,070 --> 00:04:26,080
, brauchen wir unsere teure Funktion nicht,
 

250
00:04:26,080 --> 00:04:27,430
, brauchen wir unsere teure Funktion nicht,
weil

251
00:04:27,430 --> 00:04:27,440
weil
 

252
00:04:27,440 --> 00:04:30,310
weil
wir diesen Text einfach ausdrucken. Wir wollen

253
00:04:30,310 --> 00:04:30,320
wir diesen Text einfach ausdrucken. Wir wollen
 

254
00:04:30,320 --> 00:04:32,310
wir diesen Text einfach ausdrucken. Wir wollen
unseren Code an einer Stelle definieren

255
00:04:32,310 --> 00:04:32,320
unseren Code an einer Stelle definieren
 

256
00:04:32,320 --> 00:04:35,270
unseren Code an einer Stelle definieren
, ihn aber nur bei Bedarf ausführen.

257
00:04:35,270 --> 00:04:35,280
, ihn aber nur bei Bedarf ausführen.
 

258
00:04:35,280 --> 00:04:37,189
, ihn aber nur bei Bedarf ausführen.
Versuchen wir also, dies

259
00:04:37,189 --> 00:04:37,199
Versuchen wir also, dies
 

260
00:04:37,199 --> 00:04:39,749
Versuchen wir also, dies
mit Closures umzugestalten. Scrollen wir zurück

261
00:04:39,749 --> 00:04:39,759
mit Closures umzugestalten. Scrollen wir zurück
 

262
00:04:39,759 --> 00:04:41,030
mit Closures umzugestalten. Scrollen wir zurück
nach oben  unseres Programms

263
00:04:41,030 --> 00:04:41,040
nach oben  unseres Programms
 

264
00:04:41,040 --> 00:04:43,270
nach oben  unseres Programms
und anstatt diese teure

265
00:04:43,270 --> 00:04:43,280
und anstatt diese teure
 

266
00:04:43,280 --> 00:04:44,550
und anstatt diese teure
Ergebnisvariable zu definieren

267
00:04:44,550 --> 00:04:44,560
Ergebnisvariable zu definieren
 

268
00:04:44,560 --> 00:04:48,150
Ergebnisvariable zu definieren
, definieren wir hier eine Closure

269
00:04:48,150 --> 00:04:48,160

 

270
00:04:48,160 --> 00:04:50,310

, wir haben eine Variable namens teure

271
00:04:50,310 --> 00:04:50,320
, wir haben eine Variable namens teure
 

272
00:04:50,320 --> 00:04:52,550
, wir haben eine Variable namens teure
Closure, die gleich

273
00:04:52,550 --> 00:04:52,560
Closure, die gleich
 

274
00:04:52,560 --> 00:04:55,030
Closure, die gleich
unserer Closure ist. Denken Sie daran, Closures sind

275
00:04:55,030 --> 00:04:55,040
unserer Closure ist. Denken Sie daran, Closures sind
 

276
00:04:55,040 --> 00:04:56,469
unserer Closure ist. Denken Sie daran, Closures sind
anonyme Funktionen

277
00:04:56,469 --> 00:04:56,479
anonyme Funktionen
 

278
00:04:56,479 --> 00:04:58,390
anonyme Funktionen
und der Unterschied zwischen einer Closure und

279
00:04:58,390 --> 00:04:58,400
und der Unterschied zwischen einer Closure und
 

280
00:04:58,400 --> 00:05:00,230
und der Unterschied zwischen einer Closure und
einer Funktion oder zumindest der  Der wichtigste visuelle

281
00:05:00,230 --> 00:05:00,240
einer Funktion oder zumindest der  Der wichtigste visuelle
 

282
00:05:00,240 --> 00:05:00,870
einer Funktion oder zumindest der  Der wichtigste visuelle
Unterschied

283
00:05:00,870 --> 00:05:00,880
Unterschied
 

284
00:05:00,880 --> 00:05:03,029
Unterschied
besteht darin, dass sich die Eingabeparameter nicht

285
00:05:03,029 --> 00:05:03,039
besteht darin, dass sich die Eingabeparameter nicht
 

286
00:05:03,039 --> 00:05:04,629
besteht darin, dass sich die Eingabeparameter nicht
in Klammern befinden,

287
00:05:04,629 --> 00:05:04,639
in Klammern befinden,
 

288
00:05:04,639 --> 00:05:06,790
in Klammern befinden,
sondern in diesen vertikalen Rohren.

289
00:05:06,790 --> 00:05:06,800
sondern in diesen vertikalen Rohren.
 

290
00:05:06,800 --> 00:05:07,749
sondern in diesen vertikalen Rohren.
Hier haben wir also einen

291
00:05:07,749 --> 00:05:07,759
Hier haben wir also einen
 

292
00:05:07,759 --> 00:05:10,230
Hier haben wir also einen
Eingabeparameter, der num ist, gefolgt von

293
00:05:10,230 --> 00:05:10,240
Eingabeparameter, der num ist, gefolgt von
 

294
00:05:10,240 --> 00:05:10,950
Eingabeparameter, der num ist, gefolgt von
Klammern,

295
00:05:10,950 --> 00:05:10,960
Klammern,
 

296
00:05:10,960 --> 00:05:13,590
Klammern,
die den Körper unseres Abschlusses enthalten, und

297
00:05:13,590 --> 00:05:13,600
die den Körper unseres Abschlusses enthalten, und
 

298
00:05:13,600 --> 00:05:14,790
die den Körper unseres Abschlusses enthalten, und
wenn unser Abschluss dann nur

299
00:05:14,790 --> 00:05:14,800
wenn unser Abschluss dann nur
 

300
00:05:14,800 --> 00:05:16,629
wenn unser Abschluss dann nur
eine Zeile war  Wir brauchen nicht einmal die

301
00:05:16,629 --> 00:05:16,639
eine Zeile war  Wir brauchen nicht einmal die
 

302
00:05:16,639 --> 00:05:19,189
eine Zeile war  Wir brauchen nicht einmal die
Klammern, also führen wir in unserem Verschlusskörper

303
00:05:19,189 --> 00:05:19,199
Klammern, also führen wir in unserem Verschlusskörper
 

304
00:05:19,199 --> 00:05:21,909
Klammern, also führen wir in unserem Verschlusskörper
unsere teure Berechnung durch und geben

305
00:05:21,909 --> 00:05:21,919
unsere teure Berechnung durch und geben
 

306
00:05:21,919 --> 00:05:22,629
unsere teure Berechnung durch und geben
dann

307
00:05:22,629 --> 00:05:22,639
dann
 

308
00:05:22,639 --> 00:05:25,990
dann
schließlich num zurück, am Ende brauchen wir

309
00:05:25,990 --> 00:05:26,000
schließlich num zurück, am Ende brauchen wir
 

310
00:05:26,000 --> 00:05:28,790
schließlich num zurück, am Ende brauchen wir
dieses Semico  lon hier, um die let-Anweisung zu beenden.

311
00:05:28,790 --> 00:05:29,830
dieses Semico  lon hier, um die let-Anweisung zu beenden.
 

312
00:05:29,830 --> 00:05:29,840

 

313
00:05:29,840 --> 00:05:31,830

Beachten Sie, dass unsere teure Closure-

314
00:05:31,830 --> 00:05:31,840
Beachten Sie, dass unsere teure Closure-
 

315
00:05:31,840 --> 00:05:34,070
Beachten Sie, dass unsere teure Closure-
Variable nicht den Rückgabewert unserer

316
00:05:34,070 --> 00:05:34,080
Variable nicht den Rückgabewert unserer
 

317
00:05:34,080 --> 00:05:34,870
Variable nicht den Rückgabewert unserer
Closure

318
00:05:34,870 --> 00:05:34,880
Closure
 

319
00:05:34,880 --> 00:05:37,189
Closure
speichert, sondern die Closure selbst.

320
00:05:37,189 --> 00:05:37,199
speichert, sondern die Closure selbst.
 

321
00:05:37,199 --> 00:05:39,590
speichert, sondern die Closure selbst.
Beachten Sie auch, dass der Rumpf unserer

322
00:05:39,590 --> 00:05:39,600
Beachten Sie auch, dass der Rumpf unserer
 

323
00:05:39,600 --> 00:05:41,990
Beachten Sie auch, dass der Rumpf unserer
Closure mit dem Rumpf unserer hier oben

324
00:05:41,990 --> 00:05:42,000
Closure mit dem Rumpf unserer hier oben
 

325
00:05:42,000 --> 00:05:43,670
Closure mit dem Rumpf unserer hier oben
definierten teuren Funktion identisch ist

326
00:05:43,670 --> 00:05:43,680
definierten teuren Funktion identisch ist
 

327
00:05:43,680 --> 00:05:46,230
definierten teuren Funktion identisch ist
Da unser Abschluss definiert ist

328
00:05:46,230 --> 00:05:46,240
Da unser Abschluss definiert ist
 

329
00:05:46,240 --> 00:05:47,670
Da unser Abschluss definiert ist
, können wir ihn in unseren Druckzeilenanweisungen aufrufen,

330
00:05:47,670 --> 00:05:54,550
, können wir ihn in unseren Druckzeilenanweisungen aufrufen,
 

331
00:05:54,550 --> 00:05:54,560

 

332
00:05:54,560 --> 00:05:56,230

da Sie sehen können, dass die Syntax zum Aufrufen

333
00:05:56,230 --> 00:05:56,240
da Sie sehen können, dass die Syntax zum Aufrufen
 

334
00:05:56,240 --> 00:05:58,629
da Sie sehen können, dass die Syntax zum Aufrufen
unseres Abschlusses der Syntax zum

335
00:05:58,629 --> 00:05:58,639
unseres Abschlusses der Syntax zum
 

336
00:05:58,639 --> 00:06:00,150
unseres Abschlusses der Syntax zum
Aufrufen einer Funktion ähnelt.

337
00:06:00,150 --> 00:06:00,160
Aufrufen einer Funktion ähnelt.
 

338
00:06:00,160 --> 00:06:02,469
Aufrufen einer Funktion ähnelt.
Wir geben unseren Variablennamen an, der

339
00:06:02,469 --> 00:06:02,479
Wir geben unseren Variablennamen an, der
 

340
00:06:02,479 --> 00:06:03,430
Wir geben unseren Variablennamen an, der
unseren Abschluss enthält,

341
00:06:03,430 --> 00:06:03,440
unseren Abschluss enthält,
 

342
00:06:03,440 --> 00:06:06,150
unseren Abschluss enthält,
gefolgt von Klammern, und übergeben dann

343
00:06:06,150 --> 00:06:06,160
gefolgt von Klammern, und übergeben dann
 

344
00:06:06,160 --> 00:06:07,590
gefolgt von Klammern, und übergeben dann
die  Eingabeparameter

345
00:06:07,590 --> 00:06:07,600
die  Eingabeparameter
 

346
00:06:07,600 --> 00:06:09,590
die  Eingabeparameter
Jetzt ist unsere Logik an einer Stelle definiert

347
00:06:09,590 --> 00:06:09,600
Jetzt ist unsere Logik an einer Stelle definiert
 

348
00:06:09,600 --> 00:06:11,189
Jetzt ist unsere Logik an einer Stelle definiert
und wir rufen unsere teure

349
00:06:11,189 --> 00:06:11,199
und wir rufen unsere teure
 

350
00:06:11,199 --> 00:06:12,150
und wir rufen unsere teure
Operation nur

351
00:06:12,150 --> 00:06:12,160
Operation nur
 

352
00:06:12,160 --> 00:06:14,550
Operation nur
bei Bedarf auf, aber wir sind mit einem alten

353
00:06:14,550 --> 00:06:14,560
bei Bedarf auf, aber wir sind mit einem alten
 

354
00:06:14,560 --> 00:06:15,749
bei Bedarf auf, aber wir sind mit einem alten
Problem zurück, nämlich dass

355
00:06:15,749 --> 00:06:15,759
Problem zurück, nämlich dass
 

356
00:06:15,759 --> 00:06:17,670
Problem zurück, nämlich dass
wir in diesem if-Block unsere

357
00:06:17,670 --> 00:06:17,680
wir in diesem if-Block unsere
 

358
00:06:17,680 --> 00:06:19,110
wir in diesem if-Block unsere
teure Operation

359
00:06:19,110 --> 00:06:19,120
teure Operation
 

360
00:06:19,120 --> 00:06:21,830
teure Operation
zweimal aufrufen, was nicht gut ist  Jetzt könnten wir

361
00:06:21,830 --> 00:06:21,840
zweimal aufrufen, was nicht gut ist  Jetzt könnten wir
 

362
00:06:21,840 --> 00:06:23,590
zweimal aufrufen, was nicht gut ist  Jetzt könnten wir
dieses Problem beheben, indem wir das Ergebnis

363
00:06:23,590 --> 00:06:23,600
dieses Problem beheben, indem wir das Ergebnis
 

364
00:06:23,600 --> 00:06:25,189
dieses Problem beheben, indem wir das Ergebnis
unseres teuren Abschlussaufrufs

365
00:06:25,189 --> 00:06:25,199
unseres teuren Abschlussaufrufs
 

366
00:06:25,199 --> 00:06:27,350
unseres teuren Abschlussaufrufs
oben in dieser if-Anweisung speichern, aber es

367
00:06:27,350 --> 00:06:27,360
oben in dieser if-Anweisung speichern, aber es
 

368
00:06:27,360 --> 00:06:28,710
oben in dieser if-Anweisung speichern, aber es
gibt eine andere Möglichkeit, wie wir dieses Problem lösen können

369
00:06:28,710 --> 00:06:28,720
gibt eine andere Möglichkeit, wie wir dieses Problem lösen können
 

370
00:06:28,720 --> 00:06:29,270
gibt eine andere Möglichkeit, wie wir dieses Problem lösen können
, nämlich

371
00:06:29,270 --> 00:06:29,280
, nämlich
 

372
00:06:29,280 --> 00:06:31,670
, nämlich
die von uns

373
00:06:31,670 --> 00:06:31,680
die von uns
 

374
00:06:31,680 --> 00:06:33,430
die von uns
Bevor wir dieses Problem lösen, haben

375
00:06:33,430 --> 00:06:33,440
Bevor wir dieses Problem lösen, haben
 

376
00:06:33,440 --> 00:06:34,870
Bevor wir dieses Problem lösen, haben
Sie vielleicht bemerkt, dass wir

377
00:06:34,870 --> 00:06:34,880
Sie vielleicht bemerkt, dass wir
 

378
00:06:34,880 --> 00:06:36,629
Sie vielleicht bemerkt, dass wir
weder den Typ des

379
00:06:36,629 --> 00:06:36,639
weder den Typ des
 

380
00:06:36,639 --> 00:06:37,270
weder den Typ des

381
00:06:37,270 --> 00:06:37,280

 

382
00:06:37,280 --> 00:06:39,350

Eingabeparameters

383
00:06:39,350 --> 00:06:39,360
Eingabeparameters
 

384
00:06:39,360 --> 00:06:40,710
Eingabeparameters
unserer Closure noch den Rückgabewert unserer Closure

385
00:06:40,710 --> 00:06:40,720
unserer Closure noch den Rückgabewert unserer Closure
 

386
00:06:40,720 --> 00:06:42,950
unserer Closure noch den Rückgabewert unserer Closure
für reguläre Funktionen kommentieren mussten, über die wir

387
00:06:42,950 --> 00:06:42,960
für reguläre Funktionen kommentieren mussten, über die wir
 

388
00:06:42,960 --> 00:06:44,790
für reguläre Funktionen kommentieren mussten, über die wir
den Typ spezifizieren müssten  unserer

389
00:06:44,790 --> 00:06:44,800
den Typ spezifizieren müssten  unserer
 

390
00:06:44,800 --> 00:06:45,909
den Typ spezifizieren müssten  unserer
Eingabeparameter

391
00:06:45,909 --> 00:06:45,919
Eingabeparameter
 

392
00:06:45,919 --> 00:06:48,070
Eingabeparameter
und des Typs unserer Rückgabewerte, und

393
00:06:48,070 --> 00:06:48,080
und des Typs unserer Rückgabewerte, und
 

394
00:06:48,080 --> 00:06:49,990
und des Typs unserer Rückgabewerte, und
das liegt daran, dass Funktionen Teil einer

395
00:06:49,990 --> 00:06:50,000
das liegt daran, dass Funktionen Teil einer
 

396
00:06:50,000 --> 00:06:51,350
das liegt daran, dass Funktionen Teil einer
expliziten Schnittstelle sind,

397
00:06:51,350 --> 00:06:51,360
expliziten Schnittstelle sind,
 

398
00:06:51,360 --> 00:06:53,749
expliziten Schnittstelle sind,
die den Benutzern ausgesetzt ist. Daher ist es wichtig, sich auf die

399
00:06:53,749 --> 00:06:53,759
die den Benutzern ausgesetzt ist. Daher ist es wichtig, sich auf die
 

400
00:06:53,759 --> 00:06:55,110
die den Benutzern ausgesetzt ist. Daher ist es wichtig, sich auf die
übergebenen

401
00:06:55,110 --> 00:06:55,120
übergebenen
 

402
00:06:55,120 --> 00:06:57,830
übergebenen
und zurückgegebenen Typen zu einigen. Closures

403
00:06:57,830 --> 00:06:57,840
und zurückgegebenen Typen zu einigen. Closures
 

404
00:06:57,840 --> 00:06:59,510
und zurückgegebenen Typen zu einigen. Closures
hingegen sind normalerweise kurz und

405
00:06:59,510 --> 00:06:59,520
hingegen sind normalerweise kurz und
 

406
00:06:59,520 --> 00:07:02,150
hingegen sind normalerweise kurz und
nur innerhalb eines engen Bereichs relevant  Kontext, so dass

407
00:07:02,150 --> 00:07:02,160
nur innerhalb eines engen Bereichs relevant  Kontext, so dass
 

408
00:07:02,160 --> 00:07:02,550
nur innerhalb eines engen Bereichs relevant  Kontext, so dass
der

409
00:07:02,550 --> 00:07:02,560
der
 

410
00:07:02,560 --> 00:07:04,870
der
Compiler in der Lage ist, die Eingabeparametertypen

411
00:07:04,870 --> 00:07:05,990
Compiler in der Lage ist, die Eingabeparametertypen
 

412
00:07:05,990 --> 00:07:06,000

 

413
00:07:06,000 --> 00:07:08,230

und die Rückgabetypen zu bestimmen. Dies ist ähnlich,

414
00:07:08,230 --> 00:07:08,240
und die Rückgabetypen zu bestimmen. Dies ist ähnlich,
 

415
00:07:08,240 --> 00:07:10,150
und die Rückgabetypen zu bestimmen. Dies ist ähnlich,
wie der Compiler in der Lage ist,

416
00:07:10,150 --> 00:07:10,160
wie der Compiler in der Lage ist,
 

417
00:07:10,160 --> 00:07:12,070
wie der Compiler in der Lage ist,
die Typen der meisten Variablen zu bestimmen.

418
00:07:12,070 --> 00:07:12,080
die Typen der meisten Variablen zu bestimmen.
 

419
00:07:12,080 --> 00:07:13,749
die Typen der meisten Variablen zu bestimmen.
Beachten Sie, dass wir die Typen explizit machen könnten,

420
00:07:13,749 --> 00:07:13,759
Beachten Sie, dass wir die Typen explizit machen könnten,
 

421
00:07:13,759 --> 00:07:17,430
Beachten Sie, dass wir die Typen explizit machen könnten,
wenn wir möchten,

422
00:07:17,430 --> 00:07:17,440
wenn wir möchten,
 

423
00:07:17,440 --> 00:07:19,270
wenn wir möchten,
damit die Typen explizit werden  Beachten Sie auf

424
00:07:19,270 --> 00:07:19,280
damit die Typen explizit werden  Beachten Sie auf
 

425
00:07:19,280 --> 00:07:21,350
damit die Typen explizit werden  Beachten Sie auf
Kosten der Ausführlichkeit

426
00:07:21,350 --> 00:07:21,360
Kosten der Ausführlichkeit
 

427
00:07:21,360 --> 00:07:23,189
Kosten der Ausführlichkeit
, dass Abschlussdefinitionen

428
00:07:23,189 --> 00:07:23,199
, dass Abschlussdefinitionen
 

429
00:07:23,199 --> 00:07:25,350
, dass Abschlussdefinitionen
nur einen konkreten Typ haben können, der

430
00:07:25,350 --> 00:07:25,360
nur einen konkreten Typ haben können, der
 

431
00:07:25,360 --> 00:07:27,749
nur einen konkreten Typ haben können, der
für jeden Eingabeparameter abgeleitet werden kann, zum Beispiel

432
00:07:27,749 --> 00:07:27,759
für jeden Eingabeparameter abgeleitet werden kann, zum Beispiel
 

433
00:07:27,759 --> 00:07:29,110
für jeden Eingabeparameter abgeleitet werden kann, zum Beispiel
hier wir  Haben Sie eine Variable namens

434
00:07:29,110 --> 00:07:29,120
hier wir  Haben Sie eine Variable namens
 

435
00:07:29,120 --> 00:07:31,189
hier wir  Haben Sie eine Variable namens
Beispielabschluss, die gleich einem

436
00:07:31,189 --> 00:07:31,199
Beispielabschluss, die gleich einem
 

437
00:07:31,199 --> 00:07:33,270
Beispielabschluss, die gleich einem
Abschluss ist, der x aufnimmt

438
00:07:33,270 --> 00:07:33,280
Abschluss ist, der x aufnimmt
 

439
00:07:33,280 --> 00:07:36,150
Abschluss ist, der x aufnimmt
und dann x zurückgibt, da der

440
00:07:36,150 --> 00:07:36,160
und dann x zurückgibt, da der
 

441
00:07:36,160 --> 00:07:37,589
und dann x zurückgibt, da der
Abschluss

442
00:07:37,589 --> 00:07:37,599
Abschluss
 

443
00:07:37,599 --> 00:07:40,309
Abschluss
hier in Zeile 26 mit einer Zeichenfolge verwendet wird, schließt der

444
00:07:40,309 --> 00:07:40,319
hier in Zeile 26 mit einer Zeichenfolge verwendet wird, schließt der
 

445
00:07:40,319 --> 00:07:41,670
hier in Zeile 26 mit einer Zeichenfolge verwendet wird, schließt der
Compiler,

446
00:07:41,670 --> 00:07:41,680
Compiler,
 

447
00:07:41,680 --> 00:07:43,830
Compiler,
dass der Eingabeparametertyp eine

448
00:07:43,830 --> 00:07:43,840
dass der Eingabeparametertyp eine
 

449
00:07:43,840 --> 00:07:46,230
dass der Eingabeparametertyp eine
Zeichenfolge ist, aber dann direkt darunter in der Zeile

450
00:07:46,230 --> 00:07:46,240
Zeichenfolge ist, aber dann direkt darunter in der Zeile
 

451
00:07:46,240 --> 00:07:47,270
Zeichenfolge ist, aber dann direkt darunter in der Zeile
27

452
00:07:47,270 --> 00:07:47,280
27
 

453
00:07:47,280 --> 00:07:50,309
27
rufen wir unsere Beispiel-Closure-Variable

454
00:07:50,309 --> 00:07:50,319
rufen wir unsere Beispiel-Closure-Variable
 

455
00:07:50,319 --> 00:07:53,110
rufen wir unsere Beispiel-Closure-Variable
mit einer Ganzzahl auf, jetzt beschwert sich der Compiler

456
00:07:53,110 --> 00:07:53,120
mit einer Ganzzahl auf, jetzt beschwert sich der Compiler
 

457
00:07:53,120 --> 00:07:53,830
mit einer Ganzzahl auf, jetzt beschwert sich der Compiler

458
00:07:53,830 --> 00:07:53,840

 

459
00:07:53,840 --> 00:07:55,350

und der Pfeil sagt, dass wir nicht

460
00:07:55,350 --> 00:07:55,360
und der Pfeil sagt, dass wir nicht
 

461
00:07:55,360 --> 00:07:57,510
und der Pfeil sagt, dass wir nicht
übereinstimmende Typen haben. Wir erwarten einen

462
00:07:57,510 --> 00:07:57,520
übereinstimmende Typen haben. Wir erwarten einen
 

463
00:07:57,520 --> 00:07:58,550
übereinstimmende Typen haben. Wir erwarten einen
String, aber wir erhalten

464
00:07:58,550 --> 00:07:58,560
String, aber wir erhalten
 

465
00:07:58,560 --> 00:08:00,950
String, aber wir erhalten
eine Ganzzahl, also funktioniert der Compiler

466
00:08:00,950 --> 00:08:00,960
eine Ganzzahl, also funktioniert der Compiler
 

467
00:08:00,960 --> 00:08:02,869
eine Ganzzahl, also funktioniert der Compiler
so, dass der erste Typ an uns übergeben wird

468
00:08:02,869 --> 00:08:02,879
so, dass der erste Typ an uns übergeben wird
 

469
00:08:02,879 --> 00:08:03,670
so, dass der erste Typ an uns übergeben wird
Der Abschluss

470
00:08:03,670 --> 00:08:03,680
Der Abschluss
 

471
00:08:03,680 --> 00:08:06,309
Der Abschluss
wird der konkrete Typ unserer Eingabeparameter.

472
00:08:06,309 --> 00:08:06,319
wird der konkrete Typ unserer Eingabeparameter.
 

473
00:08:06,319 --> 00:08:07,189
wird der konkrete Typ unserer Eingabeparameter.
Kommen

474
00:08:07,189 --> 00:08:07,199
Kommen
 

475
00:08:07,199 --> 00:08:08,790
Kommen
wir nun auf das Problem zurück

476
00:08:08,790 --> 00:08:08,800
wir nun auf das Problem zurück
 

477
00:08:08,800 --> 00:08:11,029
wir nun auf das Problem zurück
, unseren teuren Abschluss zweimal

478
00:08:11,029 --> 00:08:11,039
, unseren teuren Abschluss zweimal
 

479
00:08:11,039 --> 00:08:13,830
, unseren teuren Abschluss zweimal
in diesem if-Block aufzurufen. Wir könnten

480
00:08:13,830 --> 00:08:13,840
in diesem if-Block aufzurufen. Wir könnten
 

481
00:08:13,840 --> 00:08:15,830
in diesem if-Block aufzurufen. Wir könnten
diese Funktion wieder lösen, indem wir eine Variable

482
00:08:15,830 --> 00:08:15,840
diese Funktion wieder lösen, indem wir eine Variable
 

483
00:08:15,840 --> 00:08:16,710
diese Funktion wieder lösen, indem wir eine Variable
am Anfang unseres

484
00:08:16,710 --> 00:08:16,720
am Anfang unseres
 

485
00:08:16,720 --> 00:08:18,950
am Anfang unseres
if-Blocks erstellen und nur das Ergebnis von speichern

486
00:08:18,950 --> 00:08:18,960
if-Blocks erstellen und nur das Ergebnis von speichern
 

487
00:08:18,960 --> 00:08:20,309
if-Blocks erstellen und nur das Ergebnis von speichern
unseren teuren Abschluss

488
00:08:20,309 --> 00:08:20,319
unseren teuren Abschluss
 

489
00:08:20,319 --> 00:08:22,309
unseren teuren Abschluss
und dann dieses Ergebnis in

490
00:08:22,309 --> 00:08:22,319
und dann dieses Ergebnis in
 

491
00:08:22,319 --> 00:08:23,990
und dann dieses Ergebnis in
diesen beiden Druckzeilenanweisungen zu verwenden,

492
00:08:23,990 --> 00:08:24,000
diesen beiden Druckzeilenanweisungen zu verwenden,
 

493
00:08:24,000 --> 00:08:25,830
diesen beiden Druckzeilenanweisungen zu verwenden,
aber wir werden etwas anderes tun,

494
00:08:25,830 --> 00:08:25,840
aber wir werden etwas anderes tun,
 

495
00:08:25,840 --> 00:08:28,070
aber wir werden etwas anderes tun,
was wir tun werden, ist das Memoisierungsmuster zu verwenden

496
00:08:28,070 --> 00:08:28,080
was wir tun werden, ist das Memoisierungsmuster zu verwenden
 

497
00:08:28,080 --> 00:08:28,869
was wir tun werden, ist das Memoisierungsmuster zu verwenden
,

498
00:08:28,869 --> 00:08:28,879
,
 

499
00:08:28,879 --> 00:08:31,670
,
indem wir einen str erstellen  uct, das unsere

500
00:08:31,670 --> 00:08:31,680
indem wir einen str erstellen  uct, das unsere
 

501
00:08:31,680 --> 00:08:32,630
indem wir einen str erstellen  uct, das unsere
Schließung

502
00:08:32,630 --> 00:08:32,640
Schließung
 

503
00:08:32,640 --> 00:08:35,430
Schließung
und das Ergebnis unserer Schließung hier enthält. Ich habe

504
00:08:35,430 --> 00:08:35,440
und das Ergebnis unserer Schließung hier enthält. Ich habe
 

505
00:08:35,440 --> 00:08:37,110
und das Ergebnis unserer Schließung hier enthält. Ich habe
eine Struktur namens

506
00:08:37,110 --> 00:08:37,120
eine Struktur namens
 

507
00:08:37,120 --> 00:08:40,070
eine Struktur namens
Cacher direkt über unserer Funktion „Generate Workout“ erstellt

508
00:08:40,070 --> 00:08:40,080
Cacher direkt über unserer Funktion „Generate Workout“ erstellt
 

509
00:08:40,080 --> 00:08:40,870
Cacher direkt über unserer Funktion „Generate Workout“ erstellt

510
00:08:40,870 --> 00:08:40,880

 

511
00:08:40,880 --> 00:08:43,670

, um jetzt Strukturaufzählungen oder

512
00:08:43,670 --> 00:08:43,680
, um jetzt Strukturaufzählungen oder
 

513
00:08:43,680 --> 00:08:45,269
, um jetzt Strukturaufzählungen oder
sogar Funktionsparameter zu definieren

514
00:08:45,269 --> 00:08:45,279
sogar Funktionsparameter zu definieren
 

515
00:08:45,279 --> 00:08:47,910
sogar Funktionsparameter zu definieren
, die Schließungen verwenden. Wir müssen

516
00:08:47,910 --> 00:08:47,920
, die Schließungen verwenden. Wir müssen
 

517
00:08:47,920 --> 00:08:48,870
, die Schließungen verwenden. Wir müssen

518
00:08:48,870 --> 00:08:48,880

 

519
00:08:48,880 --> 00:08:51,590

hier in unserem Cache Generika und Trait-Grenzen verwenden

520
00:08:51,590 --> 00:08:51,600
hier in unserem Cache Generika und Trait-Grenzen verwenden
 

521
00:08:51,600 --> 00:08:52,230
hier in unserem Cache Generika und Trait-Grenzen verwenden
Instruct verwendet

522
00:08:52,230 --> 00:08:52,240
Instruct verwendet
 

523
00:08:52,240 --> 00:08:55,430
Instruct verwendet
ein Generikum namens t und unten definieren wir ein

524
00:08:55,430 --> 00:08:55,440
ein Generikum namens t und unten definieren wir ein
 

525
00:08:55,440 --> 00:08:56,949
ein Generikum namens t und unten definieren wir ein
Merkmal, das für Generikum gebunden ist,

526
00:08:56,949 --> 00:08:56,959
Merkmal, das für Generikum gebunden ist,
 

527
00:08:56,959 --> 00:08:59,590
Merkmal, das für Generikum gebunden ist,
und das Merkmal, das wir verwenden, ist jetzt fn, kurz

528
00:08:59,590 --> 00:08:59,600
und das Merkmal, das wir verwenden, ist jetzt fn, kurz
 

529
00:08:59,600 --> 00:09:00,150
und das Merkmal, das wir verwenden, ist jetzt fn, kurz
für

530
00:09:00,150 --> 00:09:00,160
für
 

531
00:09:00,160 --> 00:09:02,070
für
Funktion, ohne auf das

532
00:09:02,070 --> 00:09:02,080
Funktion, ohne auf das
 

533
00:09:02,080 --> 00:09:04,310
Funktion, ohne auf das
Merkmal fn einzugehen, wissen Sie nur, dass es

534
00:09:04,310 --> 00:09:04,320
Merkmal fn einzugehen, wissen Sie nur, dass es
 

535
00:09:04,320 --> 00:09:05,750
Merkmal fn einzugehen, wissen Sie nur, dass es
von der Standardbibliothek bereitgestellt wird

536
00:09:05,750 --> 00:09:05,760
von der Standardbibliothek bereitgestellt wird
 

537
00:09:05,760 --> 00:09:07,829
von der Standardbibliothek bereitgestellt wird
und alle Closures implementieren  Eines der

538
00:09:07,829 --> 00:09:07,839
und alle Closures implementieren  Eines der
 

539
00:09:07,839 --> 00:09:09,670
und alle Closures implementieren  Eines der
drei Fn-

540
00:09:09,670 --> 00:09:09,680
drei Fn-
 

541
00:09:09,680 --> 00:09:12,389
drei Fn-
Merkmale ist fn, das andere ist fn

542
00:09:12,389 --> 00:09:12,399
Merkmale ist fn, das andere ist fn
 

543
00:09:12,399 --> 00:09:13,350
Merkmale ist fn, das andere ist fn
mute

544
00:09:13,350 --> 00:09:13,360
mute
 

545
00:09:13,360 --> 00:09:17,269
mute
und das letzte ist fn. Sobald

546
00:09:17,269 --> 00:09:17,279
und das letzte ist fn. Sobald
 

547
00:09:17,279 --> 00:09:19,110
und das letzte ist fn. Sobald
wir uns gleich mit den Unterschieden zwischen

548
00:09:19,110 --> 00:09:19,120
wir uns gleich mit den Unterschieden zwischen
 

549
00:09:19,120 --> 00:09:21,190
wir uns gleich mit den Unterschieden zwischen
diesen drei Merkmalen befassen,

550
00:09:21,190 --> 00:09:21,200
diesen drei Merkmalen befassen,
 

551
00:09:21,200 --> 00:09:23,190
diesen drei Merkmalen befassen,
haben wir der fn-Leiste Typen hinzugefügt, um die

552
00:09:23,190 --> 00:09:23,200
haben wir der fn-Leiste Typen hinzugefügt, um die
 

553
00:09:23,200 --> 00:09:25,030
haben wir der fn-Leiste Typen hinzugefügt, um die
darzustellen

554
00:09:25,030 --> 00:09:25,040
darzustellen
 

555
00:09:25,040 --> 00:09:27,509
darzustellen
Eingabeparameter unserer Schließung, die eine

556
00:09:27,509 --> 00:09:27,519
Eingabeparameter unserer Schließung, die eine
 

557
00:09:27,519 --> 00:09:29,430
Eingabeparameter unserer Schließung, die eine
vorzeichenlose 32-Bit-Ganzzahl sein wird,

558
00:09:29,430 --> 00:09:29,440
vorzeichenlose 32-Bit-Ganzzahl sein wird,
 

559
00:09:29,440 --> 00:09:31,670
vorzeichenlose 32-Bit-Ganzzahl sein wird,
und auch die Ausgabeparameter, die

560
00:09:31,670 --> 00:09:31,680
und auch die Ausgabeparameter, die
 

561
00:09:31,680 --> 00:09:32,630
und auch die Ausgabeparameter, die
wieder

562
00:09:32,630 --> 00:09:32,640
wieder
 

563
00:09:32,640 --> 00:09:35,269
wieder
eine vorzeichenlose 32-Bit-Ganzzahl sein wird, dann

564
00:09:35,269 --> 00:09:35,279
eine vorzeichenlose 32-Bit-Ganzzahl sein wird, dann
 

565
00:09:35,279 --> 00:09:37,190
eine vorzeichenlose 32-Bit-Ganzzahl sein wird, dann
haben wir im Körper unserer Struktur

566
00:09:37,190 --> 00:09:37,200
haben wir im Körper unserer Struktur
 

567
00:09:37,200 --> 00:09:39,509
haben wir im Körper unserer Struktur
t  wo Felder das erste ist Berechnung,

568
00:09:39,509 --> 00:09:39,519
t  wo Felder das erste ist Berechnung,
 

569
00:09:39,519 --> 00:09:41,350
t  wo Felder das erste ist Berechnung,
die unseren generischen Typ speichert,

570
00:09:41,350 --> 00:09:41,360
die unseren generischen Typ speichert,
 

571
00:09:41,360 --> 00:09:44,070
die unseren generischen Typ speichert,
also könnte Berechnung jede Schließung sein,

572
00:09:44,070 --> 00:09:44,080
also könnte Berechnung jede Schließung sein,
 

573
00:09:44,080 --> 00:09:44,949
also könnte Berechnung jede Schließung sein,
die diesem

574
00:09:44,949 --> 00:09:44,959
die diesem
 

575
00:09:44,959 --> 00:09:48,310
die diesem
Fach entspricht, das hier gebunden ist, dann haben wir einen

576
00:09:48,310 --> 00:09:48,320
Fach entspricht, das hier gebunden ist, dann haben wir einen
 

577
00:09:48,320 --> 00:09:50,710
Fach entspricht, das hier gebunden ist, dann haben wir einen
Wert, der ein optionaler

578
00:09:50,710 --> 00:09:50,720
Wert, der ein optionaler
 

579
00:09:50,720 --> 00:09:51,670
Wert, der ein optionaler
32-Bit-

580
00:09:51,670 --> 00:09:51,680
32-Bit-
 

581
00:09:51,680 --> 00:09:54,230
32-Bit-
Ganzzahlwert sein wird, ist optional, da

582
00:09:54,230 --> 00:09:54,240
Ganzzahlwert sein wird, ist optional, da
 

583
00:09:54,240 --> 00:09:55,110
Ganzzahlwert sein wird, ist optional, da
unser Cacher

584
00:09:55,110 --> 00:09:55,120
unser Cacher
 

585
00:09:55,120 --> 00:09:57,190
unser Cacher
initialisiert wird  Es wird keine sein

586
00:09:57,190 --> 00:09:57,200
initialisiert wird  Es wird keine sein
 

587
00:09:57,200 --> 00:09:59,110
initialisiert wird  Es wird keine sein
und sobald wir unsere Berechnung aufgerufen haben,

588
00:09:59,110 --> 00:09:59,120
und sobald wir unsere Berechnung aufgerufen haben,
 

589
00:09:59,120 --> 00:10:01,590
und sobald wir unsere Berechnung aufgerufen haben,
speichern wir den Rückgabewert in

590
00:10:01,590 --> 00:10:01,600
speichern wir den Rückgabewert in
 

591
00:10:01,600 --> 00:10:02,870
speichern wir den Rückgabewert in
unserem Wertfeld.

592
00:10:02,870 --> 00:10:02,880
unserem Wertfeld.
 

593
00:10:02,880 --> 00:10:05,190
unserem Wertfeld.
Beachten Sie, dass reguläre Funktionen

594
00:10:05,190 --> 00:10:05,200
Beachten Sie, dass reguläre Funktionen
 

595
00:10:05,200 --> 00:10:06,710
Beachten Sie, dass reguläre Funktionen
auch diese drei

596
00:10:06,710 --> 00:10:06,720
auch diese drei
 

597
00:10:06,720 --> 00:10:09,829
auch diese drei
fn-Merkmale implementieren, sodass wir als nächstes auch eine reguläre

598
00:10:09,829 --> 00:10:09,839
fn-Merkmale implementieren, sodass wir als nächstes auch eine reguläre
 

599
00:10:09,839 --> 00:10:10,310
fn-Merkmale implementieren, sodass wir als nächstes auch eine reguläre
Funktion

600
00:10:10,310 --> 00:10:10,320
Funktion
 

601
00:10:10,320 --> 00:10:13,190
Funktion
in unserem Berechnungsfeld speichern können

602
00:10:13,190 --> 00:10:13,200
in unserem Berechnungsfeld speichern können
 

603
00:10:13,200 --> 00:10:15,190
in unserem Berechnungsfeld speichern können
i '  Ich füge den

604
00:10:15,190 --> 00:10:15,200
i '  Ich füge den
 

605
00:10:15,200 --> 00:10:16,949
i '  Ich füge den
Implementierungsblock für einen Cache oder eine Struktur ein

606
00:10:16,949 --> 00:10:16,959
Implementierungsblock für einen Cache oder eine Struktur ein
 

607
00:10:16,959 --> 00:10:21,110
Implementierungsblock für einen Cache oder eine Struktur ein
und wir reden darüber.

608
00:10:21,110 --> 00:10:21,120

 

609
00:10:21,120 --> 00:10:23,269

Okay, gehen wir das durch. Wir haben unseren

610
00:10:23,269 --> 00:10:23,279
Okay, gehen wir das durch. Wir haben unseren
 

611
00:10:23,279 --> 00:10:24,389
Okay, gehen wir das durch. Wir haben unseren
Implementierungsblock

612
00:10:24,389 --> 00:10:24,399
Implementierungsblock
 

613
00:10:24,399 --> 00:10:27,110
Implementierungsblock
für den Cacher, der die gleiche generische

614
00:10:27,110 --> 00:10:27,120
für den Cacher, der die gleiche generische
 

615
00:10:27,120 --> 00:10:28,230
für den Cacher, der die gleiche generische
und Merkmalsbindung hat

616
00:10:28,230 --> 00:10:28,240
und Merkmalsbindung hat
 

617
00:10:28,240 --> 00:10:30,630
und Merkmalsbindung hat
wie unser Cache oder unsere Struktur, und dann ist die

618
00:10:30,630 --> 00:10:30,640
wie unser Cache oder unsere Struktur, und dann ist die
 

619
00:10:30,640 --> 00:10:31,590
wie unser Cache oder unsere Struktur, und dann ist die
erste Funktion

620
00:10:31,590 --> 00:10:31,600
erste Funktion
 

621
00:10:31,600 --> 00:10:34,150
erste Funktion
darin  namens new new ist eine

622
00:10:34,150 --> 00:10:34,160
darin  namens new new ist eine
 

623
00:10:34,160 --> 00:10:35,750
darin  namens new new ist eine
Konstruktorfunktion, die eine

624
00:10:35,750 --> 00:10:35,760
Konstruktorfunktion, die eine
 

625
00:10:35,760 --> 00:10:37,829
Konstruktorfunktion, die eine
Berechnung vom Typ t

626
00:10:37,829 --> 00:10:37,839
Berechnung vom Typ t
 

627
00:10:37,839 --> 00:10:39,910
Berechnung vom Typ t
unserer Schließung aufnimmt und dann einen neuen

628
00:10:39,910 --> 00:10:39,920
unserer Schließung aufnimmt und dann einen neuen
 

629
00:10:39,920 --> 00:10:41,190
unserer Schließung aufnimmt und dann einen neuen
Cacher erstellt, der

630
00:10:41,190 --> 00:10:41,200
Cacher erstellt, der
 

631
00:10:41,200 --> 00:10:44,069
Cacher erstellt, der
die Berechnung übergibt und den Wert auf

632
00:10:44,069 --> 00:10:44,079
die Berechnung übergibt und den Wert auf
 

633
00:10:44,079 --> 00:10:44,790
die Berechnung übergibt und den Wert auf
none setzt

634
00:10:44,790 --> 00:10:44,800
none setzt
 

635
00:10:44,800 --> 00:10:47,910
none setzt
dann haben wir unsere Wertmethode und es ist eine

636
00:10:47,910 --> 00:10:47,920
dann haben wir unsere Wertmethode und es ist eine
 

637
00:10:47,920 --> 00:10:49,670
dann haben wir unsere Wertmethode und es ist eine
Methode, weil der erste

638
00:10:49,670 --> 00:10:49,680
Methode, weil der erste
 

639
00:10:49,680 --> 00:10:52,389
Methode, weil der erste
Parameter eine Referenz auf self ist und tatsächlich haben

640
00:10:52,389 --> 00:10:52,399
Parameter eine Referenz auf self ist und tatsächlich haben
 

641
00:10:52,399 --> 00:10:54,470
Parameter eine Referenz auf self ist und tatsächlich haben
wir eine veränderliche Referenz auf self.

642
00:10:54,470 --> 00:10:54,480
wir eine veränderliche Referenz auf self.
 

643
00:10:54,480 --> 00:10:57,590
wir eine veränderliche Referenz auf self.
Der nächste Parameter ist arg, das ist das

644
00:10:57,590 --> 00:10:57,600
Der nächste Parameter ist arg, das ist das
 

645
00:10:57,600 --> 00:11:00,150
Der nächste Parameter ist arg, das ist das
Argument, das wir in unsere Closure übergeben, und

646
00:11:00,150 --> 00:11:00,160
Argument, das wir in unsere Closure übergeben, und
 

647
00:11:00,160 --> 00:11:02,550
Argument, das wir in unsere Closure übergeben, und
es ist eine 32 ohne Vorzeichen  -bit integer Der

648
00:11:02,550 --> 00:11:02,560
es ist eine 32 ohne Vorzeichen  -bit integer Der
 

649
00:11:02,560 --> 00:11:05,110
es ist eine 32 ohne Vorzeichen  -bit integer Der
Rückgabetyp ist auch ein vorzeichenloser 32-Bit-

650
00:11:05,110 --> 00:11:05,120
Rückgabetyp ist auch ein vorzeichenloser 32-Bit-
 

651
00:11:05,120 --> 00:11:05,829
Rückgabetyp ist auch ein vorzeichenloser 32-Bit-
Integer

652
00:11:05,829 --> 00:11:05,839
Integer
 

653
00:11:05,839 --> 00:11:08,069
Integer
innerhalb der Wertmethode. Wir werden

654
00:11:08,069 --> 00:11:08,079
innerhalb der Wertmethode. Wir werden
 

655
00:11:08,079 --> 00:11:09,590
innerhalb der Wertmethode. Wir werden
einen Übereinstimmungsausdruck

656
00:11:09,590 --> 00:11:09,600
einen Übereinstimmungsausdruck
 

657
00:11:09,600 --> 00:11:12,710
einen Übereinstimmungsausdruck
für den Selbstpunktwert ausführen, also überprüfen wir den

658
00:11:12,710 --> 00:11:12,720
für den Selbstpunktwert ausführen, also überprüfen wir den
 

659
00:11:12,720 --> 00:11:13,829
für den Selbstpunktwert ausführen, also überprüfen wir den
Selbstpunkttyp

660
00:11:13,829 --> 00:11:13,839
Selbstpunkttyp
 

661
00:11:13,839 --> 00:11:16,550
Selbstpunkttyp
und erinnern uns daran, dass self.value ein

662
00:11:16,550 --> 00:11:16,560
und erinnern uns daran, dass self.value ein
 

663
00:11:16,560 --> 00:11:17,509
und erinnern uns daran, dass self.value ein
optionaler Typ

664
00:11:17,509 --> 00:11:17,519
optionaler Typ
 

665
00:11:17,519 --> 00:11:19,829
optionaler Typ
und ist  Wenn wir unseren Cacher zum ersten Mal erstellen,

666
00:11:19,829 --> 00:11:19,839
und ist  Wenn wir unseren Cacher zum ersten Mal erstellen,
 

667
00:11:19,839 --> 00:11:21,269
und ist  Wenn wir unseren Cacher zum ersten Mal erstellen,
wird er auf none gesetzt,

668
00:11:21,269 --> 00:11:21,279
wird er auf none gesetzt,
 

669
00:11:21,279 --> 00:11:24,310
wird er auf none gesetzt,
also führen wir diesen none-Zweig

670
00:11:24,310 --> 00:11:24,320
also führen wir diesen none-Zweig
 

671
00:11:24,320 --> 00:11:26,389
also führen wir diesen none-Zweig
innerhalb des none-Arms aus. Wir erstellen eine

672
00:11:26,389 --> 00:11:26,399
innerhalb des none-Arms aus. Wir erstellen eine
 

673
00:11:26,399 --> 00:11:27,430
innerhalb des none-Arms aus. Wir erstellen eine
Variable namens v

674
00:11:27,430 --> 00:11:27,440
Variable namens v
 

675
00:11:27,440 --> 00:11:29,590
Variable namens v
und setzen sie gleich dem Ergebnis des

676
00:11:29,590 --> 00:11:29,600
und setzen sie gleich dem Ergebnis des
 

677
00:11:29,600 --> 00:11:31,350
und setzen sie gleich dem Ergebnis des
Aufrufs unseres

678
00:11:31,350 --> 00:11:31,360
Aufrufs unseres
 

679
00:11:31,360 --> 00:11:35,030
Aufrufs unseres
Berechnungsabschlusses und der Übergabe der arg-Variablen

680
00:11:35,030 --> 00:11:35,040
Berechnungsabschlusses und der Übergabe der arg-Variablen
 

681
00:11:35,040 --> 00:11:37,110
Berechnungsabschlusses und der Übergabe der arg-Variablen
dann mutieren wir das Wertefeld

682
00:11:37,110 --> 00:11:37,120
dann mutieren wir das Wertefeld
 

683
00:11:37,120 --> 00:11:38,710
dann mutieren wir das Wertefeld
des aktuellen Caches oder der aktuellen Instanz

684
00:11:38,710 --> 00:11:38,720
des aktuellen Caches oder der aktuellen Instanz
 

685
00:11:38,720 --> 00:11:42,069
des aktuellen Caches oder der aktuellen Instanz
und setzen es auf eine Übergabe in v.

686
00:11:42,069 --> 00:11:42,079
und setzen es auf eine Übergabe in v.
 

687
00:11:42,079 --> 00:11:44,069
und setzen es auf eine Übergabe in v.
Hier findet das Caching statt. Wir

688
00:11:44,069 --> 00:11:44,079
Hier findet das Caching statt. Wir
 

689
00:11:44,079 --> 00:11:45,829
Hier findet das Caching statt. Wir
speichern den Rückgabewert unserer

690
00:11:45,829 --> 00:11:45,839
speichern den Rückgabewert unserer
 

691
00:11:45,839 --> 00:11:46,949
speichern den Rückgabewert unserer
Berechnung

692
00:11:46,949 --> 00:11:46,959
Berechnung
 

693
00:11:46,959 --> 00:11:49,110
Berechnung
im Wertefeld und geben dann

694
00:11:49,110 --> 00:11:49,120
im Wertefeld und geben dann
 

695
00:11:49,120 --> 00:11:50,710
im Wertefeld und geben dann
einfach

696
00:11:50,710 --> 00:11:50,720
einfach
 

697
00:11:50,720 --> 00:11:53,190
einfach
v next let zurück  's verwenden unser Geld oder unsere

698
00:11:53,190 --> 00:11:53,200
v next let zurück  's verwenden unser Geld oder unsere
 

699
00:11:53,200 --> 00:11:55,350
v next let zurück  's verwenden unser Geld oder unsere
Struktur in der Funktion "Training generieren",

700
00:11:55,350 --> 00:11:55,360
Struktur in der Funktion "Training generieren",
 

701
00:11:55,360 --> 00:11:57,430
Struktur in der Funktion "Training generieren",
aber bevor wir das tun, lassen Sie uns zuerst

702
00:11:57,430 --> 00:11:57,440
aber bevor wir das tun, lassen Sie uns zuerst
 

703
00:11:57,440 --> 00:12:03,509
aber bevor wir das tun, lassen Sie uns zuerst
unser Programm ausführen,

704
00:12:03,509 --> 00:12:03,519

 

705
00:12:03,519 --> 00:12:05,590

wie Sie sehen können, wurde unser teurer Abschluss

706
00:12:05,590 --> 00:12:05,600
wie Sie sehen können, wurde unser teurer Abschluss
 

707
00:12:05,600 --> 00:12:06,710
wie Sie sehen können, wurde unser teurer Abschluss
zweimal aufgerufen,

708
00:12:06,710 --> 00:12:06,720
zweimal aufgerufen,
 

709
00:12:06,720 --> 00:12:08,949
zweimal aufgerufen,
einmal, um die Anzahl der Liegestütze

710
00:12:08,949 --> 00:12:08,959
einmal, um die Anzahl der Liegestütze
 

711
00:12:08,959 --> 00:12:10,550
einmal, um die Anzahl der Liegestütze
zu berechnen, und das zweite Mal, um

712
00:12:10,550 --> 00:12:10,560
zu berechnen, und das zweite Mal, um
 

713
00:12:10,560 --> 00:12:12,870
zu berechnen, und das zweite Mal, um
die Anzahl der Liegestütze zu berechnen  Sit-ups machen wir dies

714
00:12:12,870 --> 00:12:12,880
die Anzahl der Liegestütze zu berechnen  Sit-ups machen wir dies
 

715
00:12:12,880 --> 00:12:14,710
die Anzahl der Liegestütze zu berechnen  Sit-ups machen wir dies
effizienter, indem wir unsere Closure-

716
00:12:14,710 --> 00:12:14,720
effizienter, indem wir unsere Closure-
 

717
00:12:14,720 --> 00:12:15,430
effizienter, indem wir unsere Closure-

718
00:12:15,430 --> 00:12:15,440

 

719
00:12:15,440 --> 00:12:27,990

Definition hier in unsere Casher-Struktur einpacken.

720
00:12:27,990 --> 00:12:28,000

 

721
00:12:28,000 --> 00:12:29,750

Hier rufen wir die neue Funktion für

722
00:12:29,750 --> 00:12:29,760
Hier rufen wir die neue Funktion für
 

723
00:12:29,760 --> 00:12:31,829
Hier rufen wir die neue Funktion für
unser Cash oder unsere Struktur auf und übergeben

724
00:12:31,829 --> 00:12:31,839
unser Cash oder unsere Struktur auf und übergeben
 

725
00:12:31,839 --> 00:12:34,069
unser Cash oder unsere Struktur auf und übergeben
unseren Closing, der auf das

726
00:12:34,069 --> 00:12:35,430
unseren Closing, der auf das
 

727
00:12:35,430 --> 00:12:35,440

 

728
00:12:35,440 --> 00:12:37,670

Berechnungsfeld unserer Cash-Restruct-Let's gesetzt wird  Ändern Sie unseren

729
00:12:37,670 --> 00:12:37,680
Berechnungsfeld unserer Cash-Restruct-Let's gesetzt wird  Ändern Sie unseren
 

730
00:12:37,680 --> 00:12:42,870
Berechnungsfeld unserer Cash-Restruct-Let's gesetzt wird  Ändern Sie unseren
Variablennamen in ein zwischengespeichertes Ergebnis.

731
00:12:42,870 --> 00:12:42,880

 

732
00:12:42,880 --> 00:12:44,310

Wir möchten unsere Variable auch

733
00:12:44,310 --> 00:12:44,320
Wir möchten unsere Variable auch
 

734
00:12:44,320 --> 00:12:45,910
Wir möchten unsere Variable auch
änderbar machen, da wir die Wertmethode aufrufen, die

735
00:12:45,910 --> 00:12:46,790
änderbar machen, da wir die Wertmethode aufrufen, die
 

736
00:12:46,790 --> 00:12:46,800

 

737
00:12:46,800 --> 00:12:52,389

unseren Cache oder unsere Struktur mutiert.

738
00:12:52,389 --> 00:12:52,399
unseren Cache oder unsere Struktur mutiert.
 

739
00:12:52,399 --> 00:12:54,230
unseren Cache oder unsere Struktur mutiert.
Anstatt den teuren

740
00:12:54,230 --> 00:12:54,240
Anstatt den teuren
 

741
00:12:54,240 --> 00:12:55,509
Anstatt den teuren
Abschluss aufzurufen, rufen wir

742
00:12:55,509 --> 00:12:55,519
Abschluss aufzurufen, rufen wir
 

743
00:12:55,519 --> 00:13:07,590
Abschluss aufzurufen, rufen wir
cachedresult dot value

744
00:13:07,590 --> 00:13:07,600
cachedresult dot value
 

745
00:13:07,600 --> 00:13:13,269
cachedresult dot value
auf  Führen Sie unser Programm erneut aus,

746
00:13:13,269 --> 00:13:13,279

 

747
00:13:13,279 --> 00:13:15,269

und wie Sie sehen können,

748
00:13:15,269 --> 00:13:15,279
und wie Sie sehen können,
 

749
00:13:15,279 --> 00:13:17,590
und wie Sie sehen können,
rufen wir unsere teure Operation diesmal nur

750
00:13:17,590 --> 00:13:17,600
rufen wir unsere teure Operation diesmal nur
 

751
00:13:17,600 --> 00:13:20,389
rufen wir unsere teure Operation diesmal nur
einmal auf, jetzt ist das Caching von Werten im Allgemeinen ein

752
00:13:20,389 --> 00:13:20,399
einmal auf, jetzt ist das Caching von Werten im Allgemeinen ein
 

753
00:13:20,399 --> 00:13:22,470
einmal auf, jetzt ist das Caching von Werten im Allgemeinen ein
nützliches Verhalten, sodass wir

754
00:13:22,470 --> 00:13:22,480
nützliches Verhalten, sodass wir
 

755
00:13:22,480 --> 00:13:23,350
nützliches Verhalten, sodass wir
unseren

756
00:13:23,350 --> 00:13:23,360
unseren
 

757
00:13:23,360 --> 00:13:25,590
unseren
Cacher möglicherweise anders verwenden möchten  Kontexte, aber es gibt zwei

758
00:13:25,590 --> 00:13:25,600
Cacher möglicherweise anders verwenden möchten  Kontexte, aber es gibt zwei
 

759
00:13:25,600 --> 00:13:27,910
Cacher möglicherweise anders verwenden möchten  Kontexte, aber es gibt zwei
Probleme, die uns daran hindern, dieses

760
00:13:27,910 --> 00:13:27,920
Probleme, die uns daran hindern, dieses
 

761
00:13:27,920 --> 00:13:30,230
Probleme, die uns daran hindern, dieses
Problem zu lösen. Nummer eins ist, dass der Aufruf unserer

762
00:13:30,230 --> 00:13:32,069
Problem zu lösen. Nummer eins ist, dass der Aufruf unserer
 

763
00:13:32,069 --> 00:13:32,079

 

764
00:13:32,079 --> 00:13:35,190

Wertmethode den gleichen Wert zurückgibt, unabhängig davon, was der arg-

765
00:13:35,190 --> 00:13:35,200
Wertmethode den gleichen Wert zurückgibt, unabhängig davon, was der arg-
 

766
00:13:35,200 --> 00:13:37,829
Wertmethode den gleichen Wert zurückgibt, unabhängig davon, was der arg-
Eingabeparameter ist. Sagen wir zum Beispiel, wenn

767
00:13:37,829 --> 00:13:37,839
Eingabeparameter ist. Sagen wir zum Beispiel, wenn
 

768
00:13:37,839 --> 00:13:39,910
Eingabeparameter ist. Sagen wir zum Beispiel, wenn
wir die Wertmethode zum ersten Mal aufrufen,

769
00:13:39,910 --> 00:13:39,920
wir die Wertmethode zum ersten Mal aufrufen,
 

770
00:13:39,920 --> 00:13:43,110
wir die Wertmethode zum ersten Mal aufrufen,
übergeben wir einen  als Wert für arg,

771
00:13:43,110 --> 00:13:43,120
übergeben wir einen  als Wert für arg,
 

772
00:13:43,120 --> 00:13:44,389
übergeben wir einen  als Wert für arg,
da dies das erste Mal ist, dass wir

773
00:13:44,389 --> 00:13:44,399
da dies das erste Mal ist, dass wir
 

774
00:13:44,399 --> 00:13:46,790
da dies das erste Mal ist, dass wir
die Wertmethode self.value aufrufen, die

775
00:13:46,790 --> 00:13:46,800
die Wertmethode self.value aufrufen, die
 

776
00:13:46,800 --> 00:13:48,230
die Wertmethode self.value aufrufen, die
zu none ausgewertet wird,

777
00:13:48,230 --> 00:13:48,240
zu none ausgewertet wird,
 

778
00:13:48,240 --> 00:13:50,150
zu none ausgewertet wird,
also gehen wir in den none-Zweig und

779
00:13:50,150 --> 00:13:50,160
also gehen wir in den none-Zweig und
 

780
00:13:50,160 --> 00:13:51,350
also gehen wir in den none-Zweig und
rufen dann unseren

781
00:13:51,350 --> 00:13:51,360
rufen dann unseren
 

782
00:13:51,360 --> 00:13:53,910
rufen dann unseren
Abschluss mit unserem arg auf,

783
00:13:53,910 --> 00:13:53,920
Abschluss mit unserem arg auf,
 

784
00:13:53,920 --> 00:13:55,269
Abschluss mit unserem arg auf,
das gleich sein wird  zu 1.

785
00:13:55,269 --> 00:13:55,279
das gleich sein wird  zu 1.
 

786
00:13:55,279 --> 00:13:57,670
das gleich sein wird  zu 1.
dann nehmen wir den resultierenden Wert und

787
00:13:57,670 --> 00:13:57,680
dann nehmen wir den resultierenden Wert und
 

788
00:13:57,680 --> 00:13:58,870
dann nehmen wir den resultierenden Wert und
speichern ihn in

789
00:13:58,870 --> 00:13:58,880
speichern ihn in
 

790
00:13:58,880 --> 00:14:01,670
speichern ihn in
self.value Jetzt stellen Sie sich vor, wir rufen unsere value-

791
00:14:01,670 --> 00:14:01,680
self.value Jetzt stellen Sie sich vor, wir rufen unsere value-
 

792
00:14:01,680 --> 00:14:02,150
self.value Jetzt stellen Sie sich vor, wir rufen unsere value-
Methode

793
00:14:02,150 --> 00:14:02,160
Methode
 

794
00:14:02,160 --> 00:14:04,870
Methode
erneut auf, aber dieses Mal übergeben wir 2 als

795
00:14:04,870 --> 00:14:04,880
erneut auf, aber dieses Mal übergeben wir 2 als
 

796
00:14:04,880 --> 00:14:05,590
erneut auf, aber dieses Mal übergeben wir 2 als
Wert für

797
00:14:05,590 --> 00:14:05,600
Wert für
 

798
00:14:05,600 --> 00:14:08,470
Wert für
arg. Diesmal ist self.value bereits vorhanden,

799
00:14:08,470 --> 00:14:08,480
arg. Diesmal ist self.value bereits vorhanden,
 

800
00:14:08,480 --> 00:14:10,550
arg. Diesmal ist self.value bereits vorhanden,
also gehen wir  in den sum-Arm und geben Sie einfach

801
00:14:10,550 --> 00:14:10,560
also gehen wir  in den sum-Arm und geben Sie einfach
 

802
00:14:10,560 --> 00:14:13,350
also gehen wir  in den sum-Arm und geben Sie einfach
den in sum gespeicherten Wert zurück. Dies ist

803
00:14:13,350 --> 00:14:13,360
den in sum gespeicherten Wert zurück. Dies ist
 

804
00:14:13,360 --> 00:14:14,389
den in sum gespeicherten Wert zurück. Dies ist
problematisch, da

805
00:14:14,389 --> 00:14:14,399
problematisch, da
 

806
00:14:14,399 --> 00:14:16,790
problematisch, da
r an unseren Abschluss weitergegeben wird, was bedeutet,

807
00:14:16,790 --> 00:14:16,800
r an unseren Abschluss weitergegeben wird, was bedeutet,
 

808
00:14:16,800 --> 00:14:18,790
r an unseren Abschluss weitergegeben wird, was bedeutet,
dass es den resultierenden Wert

809
00:14:18,790 --> 00:14:18,800
dass es den resultierenden Wert
 

810
00:14:18,800 --> 00:14:19,430
dass es den resultierenden Wert

811
00:14:19,430 --> 00:14:19,440

 

812
00:14:19,440 --> 00:14:21,269

aus unserem Abschluss ändern könnte, aber mit unserer aktuellen

813
00:14:21,269 --> 00:14:21,279
aus unserem Abschluss ändern könnte, aber mit unserer aktuellen
 

814
00:14:21,279 --> 00:14:23,430
aus unserem Abschluss ändern könnte, aber mit unserer aktuellen
Implementierung wird der Wert

815
00:14:23,430 --> 00:14:23,440
Implementierung wird der Wert
 

816
00:14:23,440 --> 00:14:25,590
Implementierung wird der Wert
immer gleich dem re sein  Als Ergebnis des Aufrufs

817
00:14:25,590 --> 00:14:25,600
immer gleich dem re sein  Als Ergebnis des Aufrufs
 

818
00:14:25,600 --> 00:14:27,829
immer gleich dem re sein  Als Ergebnis des Aufrufs
unserer Schließung mit dem Argument, das

819
00:14:27,829 --> 00:14:27,839
unserer Schließung mit dem Argument, das
 

820
00:14:27,839 --> 00:14:29,110
unserer Schließung mit dem Argument, das
in den ersten Aufruf

821
00:14:29,110 --> 00:14:29,120
in den ersten Aufruf
 

822
00:14:29,120 --> 00:14:31,350
in den ersten Aufruf
zum Wert übergeben wurde, sage ich im Grunde, dass

823
00:14:31,350 --> 00:14:33,189
zum Wert übergeben wurde, sage ich im Grunde, dass
 

824
00:14:33,189 --> 00:14:35,590

 

825
00:14:35,590 --> 00:14:35,600

 

826
00:14:35,600 --> 00:14:36,710

wir, anstatt einen Wert einzulösen, unabhängig vom übergebenen Argument,

827
00:14:36,710 --> 00:14:36,720
wir, anstatt einen Wert einzulösen, unabhängig vom übergebenen Argument,
 

828
00:14:36,720 --> 00:14:39,110
wir, anstatt einen Wert einzulösen, unabhängig vom übergebenen Argument,
einen Wert für jedes Argument einlösen müssen,

829
00:14:39,110 --> 00:14:39,120
einen Wert für jedes Argument einlösen müssen,
 

830
00:14:39,120 --> 00:14:40,790
einen Wert für jedes Argument einlösen müssen,
das aufgrund des Arguments übergeben wird

831
00:14:40,790 --> 00:14:40,800
das aufgrund des Arguments übergeben wird
 

832
00:14:40,800 --> 00:14:43,750
das aufgrund des Arguments übergeben wird
als Übung den Wert beeinflusst,

833
00:14:43,750 --> 00:14:43,760
als Übung den Wert beeinflusst,
 

834
00:14:43,760 --> 00:14:45,910
als Übung den Wert beeinflusst,
können Sie diese Implementierung beheben, indem Sie eine

835
00:14:45,910 --> 00:14:45,920
können Sie diese Implementierung beheben, indem Sie eine
 

836
00:14:45,920 --> 00:14:46,629
können Sie diese Implementierung beheben, indem Sie eine
Hashmap

837
00:14:46,629 --> 00:14:46,639
Hashmap
 

838
00:14:46,639 --> 00:14:48,949
Hashmap
anstelle eines einzelnen Werts speichern. Die Schlüssel

839
00:14:48,949 --> 00:14:48,959
anstelle eines einzelnen Werts speichern. Die Schlüssel
 

840
00:14:48,959 --> 00:14:50,389
anstelle eines einzelnen Werts speichern. Die Schlüssel
der Hashmap sind

841
00:14:50,389 --> 00:14:50,399
der Hashmap sind
 

842
00:14:50,399 --> 00:14:53,110
der Hashmap sind
das Argument, das an value übergeben wird, und die

843
00:14:53,110 --> 00:14:53,120
das Argument, das an value übergeben wird, und die
 

844
00:14:53,120 --> 00:14:54,470
das Argument, das an value übergeben wird, und die
Werte in Ihrer

845
00:14:54,470 --> 00:14:54,480
Werte in Ihrer
 

846
00:14:54,480 --> 00:14:57,189
Werte in Ihrer
Hashmap sind das Ergebnis des Aufrufs der

847
00:14:57,189 --> 00:14:57,199
Hashmap sind das Ergebnis des Aufrufs der
 

848
00:14:57,199 --> 00:14:58,069
Hashmap sind das Ergebnis des Aufrufs der
Schließung

849
00:14:58,069 --> 00:14:58,079
Schließung
 

850
00:14:58,079 --> 00:15:00,550
Schließung
mit dem Argument then  Im

851
00:15:00,550 --> 00:15:00,560
mit dem Argument then  Im
 

852
00:15:00,560 --> 00:15:01,670
mit dem Argument then  Im
Hauptteil dieser

853
00:15:01,670 --> 00:15:01,680
Hauptteil dieser
 

854
00:15:01,680 --> 00:15:04,150
Hauptteil dieser
Wertmethode müssen Sie das Argument in

855
00:15:04,150 --> 00:15:04,160
Wertmethode müssen Sie das Argument in
 

856
00:15:04,160 --> 00:15:05,110
Wertmethode müssen Sie das Argument in
Ihrer Hash-

857
00:15:05,110 --> 00:15:05,120
Ihrer Hash-
 

858
00:15:05,120 --> 00:15:07,829
Ihrer Hash-
Map nachschlagen. Wenn ein Wert für dieses Argument vorhanden ist, geben Sie

859
00:15:07,829 --> 00:15:07,839
Map nachschlagen. Wenn ein Wert für dieses Argument vorhanden ist, geben Sie
 

860
00:15:07,839 --> 00:15:09,110
Map nachschlagen. Wenn ein Wert für dieses Argument vorhanden ist, geben Sie
einfach

861
00:15:09,110 --> 00:15:09,120
einfach
 

862
00:15:09,120 --> 00:15:11,590
einfach
den Wert zurück, und wenn er nicht vorhanden ist, führen Sie

863
00:15:11,590 --> 00:15:11,600
den Wert zurück, und wenn er nicht vorhanden ist, führen Sie
 

864
00:15:11,600 --> 00:15:13,829
den Wert zurück, und wenn er nicht vorhanden ist, führen Sie
Ihre teure Berechnung aus und speichern Sie das

865
00:15:13,829 --> 00:15:13,839
Ihre teure Berechnung aus und speichern Sie das
 

866
00:15:13,839 --> 00:15:14,550
Ihre teure Berechnung aus und speichern Sie das
Ergebnis

867
00:15:14,550 --> 00:15:14,560
Ergebnis
 

868
00:15:14,560 --> 00:15:16,790
Ergebnis
darin  Ihre Hash-Karte Das zweite Problem

869
00:15:16,790 --> 00:15:16,800
darin  Ihre Hash-Karte Das zweite Problem
 

870
00:15:16,800 --> 00:15:18,949
darin  Ihre Hash-Karte Das zweite Problem
bei unserer Cacher-Implementierung

871
00:15:18,949 --> 00:15:18,959
bei unserer Cacher-Implementierung
 

872
00:15:18,959 --> 00:15:21,350
bei unserer Cacher-Implementierung
ist, dass wir fest codierte Typen verwenden, zum

873
00:15:21,350 --> 00:15:21,360
ist, dass wir fest codierte Typen verwenden, zum
 

874
00:15:21,360 --> 00:15:22,710
ist, dass wir fest codierte Typen verwenden, zum
Beispiel sagen wir, dass unser

875
00:15:22,710 --> 00:15:22,720
Beispiel sagen wir, dass unser
 

876
00:15:22,720 --> 00:15:25,189
Beispiel sagen wir, dass unser
Abschluss eine Ganzzahl akzeptieren und

877
00:15:25,189 --> 00:15:25,199
Abschluss eine Ganzzahl akzeptieren und
 

878
00:15:25,199 --> 00:15:26,470
Abschluss eine Ganzzahl akzeptieren und
eine Ganzzahl zurückgeben muss

879
00:15:26,470 --> 00:15:26,480
eine Ganzzahl zurückgeben muss
 

880
00:15:26,480 --> 00:15:28,949
eine Ganzzahl zurückgeben muss
und unser Wert muss auch eine Ganzzahl sein

881
00:15:28,949 --> 00:15:28,959
und unser Wert muss auch eine Ganzzahl sein
 

882
00:15:28,959 --> 00:15:29,590
und unser Wert muss auch eine Ganzzahl sein

883
00:15:29,590 --> 00:15:29,600

 

884
00:15:29,600 --> 00:15:32,069

, um dies zu beheben, können Sie einfach Generika

885
00:15:32,069 --> 00:15:32,079
, um dies zu beheben, können Sie einfach Generika
 

886
00:15:32,079 --> 00:15:32,710
, um dies zu beheben, können Sie einfach Generika
anstelle von

887
00:15:32,710 --> 00:15:32,720
anstelle von
 

888
00:15:32,720 --> 00:15:34,870
anstelle von
fest codierten Werten verwenden. Das letzte, worüber

889
00:15:34,870 --> 00:15:34,880
fest codierten Werten verwenden. Das letzte, worüber
 

890
00:15:34,880 --> 00:15:36,629
fest codierten Werten verwenden. Das letzte, worüber
ich sprechen möchte, ist das Erfassen der

891
00:15:36,629 --> 00:15:36,639
ich sprechen möchte, ist das Erfassen der
 

892
00:15:36,639 --> 00:15:38,389
ich sprechen möchte, ist das Erfassen der
Umgebung mit Closures, im

893
00:15:38,389 --> 00:15:38,399
Umgebung mit Closures, im
 

894
00:15:38,399 --> 00:15:41,189
Umgebung mit Closures, im
Gegensatz zu Funktionsclosures, die Zugriff auf

895
00:15:41,189 --> 00:15:41,199
Gegensatz zu Funktionsclosures, die Zugriff auf
 

896
00:15:41,199 --> 00:15:42,069
Gegensatz zu Funktionsclosures, die Zugriff auf
Variablen haben

897
00:15:42,069 --> 00:15:42,079
Variablen haben
 

898
00:15:42,079 --> 00:15:43,990
Variablen haben
, die in definiert sind  Bereich, in

899
00:15:43,990 --> 00:15:44,000
, die in definiert sind  Bereich, in
 

900
00:15:44,000 --> 00:15:45,829
, die in definiert sind  Bereich, in
dem der Abschluss definiert ist,

901
00:15:45,829 --> 00:15:45,839
dem der Abschluss definiert ist,
 

902
00:15:45,839 --> 00:15:47,749
dem der Abschluss definiert ist,
hier ist ein einfaches Beispiel. Oben haben

903
00:15:47,749 --> 00:15:47,759
hier ist ein einfaches Beispiel. Oben haben
 

904
00:15:47,759 --> 00:15:48,870
hier ist ein einfaches Beispiel. Oben haben
wir eine Variable namens

905
00:15:48,870 --> 00:15:48,880
wir eine Variable namens
 

906
00:15:48,880 --> 00:15:51,590
wir eine Variable namens
x, die gleich vier ist, dann haben wir einen

907
00:15:51,590 --> 00:15:51,600
x, die gleich vier ist, dann haben wir einen
 

908
00:15:51,600 --> 00:15:53,350
x, die gleich vier ist, dann haben wir einen
Abschluss namens gleich x,

909
00:15:53,350 --> 00:15:53,360
Abschluss namens gleich x,
 

910
00:15:53,360 --> 00:15:55,749
Abschluss namens gleich x,
der eine Variable namens z aufnimmt und

911
00:15:55,749 --> 00:15:55,759
der eine Variable namens z aufnimmt und
 

912
00:15:55,759 --> 00:15:57,509
der eine Variable namens z aufnimmt und
dann einen

913
00:15:57,509 --> 00:15:57,519
dann einen
 

914
00:15:57,519 --> 00:15:59,110
dann einen
booleschen Wert zurückgibt, den der boolesche Wert hat  Um diesem

915
00:15:59,110 --> 00:15:59,120
booleschen Wert zurückgibt, den der boolesche Wert hat  Um diesem
 

916
00:15:59,120 --> 00:16:00,949
booleschen Wert zurückgibt, den der boolesche Wert hat  Um diesem
Ausdruck gleich

917
00:16:00,949 --> 00:16:00,959
Ausdruck gleich
 

918
00:16:00,959 --> 00:16:03,590
Ausdruck gleich
zu sein, ist z jetzt gleich x, obwohl x außerhalb unserer Closure definiert ist, hat

919
00:16:03,590 --> 00:16:05,110
zu sein, ist z jetzt gleich x, obwohl x außerhalb unserer Closure definiert ist, hat
 

920
00:16:05,110 --> 00:16:05,120

 

921
00:16:05,120 --> 00:16:07,430

unsere Closure immer noch Zugriff auf x,

922
00:16:07,430 --> 00:16:07,440
unsere Closure immer noch Zugriff auf x,
 

923
00:16:07,440 --> 00:16:09,030
unsere Closure immer noch Zugriff auf x,
da beide im

924
00:16:09,030 --> 00:16:09,040
da beide im
 

925
00:16:09,040 --> 00:16:09,990
da beide im
selben Bereich

926
00:16:09,990 --> 00:16:10,000
selben Bereich
 

927
00:16:10,000 --> 00:16:11,990
selben Bereich
definiert sind. Dann definieren wir eine Variable namens y und

928
00:16:11,990 --> 00:16:12,000
definiert sind. Dann definieren wir eine Variable namens y und
 

929
00:16:12,000 --> 00:16:13,749
definiert sind. Dann definieren wir eine Variable namens y und
setzen sie ebenfalls gleich  bis vier

930
00:16:13,749 --> 00:16:13,759
setzen sie ebenfalls gleich  bis vier
 

931
00:16:13,759 --> 00:16:16,710
setzen sie ebenfalls gleich  bis vier
Schließlich rufen wir unsere Schließung auf, indem wir y übergeben.

932
00:16:16,710 --> 00:16:16,720
Schließlich rufen wir unsere Schließung auf, indem wir y übergeben.
 

933
00:16:16,720 --> 00:16:18,470
Schließlich rufen wir unsere Schließung auf, indem wir y übergeben.
Der Aufruf unserer Schließung wird

934
00:16:18,470 --> 00:16:18,480
Der Aufruf unserer Schließung wird
 

935
00:16:18,480 --> 00:16:20,310
Der Aufruf unserer Schließung wird
in ein Assert-Makro gewickelt,

936
00:16:20,310 --> 00:16:20,320
in ein Assert-Makro gewickelt,
 

937
00:16:20,320 --> 00:16:22,629
in ein Assert-Makro gewickelt,
das in Panik gerät, wenn die Call-Tower-

938
00:16:22,629 --> 00:16:22,639
das in Panik gerät, wenn die Call-Tower-
 

939
00:16:22,639 --> 00:16:23,590
das in Panik gerät, wenn die Call-Tower-
Funktion

940
00:16:23,590 --> 00:16:23,600
Funktion
 

941
00:16:23,600 --> 00:16:26,069
Funktion
falsch ergibt. Lassen Sie uns also fortfahren und unser Programm ausführen

942
00:16:26,069 --> 00:16:26,079
falsch ergibt. Lassen Sie uns also fortfahren und unser Programm ausführen
 

943
00:16:26,079 --> 00:16:28,710
falsch ergibt. Lassen Sie uns also fortfahren und unser Programm ausführen

944
00:16:28,710 --> 00:16:28,720

 

945
00:16:28,720 --> 00:16:31,670

und wie Sie sehen können, sind wir jetzt nicht in Panik geraten. Mal

946
00:16:31,670 --> 00:16:31,680
und wie Sie sehen können, sind wir jetzt nicht in Panik geraten. Mal
 

947
00:16:31,680 --> 00:16:33,509
und wie Sie sehen können, sind wir jetzt nicht in Panik geraten. Mal
sehen, was passieren würde, wenn wir eine

948
00:16:33,509 --> 00:16:33,519
sehen, was passieren würde, wenn wir eine
 

949
00:16:33,519 --> 00:16:34,230
sehen, was passieren würde, wenn wir eine
Funktion

950
00:16:34,230 --> 00:16:34,240
Funktion
 

951
00:16:34,240 --> 00:16:36,710
Funktion
anstelle eines Abschlusses verwenden würden, also ändern wir unseren

952
00:16:36,710 --> 00:16:36,720
anstelle eines Abschlusses verwenden würden, also ändern wir unseren
 

953
00:16:36,720 --> 00:16:37,670
anstelle eines Abschlusses verwenden würden, also ändern wir unseren
Gleich-zu-x-

954
00:16:37,670 --> 00:16:37,680
Gleich-zu-x-
 

955
00:16:37,680 --> 00:16:41,829
Gleich-zu-x-
Abschluss in eine Funktion.

956
00:16:41,829 --> 00:16:41,839

 

957
00:16:41,839 --> 00:16:43,910

Hier können Sie einige rote verschnörkelte Linien

958
00:16:43,910 --> 00:16:43,920
Hier können Sie einige rote verschnörkelte Linien
 

959
00:16:43,920 --> 00:16:45,910
Hier können Sie einige rote verschnörkelte Linien
unter x und wenn i sehen  Wenn Sie den Mauszeiger darüber bewegen, können Sie

960
00:16:45,910 --> 00:16:45,920
unter x und wenn i sehen  Wenn Sie den Mauszeiger darüber bewegen, können Sie
 

961
00:16:45,920 --> 00:16:47,030
unter x und wenn i sehen  Wenn Sie den Mauszeiger darüber bewegen, können Sie
sehen, dass der Fehler darin besteht

962
00:16:47,030 --> 00:16:47,040
sehen, dass der Fehler darin besteht
 

963
00:16:47,040 --> 00:16:49,509
sehen, dass der Fehler darin besteht
, dass die dynamische Umgebung in einer Funktion nicht erfasst werden

964
00:16:49,509 --> 00:16:49,519
, dass die dynamische Umgebung in einer Funktion nicht erfasst werden
 

965
00:16:49,519 --> 00:16:50,470
, dass die dynamische Umgebung in einer Funktion nicht erfasst werden
kann.

966
00:16:50,470 --> 00:16:50,480
kann.
 

967
00:16:50,480 --> 00:16:52,710
kann.
Verwenden Sie stattdessen eine Closure. Der Compiler weist

968
00:16:52,710 --> 00:16:52,720
Verwenden Sie stattdessen eine Closure. Der Compiler weist
 

969
00:16:52,720 --> 00:16:54,230
Verwenden Sie stattdessen eine Closure. Der Compiler weist
uns also tatsächlich an,

970
00:16:54,230 --> 00:16:54,240
uns also tatsächlich an,
 

971
00:16:54,240 --> 00:16:56,550
uns also tatsächlich an,
eine Closure anstelle einer Funktion zu verwenden, da

972
00:16:56,550 --> 00:16:56,560
eine Closure anstelle einer Funktion zu verwenden, da
 

973
00:16:56,560 --> 00:16:58,230
eine Closure anstelle einer Funktion zu verwenden, da
Closures in der Lage sind, ihre Umgebung zu erfassen, die

974
00:16:58,230 --> 00:16:58,240
Closures in der Lage sind, ihre Umgebung zu erfassen, die
 

975
00:16:58,240 --> 00:16:58,949
Closures in der Lage sind, ihre Umgebung zu erfassen, die

976
00:16:58,949 --> 00:16:58,959

 

977
00:16:58,959 --> 00:17:01,189

sie benötigen, um zusätzlichen Speicher zu verwenden  um

978
00:17:01,189 --> 00:17:01,199
sie benötigen, um zusätzlichen Speicher zu verwenden  um
 

979
00:17:01,199 --> 00:17:02,310
sie benötigen, um zusätzlichen Speicher zu verwenden  um
diesen Kontext zu speichern,

980
00:17:02,310 --> 00:17:02,320
diesen Kontext zu speichern,
 

981
00:17:02,320 --> 00:17:04,069
diesen Kontext zu speichern,
aber da Funktionen

982
00:17:04,069 --> 00:17:04,079
aber da Funktionen
 

983
00:17:04,079 --> 00:17:06,069
aber da Funktionen
ihre Umgebung nicht erfassen, verursachen sie nicht die

984
00:17:06,069 --> 00:17:06,079
ihre Umgebung nicht erfassen, verursachen sie nicht die
 

985
00:17:06,079 --> 00:17:07,429
ihre Umgebung nicht erfassen, verursachen sie nicht die
gleichen Overhead-

986
00:17:07,429 --> 00:17:07,439
gleichen Overhead-
 

987
00:17:07,439 --> 00:17:09,189
gleichen Overhead-
Abschlüsse. Erfassen Sie Werte aus ihrer

988
00:17:09,189 --> 00:17:09,199
Abschlüsse. Erfassen Sie Werte aus ihrer
 

989
00:17:09,199 --> 00:17:10,870
Abschlüsse. Erfassen Sie Werte aus ihrer
Umgebung auf drei Arten,

990
00:17:10,870 --> 00:17:10,880
Umgebung auf drei Arten,
 

991
00:17:10,880 --> 00:17:13,110
Umgebung auf drei Arten,
die direkt den drei Arten entsprechen, wie eine

992
00:17:13,110 --> 00:17:13,120
die direkt den drei Arten entsprechen, wie eine
 

993
00:17:13,120 --> 00:17:14,549
die direkt den drei Arten entsprechen, wie eine
Funktion Eingabeparameter übernehmen könnte,

994
00:17:14,549 --> 00:17:14,559
Funktion Eingabeparameter übernehmen könnte,
 

995
00:17:14,559 --> 00:17:17,590
Funktion Eingabeparameter übernehmen könnte,
indem sie den Besitz durch

996
00:17:17,590 --> 00:17:17,600
indem sie den Besitz durch
 

997
00:17:17,600 --> 00:17:18,870
indem sie den Besitz durch
unveränderliche Ausleihe übernimmt

998
00:17:18,870 --> 00:17:18,880
unveränderliche Ausleihe übernimmt
 

999
00:17:18,880 --> 00:17:21,909
unveränderliche Ausleihe übernimmt
oder durch unveränderliches Ausleihen dieser drei

1000
00:17:21,909 --> 00:17:21,919
oder durch unveränderliches Ausleihen dieser drei
 

1001
00:17:21,919 --> 00:17:23,669
oder durch unveränderliches Ausleihen dieser drei
Möglichkeiten, die Umgebung zu erfassen,

1002
00:17:23,669 --> 00:17:23,679
Möglichkeiten, die Umgebung zu erfassen,
 

1003
00:17:23,679 --> 00:17:26,069
Möglichkeiten, die Umgebung zu erfassen,
sind in den Funktionsmerkmalen kodiert, über die wir

1004
00:17:26,069 --> 00:17:26,079
sind in den Funktionsmerkmalen kodiert, über die wir
 

1005
00:17:26,079 --> 00:17:27,350
sind in den Funktionsmerkmalen kodiert, über die wir
zuvor gesprochen haben

1006
00:17:27,350 --> 00:17:27,360
zuvor gesprochen haben
 

1007
00:17:27,360 --> 00:17:30,470
zuvor gesprochen haben
, nämlich fn einmal f und mu und

1008
00:17:30,470 --> 00:17:30,480
, nämlich fn einmal f und mu und
 

1009
00:17:30,480 --> 00:17:33,270
, nämlich fn einmal f und mu und
fn einmal fn  übernimmt den Besitz der

1010
00:17:33,270 --> 00:17:33,280
fn einmal fn  übernimmt den Besitz der
 

1011
00:17:33,280 --> 00:17:34,870
fn einmal fn  übernimmt den Besitz der
Variablen innerhalb der Closures-

1012
00:17:34,870 --> 00:17:34,880
Variablen innerhalb der Closures-
 

1013
00:17:34,880 --> 00:17:36,710
Variablen innerhalb der Closures-
Umgebung. Der Once-Teil des Namens

1014
00:17:36,710 --> 00:17:36,720
Umgebung. Der Once-Teil des Namens
 

1015
00:17:36,720 --> 00:17:38,630
Umgebung. Der Once-Teil des Namens
stellt die Tatsache dar, dass Closures

1016
00:17:38,630 --> 00:17:38,640
stellt die Tatsache dar, dass Closures
 

1017
00:17:38,640 --> 00:17:40,230
stellt die Tatsache dar, dass Closures
dieselben

1018
00:17:40,230 --> 00:17:40,240
dieselben
 

1019
00:17:40,240 --> 00:17:42,150
dieselben
Variablen nicht mehr als einmal besitzen können,

1020
00:17:42,150 --> 00:17:42,160
Variablen nicht mehr als einmal besitzen können,
 

1021
00:17:42,160 --> 00:17:43,990
Variablen nicht mehr als einmal besitzen können,
sodass diese Closures nur Ones genannt

1022
00:17:43,990 --> 00:17:45,510
sodass diese Closures nur Ones genannt
 

1023
00:17:45,510 --> 00:17:48,549

 

1024
00:17:48,549 --> 00:17:48,559

 

1025
00:17:48,559 --> 00:17:51,029

werden können  Wenn Sie

1026
00:17:51,029 --> 00:17:51,039
werden können  Wenn Sie
 

1027
00:17:51,039 --> 00:17:52,870
werden können  Wenn Sie
eine Closure erstellen, leitet Rust ab, welche dieser

1028
00:17:52,870 --> 00:17:52,880
eine Closure erstellen, leitet Rust ab, welche dieser
 

1029
00:17:52,880 --> 00:17:54,070
eine Closure erstellen, leitet Rust ab, welche dieser
Eigenschaften verwendet werden sollen,

1030
00:17:54,070 --> 00:17:54,080
Eigenschaften verwendet werden sollen,
 

1031
00:17:54,080 --> 00:17:56,630
Eigenschaften verwendet werden sollen,
basierend darauf, wie Sie die Werte in

1032
00:17:56,630 --> 00:17:56,640
basierend darauf, wie Sie die Werte in
 

1033
00:17:56,640 --> 00:17:58,230
basierend darauf, wie Sie die Werte in
der Closures-Umgebung

1034
00:17:58,230 --> 00:18:00,230
der Closures-Umgebung
 

1035
00:18:00,230 --> 00:18:00,240

 

1036
00:18:00,240 --> 00:18:02,710

verwenden

1037
00:18:02,710 --> 00:18:05,270
verwenden
 

1038
00:18:05,270 --> 00:18:05,280

 

1039
00:18:05,280 --> 00:18:05,909


1040
00:18:05,909 --> 00:18:05,919

 

1041
00:18:05,919 --> 00:18:08,070

Schließung Dies ist vor allem dann

1042
00:18:08,070 --> 00:18:08,080
Schließung Dies ist vor allem dann
 

1043
00:18:08,080 --> 00:18:09,590
Schließung Dies ist vor allem dann
nützlich, wenn Sie eine Schließung

1044
00:18:09,590 --> 00:18:09,600
nützlich, wenn Sie eine Schließung
 

1045
00:18:09,600 --> 00:18:10,470
nützlich, wenn Sie eine Schließung
von einem Thread

1046
00:18:10,470 --> 00:18:10,480
von einem Thread
 

1047
00:18:10,480 --> 00:18:12,470
von einem Thread
an einen anderen Thread übergeben, damit Sie auch

1048
00:18:12,470 --> 00:18:12,480
an einen anderen Thread übergeben, damit Sie auch
 

1049
00:18:12,480 --> 00:18:14,310
an einen anderen Thread übergeben, damit Sie auch
den Besitz der Variablen von einem

1050
00:18:14,310 --> 00:18:14,320
den Besitz der Variablen von einem
 

1051
00:18:14,320 --> 00:18:14,789
den Besitz der Variablen von einem
Thread

1052
00:18:14,789 --> 00:18:14,799
Thread
 

1053
00:18:14,799 --> 00:18:17,029
Thread
an den anderen Thread übergeben können. In diesem

1054
00:18:17,029 --> 00:18:17,039
an den anderen Thread übergeben können. In diesem
 

1055
00:18:17,039 --> 00:18:19,029
an den anderen Thread übergeben können. In diesem
Fall ist x beispielsweise gleich einem Vektor, den

1056
00:18:19,029 --> 00:18:19,039
Fall ist x beispielsweise gleich einem Vektor, den
 

1057
00:18:19,039 --> 00:18:21,750
Fall ist x beispielsweise gleich einem Vektor, den
wir haben unsere Schließung  was sich nicht ändert,

1058
00:18:21,750 --> 00:18:21,760
wir haben unsere Schließung  was sich nicht ändert,
 

1059
00:18:21,760 --> 00:18:22,789
wir haben unsere Schließung  was sich nicht ändert,
dann drucken wir

1060
00:18:22,789 --> 00:18:22,799
dann drucken wir
 

1061
00:18:22,799 --> 00:18:25,990
dann drucken wir
x aus und dann haben wir y auch gleich einem

1062
00:18:25,990 --> 00:18:26,000
x aus und dann haben wir y auch gleich einem
 

1063
00:18:26,000 --> 00:18:26,950
x aus und dann haben wir y auch gleich einem
Vektor

1064
00:18:26,950 --> 00:18:26,960
Vektor
 

1065
00:18:26,960 --> 00:18:28,950
Vektor
und dann rufen wir unseren Abschluss wieder auf,

1066
00:18:28,950 --> 00:18:28,960
und dann rufen wir unseren Abschluss wieder auf,
 

1067
00:18:28,960 --> 00:18:31,110
und dann rufen wir unseren Abschluss wieder auf,
indem wir y eingeben und behaupten,

1068
00:18:31,110 --> 00:18:31,120
indem wir y eingeben und behaupten,
 

1069
00:18:31,120 --> 00:18:33,750
indem wir y eingeben und behaupten,
dass es retu ist  rns ist jetzt wahr, weil wir in

1070
00:18:33,750 --> 00:18:33,760
dass es retu ist  rns ist jetzt wahr, weil wir in
 

1071
00:18:33,760 --> 00:18:34,549
dass es retu ist  rns ist jetzt wahr, weil wir in
unserer Closure

1072
00:18:34,549 --> 00:18:34,559
unserer Closure
 

1073
00:18:34,559 --> 00:18:37,590
unserer Closure
nur x gegen z auswerten.

1074
00:18:37,590 --> 00:18:37,600
nur x gegen z auswerten.
 

1075
00:18:37,600 --> 00:18:40,150
nur x gegen z auswerten.
Wir übernehmen innerhalb unserer Closure nicht den Besitz von x,

1076
00:18:40,150 --> 00:18:41,029
Wir übernehmen innerhalb unserer Closure nicht den Besitz von x,
 

1077
00:18:41,029 --> 00:18:41,039

 

1078
00:18:41,039 --> 00:18:43,350

aber wir könnten die Closure wieder dazu zwingen,

1079
00:18:43,350 --> 00:18:43,360
aber wir könnten die Closure wieder dazu zwingen,
 

1080
00:18:43,360 --> 00:18:44,390
aber wir könnten die Closure wieder dazu zwingen,
den Besitz zu übernehmen,

1081
00:18:44,390 --> 00:18:44,400
den Besitz zu übernehmen,
 

1082
00:18:44,400 --> 00:18:46,870
den Besitz zu übernehmen,
indem wir das Schlüsselwort move

1083
00:18:46,870 --> 00:18:46,880
indem wir das Schlüsselwort move
 

1084
00:18:46,880 --> 00:18:50,710
indem wir das Schlüsselwort move
vor unserer Closure-Definition

1085
00:18:50,710 --> 00:18:50,720

 

1086
00:18:50,720 --> 00:18:53,669

jetzt unsere Closure angeben  übernimmt x

1087
00:18:53,669 --> 00:18:53,679
jetzt unsere Closure angeben  übernimmt x
 

1088
00:18:53,679 --> 00:18:54,070
jetzt unsere Closure angeben  übernimmt x
und

1089
00:18:54,070 --> 00:18:54,080
und
 

1090
00:18:54,080 --> 00:18:56,310
und
wir erhalten einen Fehler in unserer Druckanweisung

1091
00:18:56,310 --> 00:18:56,320
wir erhalten einen Fehler in unserer Druckanweisung
 

1092
00:18:56,320 --> 00:18:58,390
wir erhalten einen Fehler in unserer Druckanweisung
unter der Definition unseres Abschlusses.

1093
00:18:58,390 --> 00:18:58,400
unter der Definition unseres Abschlusses.
 

1094
00:18:58,400 --> 00:19:00,310
unter der Definition unseres Abschlusses.
Wenn ich mit der Maus über die roten Schnörkel fahre,

1095
00:19:00,310 --> 00:19:00,320
Wenn ich mit der Maus über die roten Schnörkel fahre,
 

1096
00:19:00,320 --> 00:19:01,590
Wenn ich mit der Maus über die roten Schnörkel fahre,
können Sie sehen, dass

1097
00:19:01,590 --> 00:19:01,600
können Sie sehen, dass
 

1098
00:19:01,600 --> 00:19:04,230
können Sie sehen, dass
wir einen geliehenen Wert verwenden, nachdem

1099
00:19:04,230 --> 00:19:04,240
wir einen geliehenen Wert verwenden, nachdem
 

1100
00:19:04,240 --> 00:19:04,950
wir einen geliehenen Wert verwenden, nachdem
er verschoben wurde.

1101
00:19:04,950 --> 00:19:04,960
er verschoben wurde.
 

1102
00:19:04,960 --> 00:19:07,350
er verschoben wurde.
Dies ist sinnvoll, da oben  unsere

1103
00:19:07,350 --> 00:19:07,360
Dies ist sinnvoll, da oben  unsere
 

1104
00:19:07,360 --> 00:19:09,270
Dies ist sinnvoll, da oben  unsere
Closure übernimmt x,

1105
00:19:09,270 --> 00:19:09,280
Closure übernimmt x,
 

1106
00:19:09,280 --> 00:19:12,150
Closure übernimmt x,
also können wir x nicht mehr verwenden, nachdem es hierher verschoben

1107
00:19:12,150 --> 00:19:12,160
also können wir x nicht mehr verwenden, nachdem es hierher verschoben
 

1108
00:19:12,160 --> 00:19:13,029
also können wir x nicht mehr verwenden, nachdem es hierher verschoben
wurde. Okay

1109
00:19:13,029 --> 00:19:13,039
wurde. Okay
 

1110
00:19:13,039 --> 00:19:14,789
wurde. Okay
, das schließt Teil eins von

1111
00:19:14,789 --> 00:19:14,799
, das schließt Teil eins von
 

1112
00:19:14,799 --> 00:19:16,870
, das schließt Teil eins von
Kapitel 13 ab, in dem

1113
00:19:16,870 --> 00:19:16,880
Kapitel 13 ab, in dem
 

1114
00:19:16,880 --> 00:19:19,029
Kapitel 13 ab, in dem
wir Closures behandelt

1115
00:19:19,029 --> 00:19:20,470
wir Closures behandelt
 

1116
00:19:20,470 --> 00:19:20,480

 

1117
00:19:20,480 --> 00:19:22,230

haben  die

1118
00:19:22,230 --> 00:19:22,240
haben  die
 

1119
00:19:22,240 --> 00:19:24,070
haben  die
möglichen Möglichkeiten zur Verwendung von Verschlüssen.

1120
00:19:24,070 --> 00:19:24,080
möglichen Möglichkeiten zur Verwendung von Verschlüssen.
 

1121
00:19:24,080 --> 00:19:25,909
möglichen Möglichkeiten zur Verwendung von Verschlüssen.
Wenn Sie also ein weiteres Video

1122
00:19:25,909 --> 00:19:25,919
Wenn Sie also ein weiteres Video
 

1123
00:19:25,919 --> 00:19:28,150
Wenn Sie also ein weiteres Video
über Verschlüsse mit weiteren Beispielen sehen möchten,

1124
00:19:28,150 --> 00:19:28,160
über Verschlüsse mit weiteren Beispielen sehen möchten,
 

1125
00:19:28,160 --> 00:19:30,470
über Verschlüsse mit weiteren Beispielen sehen möchten,
kommentieren Sie unten und wenn

1126
00:19:30,470 --> 00:19:30,480
kommentieren Sie unten und wenn
 

1127
00:19:30,480 --> 00:19:31,510
kommentieren Sie unten und wenn
Ihnen dieses

1128
00:19:31,510 --> 00:19:31,520
Ihnen dieses
 

1129
00:19:31,520 --> 00:19:33,350
Ihnen dieses
Video gefällt, geben Sie ihm natürlich im nächsten Video einen Daumen nach oben

1130
00:19:33,350 --> 00:19:34,630
Video gefällt, geben Sie ihm natürlich im nächsten Video einen Daumen nach oben
 

1131
00:19:34,630 --> 00:19:34,640

 

1132
00:19:34,640 --> 00:19:36,870

Wenn Sie also über Iteratoren benachrichtigt werden möchten, klicken Sie

1133
00:19:36,870 --> 00:19:37,990
Wenn Sie also über Iteratoren benachrichtigt werden möchten, klicken Sie
 

1134
00:19:37,990 --> 00:19:38,000

 

1135
00:19:38,000 --> 00:19:40,870

auf „Abonnieren“ und damit sehen

1136
00:19:40,870 --> 00:19:40,880
auf „Abonnieren“ und damit sehen
 

1137
00:19:40,880 --> 00:19:41,590
auf „Abonnieren“ und damit sehen
wir uns

1138
00:19:41,590 --> 00:19:41,600
wir uns
 

1139
00:19:41,600 --> 00:19:52,470
wir uns
im nächsten

1140
00:19:52,470 --> 00:19:52,480
im nächsten
 

1141
00:19:52,480 --> 00:19:54,559
im nächsten
Sie

