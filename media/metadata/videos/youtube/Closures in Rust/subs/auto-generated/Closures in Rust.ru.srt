1
00:00:00,560 --> 00:00:02,629

с возвращением, Russ Gang, если вы

2
00:00:02,629 --> 00:00:02,639
с возвращением, Russ Gang, если вы
 

3
00:00:02,639 --> 00:00:04,630
с возвращением, Russ Gang, если вы
здесь впервые, меня зовут Богдан, и этот

4
00:00:04,630 --> 00:00:04,640
здесь впервые, меня зовут Богдан, и этот
 

5
00:00:04,640 --> 00:00:05,829
здесь впервые, меня зовут Богдан, и этот
канал полностью посвящен

6
00:00:05,829 --> 00:00:05,839
канал полностью посвящен
 

7
00:00:05,839 --> 00:00:07,990
канал полностью посвящен
языку программирования ржавчины, в

8
00:00:07,990 --> 00:00:08,000
языку программирования ржавчины, в
 

9
00:00:08,000 --> 00:00:10,070
языку программирования ржавчины, в
последнем видео мы рассмотрели главу 12

10
00:00:10,070 --> 00:00:10,080
последнем видео мы рассмотрели главу 12
 

11
00:00:10,080 --> 00:00:11,350
последнем видео мы рассмотрели главу 12
книги по борьбе,

12
00:00:11,350 --> 00:00:11,360
книги по борьбе,
 

13
00:00:11,360 --> 00:00:14,390
книги по борьбе,
в которой мы создали программу cli,

14
00:00:14,390 --> 00:00:14,400
в которой мы создали программу cli,
 

15
00:00:14,400 --> 00:00:16,470
в которой мы создали программу cli,
в этом видео мы  переходя к главе

16
00:00:16,470 --> 00:00:16,480
в этом видео мы  переходя к главе
 

17
00:00:16,480 --> 00:00:17,830
в этом видео мы  переходя к главе
13, в частности к

18
00:00:17,830 --> 00:00:17,840
13, в частности к
 

19
00:00:17,840 --> 00:00:20,310
13, в частности к
части 1 главы 13, в которой мы поговорим

20
00:00:20,310 --> 00:00:20,320
части 1 главы 13, в которой мы поговорим
 

21
00:00:20,320 --> 00:00:21,109
части 1 главы 13, в которой мы поговорим
о

22
00:00:21,109 --> 00:00:21,119
о
 

23
00:00:21,119 --> 00:00:30,550
о
замыканиях, так что давайте

24
00:00:30,550 --> 00:00:30,560
замыканиях, так что давайте
 

25
00:00:30,560 --> 00:00:33,270
замыканиях, так что давайте
сначала разберемся, что такое замыкания, замыкания

26
00:00:33,270 --> 00:00:33,280
сначала разберемся, что такое замыкания, замыкания
 

27
00:00:33,280 --> 00:00:34,470
сначала разберемся, что такое замыкания, замыкания
похожи на функции,

28
00:00:34,470 --> 00:00:34,480
похожи на функции,
 

29
00:00:34,480 --> 00:00:36,150
похожи на функции,
за исключением того, что они анонимны, что означает,

30
00:00:36,150 --> 00:00:36,160
за исключением того, что они анонимны, что означает,
 

31
00:00:36,160 --> 00:00:37,830
за исключением того, что они анонимны, что означает,
что у них нет имен, которые

32
00:00:37,830 --> 00:00:37,840
что у них нет имен, которые
 

33
00:00:37,840 --> 00:00:40,150
что у них нет имен, которые
они могли бы  храниться как переменные и

34
00:00:40,150 --> 00:00:40,160
они могли бы  храниться как переменные и
 

35
00:00:40,160 --> 00:00:41,030
они могли бы  храниться как переменные и
передаваться по кругу,

36
00:00:41,030 --> 00:00:41,040
передаваться по кругу,
 

37
00:00:41,040 --> 00:00:43,270
передаваться по кругу,
их можно даже передавать в качестве входных

38
00:00:43,270 --> 00:00:43,280
их можно даже передавать в качестве входных
 

39
00:00:43,280 --> 00:00:44,150
их можно даже передавать в качестве входных

40
00:00:44,150 --> 00:00:44,160

 

41
00:00:44,160 --> 00:00:46,549

параметров функции, и они фиксируют

42
00:00:46,549 --> 00:00:46,559
параметров функции, и они фиксируют
 

43
00:00:46,559 --> 00:00:47,590
параметров функции, и они фиксируют
переменные

44
00:00:47,590 --> 00:00:47,600
переменные
 

45
00:00:47,600 --> 00:00:50,150
переменные
внутри области, в которой они

46
00:00:50,150 --> 00:00:50,160
внутри области, в которой они
 

47
00:00:50,160 --> 00:00:50,950
внутри области, в которой они
определены

48
00:00:50,950 --> 00:00:50,960
определены
 

49
00:00:50,960 --> 00:00:53,029
определены
, чтобы лучше понять замыкания, которые

50
00:00:53,029 --> 00:00:53,039
, чтобы лучше понять замыкания, которые
 

51
00:00:53,039 --> 00:00:54,389
, чтобы лучше понять замыкания, которые
мы будем использовать в следующем

52
00:00:54,389 --> 00:00:54,399
мы будем использовать в следующем
 

53
00:00:54,399 --> 00:00:56,470
мы будем использовать в следующем
примере, представьте, что вы'  повторное создание серверной

54
00:00:56,470 --> 00:00:56,480
примере, представьте, что вы'  повторное создание серверной
 

55
00:00:56,480 --> 00:00:58,389
примере, представьте, что вы'  повторное создание серверной
части для фитнес-приложения,

56
00:00:58,389 --> 00:00:58,399
части для фитнес-приложения,
 

57
00:00:58,399 --> 00:01:00,950
части для фитнес-приложения,
а серверная часть встроена в ржавчину,

58
00:01:00,950 --> 00:01:00,960
а серверная часть встроена в ржавчину,
 

59
00:01:00,960 --> 00:01:02,790
а серверная часть встроена в ржавчину,
фитнес-приложение будет генерировать индивидуальные

60
00:01:02,790 --> 00:01:02,800
фитнес-приложение будет генерировать индивидуальные
 

61
00:01:02,800 --> 00:01:04,390
фитнес-приложение будет генерировать индивидуальные
тренировки для пользователя

62
00:01:04,390 --> 00:01:04,400
тренировки для пользователя
 

63
00:01:04,400 --> 00:01:07,109
тренировки для пользователя
на основе различных факторов, таких как их возраст,

64
00:01:07,109 --> 00:01:07,910
на основе различных факторов, таких как их возраст,
 

65
00:01:07,910 --> 00:01:07,920

 

66
00:01:07,920 --> 00:01:11,190

индекс массы тела, предпочитаемые тренировки.  уровень интенсивности и интенсивности

67
00:01:11,190 --> 00:01:11,200
индекс массы тела, предпочитаемые тренировки.  уровень интенсивности и интенсивности
 

68
00:01:11,200 --> 00:01:12,149
индекс массы тела, предпочитаемые тренировки.  уровень интенсивности и интенсивности

69
00:01:12,149 --> 00:01:12,159

 

70
00:01:12,159 --> 00:01:14,310

теперь реализация этого алгоритма

71
00:01:14,310 --> 00:01:14,320
теперь реализация этого алгоритма
 

72
00:01:14,320 --> 00:01:15,670
теперь реализация этого алгоритма
не имеет большого значения,

73
00:01:15,670 --> 00:01:15,680
не имеет большого значения,
 

74
00:01:15,680 --> 00:01:17,270
не имеет большого значения,
важно то, что часть этого

75
00:01:17,270 --> 00:01:17,280
важно то, что часть этого
 

76
00:01:17,280 --> 00:01:19,510
важно то, что часть этого
алгоритма выполняет расчет

77
00:01:19,510 --> 00:01:19,520
алгоритма выполняет расчет
 

78
00:01:19,520 --> 00:01:21,590
алгоритма выполняет расчет
, который требует больших затрат и занимает несколько

79
00:01:21,590 --> 00:01:21,600
, который требует больших затрат и занимает несколько
 

80
00:01:21,600 --> 00:01:23,109
, который требует больших затрат и занимает несколько
секунд.

81
00:01:23,109 --> 00:01:25,510
секунд.
 

82
00:01:25,510 --> 00:01:26,630

 

83
00:01:26,630 --> 00:01:26,640

 

84
00:01:26,640 --> 00:01:29,749

вычисление, которое

85
00:01:29,749 --> 00:01:30,310
вычисление, которое
 

86
00:01:30,310 --> 00:01:30,320

 

87
00:01:30,320 --> 00:01:32,630

принимает интенсивность, а затем распечатывает

88
00:01:32,630 --> 00:01:32,640
принимает интенсивность, а затем распечатывает
 

89
00:01:32,640 --> 00:01:34,390
принимает интенсивность, а затем распечатывает
вычисление медленно,

90
00:01:34,390 --> 00:01:34,400
вычисление медленно,
 

91
00:01:34,400 --> 00:01:36,710
вычисление медленно,
позволяет потоку засыпать в течение двух секунд

92
00:01:36,710 --> 00:01:36,720
позволяет потоку засыпать в течение двух секунд
 

93
00:01:36,720 --> 00:01:38,950
позволяет потоку засыпать в течение двух секунд
и возвращает интенсивность,

94
00:01:38,950 --> 00:01:38,960
и возвращает интенсивность,
 

95
00:01:38,960 --> 00:01:41,030
и возвращает интенсивность,
теперь здесь, в maine, мы моделируем

96
00:01:41,030 --> 00:01:41,040
теперь здесь, в maine, мы моделируем
 

97
00:01:41,040 --> 00:01:42,230
теперь здесь, в maine, мы моделируем
код, который будет вызываться,

98
00:01:42,230 --> 00:01:42,240
код, который будет вызываться,
 

99
00:01:42,240 --> 00:01:44,870
код, который будет вызываться,
если пользователь захочет новую тренировку, которую мы

100
00:01:44,870 --> 00:01:44,880
если пользователь захочет новую тренировку, которую мы
 

101
00:01:44,880 --> 00:01:46,710
если пользователь захочет новую тренировку, которую мы
вызываем, сгенерировать тренировку  это

102
00:01:46,710 --> 00:01:46,720
вызываем, сгенерировать тренировку  это
 

103
00:01:46,720 --> 00:01:48,630
вызываем, сгенерировать тренировку  это
функция, которую мы еще не создали,

104
00:01:48,630 --> 00:01:48,640
функция, которую мы еще не создали,
 

105
00:01:48,640 --> 00:01:50,310
функция, которую мы еще не создали,
и генератор тренировки принимает два

106
00:01:50,310 --> 00:01:50,320
и генератор тренировки принимает два
 

107
00:01:50,320 --> 00:01:52,710
и генератор тренировки принимает два
параметра: интенсивность, указанную пользователем,

108
00:01:52,710 --> 00:01:52,720
параметра: интенсивность, указанную пользователем,
 

109
00:01:52,720 --> 00:01:53,670
параметра: интенсивность, указанную пользователем,

110
00:01:53,670 --> 00:01:53,680

 

111
00:01:53,680 --> 00:01:55,830

и случайное число, чтобы внести некоторое

112
00:01:55,830 --> 00:01:55,840
и случайное число, чтобы внести некоторое
 

113
00:01:55,840 --> 00:01:58,149
и случайное число, чтобы внести некоторое
разнообразие в сгенерированную тренировку

114
00:01:58,149 --> 00:01:58,159
разнообразие в сгенерированную тренировку
 

115
00:01:58,159 --> 00:01:59,990
разнообразие в сгенерированную тренировку
сейчас, потому что мы на самом деле не

116
00:01:59,990 --> 00:02:00,000
сейчас, потому что мы на самом деле не
 

117
00:02:00,000 --> 00:02:01,830
сейчас, потому что мы на самом деле не
создаем интерфейс в этом примере,

118
00:02:01,830 --> 00:02:01,840
создаем интерфейс в этом примере,
 

119
00:02:01,840 --> 00:02:04,469
создаем интерфейс в этом примере,
мы'  Мы будем проходить с имитируемой интенсивностью

120
00:02:04,469 --> 00:02:04,479
мы'  Мы будем проходить с имитируемой интенсивностью
 

121
00:02:04,479 --> 00:02:05,030
мы'  Мы будем проходить с имитируемой интенсивностью
10,

122
00:02:05,030 --> 00:02:05,040
10,
 

123
00:02:05,040 --> 00:02:07,109
10,
и для случайного числа мы могли бы

124
00:02:07,109 --> 00:02:07,119
и для случайного числа мы могли бы
 

125
00:02:07,119 --> 00:02:08,949
и для случайного числа мы могли бы
использовать ящик с рандом и фактически сгенерировать

126
00:02:08,949 --> 00:02:08,959
использовать ящик с рандом и фактически сгенерировать
 

127
00:02:08,959 --> 00:02:09,749
использовать ящик с рандом и фактически сгенерировать
случайное число,

128
00:02:09,749 --> 00:02:09,759
случайное число,
 

129
00:02:09,759 --> 00:02:11,510
случайное число,
но опять же, это не так.  В этом примере мы сосредоточимся на этом,

130
00:02:11,510 --> 00:02:11,520
но опять же, это не так.  В этом примере мы сосредоточимся на этом,
 

131
00:02:11,520 --> 00:02:13,589
но опять же, это не так.  В этом примере мы сосредоточимся на этом,
поэтому мы просто установим случайное

132
00:02:13,589 --> 00:02:13,599
поэтому мы просто установим случайное
 

133
00:02:13,599 --> 00:02:15,350
поэтому мы просто установим случайное
число на жестко запрограммированное число

134
00:02:15,350 --> 00:02:15,360
число на жестко запрограммированное число
 

135
00:02:15,360 --> 00:02:17,670
число на жестко запрограммированное число
семь, затем мы определим сгенерированную

136
00:02:17,670 --> 00:02:17,680
семь, затем мы определим сгенерированную
 

137
00:02:17,680 --> 00:02:18,869
семь, затем мы определим сгенерированную
функцию тренировки

138
00:02:18,869 --> 00:02:18,879
функцию тренировки
 

139
00:02:18,879 --> 00:02:21,990
функцию тренировки
прямо под основной

140
00:02:21,990 --> 00:02:22,000
прямо под основной
 

141
00:02:22,000 --> 00:02:23,990
прямо под основной
функцией генерации тренировки, которая принимает

142
00:02:23,990 --> 00:02:24,000
функцией генерации тренировки, которая принимает
 

143
00:02:24,000 --> 00:02:25,910
функцией генерации тренировки, которая принимает
интенсивность и случайное число,

144
00:02:25,910 --> 00:02:25,920
интенсивность и случайное число,
 

145
00:02:25,920 --> 00:02:28,630
интенсивность и случайное число,
если интенсивность меньше 25.  мы

146
00:02:28,630 --> 00:02:28,640
если интенсивность меньше 25.  мы
 

147
00:02:28,640 --> 00:02:30,710
если интенсивность меньше 25.  мы
распечатываем количество

148
00:02:30,710 --> 00:02:30,720
распечатываем количество
 

149
00:02:30,720 --> 00:02:33,030
распечатываем количество
отжиманий do x и количество приседаний do x, чтобы выяснить,

150
00:02:33,030 --> 00:02:33,040
отжиманий do x и количество приседаний do x, чтобы выяснить,
 

151
00:02:33,040 --> 00:02:34,949
отжиманий do x и количество приседаний do x, чтобы выяснить,
сколько отжиманий и подходов нужно сделать,

152
00:02:34,949 --> 00:02:34,959
сколько отжиманий и подходов нужно сделать,
 

153
00:02:34,959 --> 00:02:37,990
сколько отжиманий и подходов нужно сделать,
мы вызываем наш дорогостоящий расчет, если

154
00:02:37,990 --> 00:02:38,000
мы вызываем наш дорогостоящий расчет, если
 

155
00:02:38,000 --> 00:02:39,910
мы вызываем наш дорогостоящий расчет, если
интенсивность превышает 25,

156
00:02:39,910 --> 00:02:39,920
интенсивность превышает 25,
 

157
00:02:39,920 --> 00:02:42,710
интенсивность превышает 25,
тогда мы переходим в предложение else здесь мы

158
00:02:42,710 --> 00:02:42,720
тогда мы переходим в предложение else здесь мы
 

159
00:02:42,720 --> 00:02:43,030
тогда мы переходим в предложение else здесь мы
проверьте

160
00:02:43,030 --> 00:02:43,040
проверьте
 

161
00:02:43,040 --> 00:02:45,750
проверьте
наше случайное число, если это ровно три,

162
00:02:45,750 --> 00:02:45,760
наше случайное число, если это ровно три,
 

163
00:02:45,760 --> 00:02:47,509
наше случайное число, если это ровно три,
мы распечатываем, делаем перерыв, в

164
00:02:47,509 --> 00:02:47,519
мы распечатываем, делаем перерыв, в
 

165
00:02:47,519 --> 00:02:49,910
мы распечатываем, делаем перерыв, в
противном случае мы используем местоимение, выполняемое x количество

166
00:02:49,910 --> 00:02:49,920
противном случае мы используем местоимение, выполняемое x количество
 

167
00:02:49,920 --> 00:02:51,670
противном случае мы используем местоимение, выполняемое x количество
минут, и снова, чтобы вычислить

168
00:02:51,670 --> 00:02:51,680
минут, и снова, чтобы вычислить
 

169
00:02:51,680 --> 00:02:53,110
минут, и снова, чтобы вычислить
количество минут для запуска,

170
00:02:53,110 --> 00:02:53,120
количество минут для запуска,
 

171
00:02:53,120 --> 00:02:55,350
количество минут для запуска,
мы используем нашу дорогостоящую функцию расчета,

172
00:02:55,350 --> 00:02:55,360
мы используем нашу дорогостоящую функцию расчета,
 

173
00:02:55,360 --> 00:02:56,150
мы используем нашу дорогостоящую функцию расчета,

174
00:02:56,150 --> 00:02:56,160

 

175
00:02:56,160 --> 00:02:57,910

теперь это работает, но для этого может

176
00:02:57,910 --> 00:02:57,920
теперь это работает, но для этого может
 

177
00:02:57,920 --> 00:02:59,750
теперь это работает, но для этого может
потребоваться некоторый рефакторинг, одна проблема  что мы

178
00:02:59,750 --> 00:02:59,760
потребоваться некоторый рефакторинг, одна проблема  что мы
 

179
00:02:59,760 --> 00:03:01,350
потребоваться некоторый рефакторинг, одна проблема  что мы
вызываем нашу дорогую функцию

180
00:03:01,350 --> 00:03:01,360
вызываем нашу дорогую функцию
 

181
00:03:01,360 --> 00:03:03,910
вызываем нашу дорогую функцию
в нескольких местах, поэтому, если мы

182
00:03:03,910 --> 00:03:03,920
в нескольких местах, поэтому, если мы
 

183
00:03:03,920 --> 00:03:05,350
в нескольких местах, поэтому, если мы
изменим способ вызова функции,

184
00:03:05,350 --> 00:03:05,360
изменим способ вызова функции,
 

185
00:03:05,360 --> 00:03:07,910
изменим способ вызова функции,
например, если мы добавим еще один параметр,

186
00:03:07,910 --> 00:03:07,920
например, если мы добавим еще один параметр,
 

187
00:03:07,920 --> 00:03:09,110
например, если мы добавим еще один параметр,
тогда нам придется изменить

188
00:03:09,110 --> 00:03:09,120
тогда нам придется изменить
 

189
00:03:09,120 --> 00:03:11,589
тогда нам придется изменить
все сайты вызова, также мы вызываем наши

190
00:03:11,589 --> 00:03:11,599
все сайты вызова, также мы вызываем наши
 

191
00:03:11,599 --> 00:03:12,710
все сайты вызова, также мы вызываем наши
дорогие функции

192
00:03:12,710 --> 00:03:12,720
дорогие функции
 

193
00:03:12,720 --> 00:03:15,589
дорогие функции
несколько раз без необходимости, например,

194
00:03:15,589 --> 00:03:15,599
несколько раз без необходимости, например,
 

195
00:03:15,599 --> 00:03:16,710
несколько раз без необходимости, например,
в этом блоке if

196
00:03:16,710 --> 00:03:16,720
в этом блоке if
 

197
00:03:16,720 --> 00:03:18,790
в этом блоке if
мы вызываем нашу дорогую функцию дважды,

198
00:03:18,790 --> 00:03:18,800
мы вызываем нашу дорогую функцию дважды,
 

199
00:03:18,800 --> 00:03:21,030
мы вызываем нашу дорогую функцию дважды,
когда нам действительно нужно вызвать ее только один раз,

200
00:03:21,030 --> 00:03:21,040
когда нам действительно нужно вызвать ее только один раз,
 

201
00:03:21,040 --> 00:03:23,190
когда нам действительно нужно вызвать ее только один раз,
а затем передать возвращаемое значение обоим

202
00:03:23,190 --> 00:03:23,200
а затем передать возвращаемое значение обоим
 

203
00:03:23,200 --> 00:03:24,789
а затем передать возвращаемое значение обоим
этим операторам печати,

204
00:03:24,789 --> 00:03:24,799
этим операторам печати,
 

205
00:03:24,799 --> 00:03:26,630
этим операторам печати,
теперь это может быть хорошо для обычных

206
00:03:26,630 --> 00:03:26,640
теперь это может быть хорошо для обычных
 

207
00:03:26,640 --> 00:03:28,470
теперь это может быть хорошо для обычных
функций, но помните, что это

208
00:03:28,470 --> 00:03:28,480
функций, но помните, что это
 

209
00:03:28,480 --> 00:03:30,229
функций, но помните, что это
дорого  функция, выполнение которой занимает две

210
00:03:30,229 --> 00:03:30,239
дорого  функция, выполнение которой занимает две
 

211
00:03:30,239 --> 00:03:32,550
дорого  функция, выполнение которой занимает две
секунды, поэтому мы хотим максимально ограничить

212
00:03:32,550 --> 00:03:32,560
секунды, поэтому мы хотим максимально ограничить
 

213
00:03:32,560 --> 00:03:34,470
секунды, поэтому мы хотим максимально ограничить
количество вызовов этой функции,

214
00:03:34,470 --> 00:03:34,480
количество вызовов этой функции,
 

215
00:03:34,480 --> 00:03:37,110
количество вызовов этой функции,
давайте исправим эти две

216
00:03:37,110 --> 00:03:37,120
давайте исправим эти две
 

217
00:03:37,120 --> 00:03:37,750
давайте исправим эти две
проблемы

218
00:03:37,750 --> 00:03:37,760
проблемы
 

219
00:03:37,760 --> 00:03:39,670
проблемы
, сохранив результат вызова нашей дорогостоящей

220
00:03:39,670 --> 00:03:39,680
, сохранив результат вызова нашей дорогостоящей
 

221
00:03:39,680 --> 00:03:41,830
, сохранив результат вызова нашей дорогостоящей
функции внутри переменной,

222
00:03:41,830 --> 00:03:41,840
функции внутри переменной,
 

223
00:03:41,840 --> 00:03:43,270
функции внутри переменной,
поэтому мы создадим новую переменную в  В

224
00:03:43,270 --> 00:03:43,280
поэтому мы создадим новую переменную в  В
 

225
00:03:43,280 --> 00:03:44,869
поэтому мы создадим новую переменную в  В
верхней части нашей функции

226
00:03:44,869 --> 00:03:44,879
верхней части нашей функции
 

227
00:03:44,879 --> 00:03:50,470
верхней части нашей функции
мы назовем это дорогим результатом

228
00:03:50,470 --> 00:03:50,480

 

229
00:03:50,480 --> 00:03:52,789

и установим его равным вызову нашей дорогой

230
00:03:52,789 --> 00:03:52,799
и установим его равным вызову нашей дорогой
 

231
00:03:52,799 --> 00:03:56,710
и установим его равным вызову нашей дорогой
функции,

232
00:03:56,710 --> 00:03:56,720

 

233
00:03:56,720 --> 00:03:58,550

затем мы будем использовать нашу переменную во всех наших

234
00:03:58,550 --> 00:03:58,560
затем мы будем использовать нашу переменную во всех наших
 

235
00:03:58,560 --> 00:04:07,509
затем мы будем использовать нашу переменную во всех наших
операторах строки печати,

236
00:04:07,509 --> 00:04:07,519

 

237
00:04:07,519 --> 00:04:09,509

теперь это решает нашу проблему дублирования,

238
00:04:09,509 --> 00:04:09,519
теперь это решает нашу проблему дублирования,
 

239
00:04:09,519 --> 00:04:11,670
теперь это решает нашу проблему дублирования,
но теперь у нас есть еще один  проблема,

240
00:04:11,670 --> 00:04:11,680
но теперь у нас есть еще один  проблема,
 

241
00:04:11,680 --> 00:04:13,910
но теперь у нас есть еще один  проблема,
мы вызываем нашу дорогую функцию в

242
00:04:13,910 --> 00:04:13,920
мы вызываем нашу дорогую функцию в
 

243
00:04:13,920 --> 00:04:15,429
мы вызываем нашу дорогую функцию в
каждом отдельном случае

244
00:04:15,429 --> 00:04:15,439
каждом отдельном случае
 

245
00:04:15,439 --> 00:04:17,509
каждом отдельном случае
здесь вверху, независимо от того, что

246
00:04:17,509 --> 00:04:17,519
здесь вверху, независимо от того, что
 

247
00:04:17,519 --> 00:04:18,629
здесь вверху, независимо от того, что
выполняется ниже,

248
00:04:18,629 --> 00:04:18,639
выполняется ниже,
 

249
00:04:18,639 --> 00:04:20,310
выполняется ниже,
мы собираемся вызвать нашу дорогую

250
00:04:20,310 --> 00:04:20,320
мы собираемся вызвать нашу дорогую
 

251
00:04:20,320 --> 00:04:22,870
мы собираемся вызвать нашу дорогую
функцию, но здесь вы можете видеть, что

252
00:04:22,870 --> 00:04:22,880
функцию, но здесь вы можете видеть, что
 

253
00:04:22,880 --> 00:04:24,390
функцию, но здесь вы можете видеть, что
если случайный  число равно 3,

254
00:04:24,390 --> 00:04:24,400
если случайный  число равно 3,
 

255
00:04:24,400 --> 00:04:26,070
если случайный  число равно 3,
нам не нужна наша дорогая функция,

256
00:04:26,070 --> 00:04:26,080
нам не нужна наша дорогая функция,
 

257
00:04:26,080 --> 00:04:27,430
нам не нужна наша дорогая функция,
потому что мы просто

258
00:04:27,430 --> 00:04:27,440
потому что мы просто
 

259
00:04:27,440 --> 00:04:30,310
потому что мы просто
распечатываем этот текст, мы хотим

260
00:04:30,310 --> 00:04:30,320
распечатываем этот текст, мы хотим
 

261
00:04:30,320 --> 00:04:32,310
распечатываем этот текст, мы хотим
определить наш код в одном месте,

262
00:04:32,310 --> 00:04:32,320
определить наш код в одном месте,
 

263
00:04:32,320 --> 00:04:35,270
определить наш код в одном месте,
но выполнять его только при необходимости, поэтому

264
00:04:35,270 --> 00:04:35,280
но выполнять его только при необходимости, поэтому
 

265
00:04:35,280 --> 00:04:37,189
но выполнять его только при необходимости, поэтому
давайте попробуем рефакторинг этого

266
00:04:37,189 --> 00:04:37,199
давайте попробуем рефакторинг этого
 

267
00:04:37,199 --> 00:04:39,749
давайте попробуем рефакторинг этого
с помощью замыканий, давайте прокрутим

268
00:04:39,749 --> 00:04:39,759
с помощью замыканий, давайте прокрутим
 

269
00:04:39,759 --> 00:04:41,030
с помощью замыканий, давайте прокрутим
обратно вверх  нашей программы,

270
00:04:41,030 --> 00:04:41,040
обратно вверх  нашей программы,
 

271
00:04:41,040 --> 00:04:43,270
обратно вверх  нашей программы,
и вместо определения этой дорогостоящей

272
00:04:43,270 --> 00:04:43,280
и вместо определения этой дорогостоящей
 

273
00:04:43,280 --> 00:04:44,550
и вместо определения этой дорогостоящей
переменной результата

274
00:04:44,550 --> 00:04:44,560
переменной результата
 

275
00:04:44,560 --> 00:04:48,150
переменной результата
мы определим замыкание

276
00:04:48,150 --> 00:04:48,160

 

277
00:04:48,160 --> 00:04:50,310

здесь, у нас есть переменная, называемая дорогостоящим

278
00:04:50,310 --> 00:04:50,320
здесь, у нас есть переменная, называемая дорогостоящим
 

279
00:04:50,320 --> 00:04:52,550
здесь, у нас есть переменная, называемая дорогостоящим
замыканием, которая равна

280
00:04:52,550 --> 00:04:52,560
замыканием, которая равна
 

281
00:04:52,560 --> 00:04:55,030
замыканием, которая равна
нашему замыканию, теперь помните, что замыкания - это

282
00:04:55,030 --> 00:04:55,040
нашему замыканию, теперь помните, что замыкания - это
 

283
00:04:55,040 --> 00:04:56,469
нашему замыканию, теперь помните, что замыкания - это
анонимные функции,

284
00:04:56,469 --> 00:04:56,479
анонимные функции,
 

285
00:04:56,479 --> 00:04:58,390
анонимные функции,
и разница между замыканием

286
00:04:58,390 --> 00:04:58,400
и разница между замыканием
 

287
00:04:58,400 --> 00:05:00,230
и разница между замыканием
и функцией или, по крайней мере,  Основное визуальное

288
00:05:00,230 --> 00:05:00,240
и функцией или, по крайней мере,  Основное визуальное
 

289
00:05:00,240 --> 00:05:00,870
и функцией или, по крайней мере,  Основное визуальное
отличие

290
00:05:00,870 --> 00:05:00,880
отличие
 

291
00:05:00,880 --> 00:05:03,029
отличие
состоит в том, что входные параметры находятся не

292
00:05:03,029 --> 00:05:03,039
состоит в том, что входные параметры находятся не
 

293
00:05:03,039 --> 00:05:04,629
состоит в том, что входные параметры находятся не
в круглых скобках,

294
00:05:04,629 --> 00:05:04,639
в круглых скобках,
 

295
00:05:04,639 --> 00:05:06,790
в круглых скобках,
а внутри этих вертикальных труб,

296
00:05:06,790 --> 00:05:06,800
а внутри этих вертикальных труб,
 

297
00:05:06,800 --> 00:05:07,749
а внутри этих вертикальных труб,
поэтому здесь у нас есть один

298
00:05:07,749 --> 00:05:07,759
поэтому здесь у нас есть один
 

299
00:05:07,759 --> 00:05:10,230
поэтому здесь у нас есть один
входной параметр, который равен num, за которым следуют

300
00:05:10,230 --> 00:05:10,240
входной параметр, который равен num, за которым следуют
 

301
00:05:10,240 --> 00:05:10,950
входной параметр, который равен num, за которым следуют
скобки,

302
00:05:10,950 --> 00:05:10,960
скобки,
 

303
00:05:10,960 --> 00:05:13,590
скобки,
которые содержат тело нашего замыкания, и

304
00:05:13,590 --> 00:05:13,600
которые содержат тело нашего замыкания, и
 

305
00:05:13,600 --> 00:05:14,790
которые содержат тело нашего замыкания, и
если наше замыкание было только

306
00:05:14,790 --> 00:05:14,800
если наше замыкание было только
 

307
00:05:14,800 --> 00:05:16,629
если наше замыкание было только
одной строкой, то  нам даже не нужны

308
00:05:16,629 --> 00:05:16,639
одной строкой, то  нам даже не нужны
 

309
00:05:16,639 --> 00:05:19,189
одной строкой, то  нам даже не нужны
скобки, поэтому внутри нашего тела замыкания

310
00:05:19,189 --> 00:05:19,199
скобки, поэтому внутри нашего тела замыкания
 

311
00:05:19,199 --> 00:05:21,909
скобки, поэтому внутри нашего тела замыкания
мы выполняем наши дорогостоящие вычисления, а

312
00:05:21,909 --> 00:05:21,919
мы выполняем наши дорогостоящие вычисления, а
 

313
00:05:21,919 --> 00:05:22,629
мы выполняем наши дорогостоящие вычисления, а
затем мы

314
00:05:22,629 --> 00:05:22,639
затем мы
 

315
00:05:22,639 --> 00:05:25,990
затем мы
возвращаем num, наконец, в конце нам нужен

316
00:05:25,990 --> 00:05:26,000
возвращаем num, наконец, в конце нам нужен
 

317
00:05:26,000 --> 00:05:28,790
возвращаем num, наконец, в конце нам нужен
этот полуко  lon здесь, чтобы закончить

318
00:05:28,790 --> 00:05:28,800
этот полуко  lon здесь, чтобы закончить
 

319
00:05:28,800 --> 00:05:29,830
этот полуко  lon здесь, чтобы закончить
оператор let

320
00:05:29,830 --> 00:05:29,840
оператор let
 

321
00:05:29,840 --> 00:05:31,830
оператор let
обратите внимание, что наша дорогая переменная закрытия

322
00:05:31,830 --> 00:05:31,840
обратите внимание, что наша дорогая переменная закрытия
 

323
00:05:31,840 --> 00:05:34,070
обратите внимание, что наша дорогая переменная закрытия
не хранит возвращаемое значение нашего

324
00:05:34,070 --> 00:05:34,080
не хранит возвращаемое значение нашего
 

325
00:05:34,080 --> 00:05:34,870
не хранит возвращаемое значение нашего
закрытия,

326
00:05:34,870 --> 00:05:34,880
закрытия,
 

327
00:05:34,880 --> 00:05:37,189
закрытия,
а хранит само закрытие

328
00:05:37,189 --> 00:05:37,199
а хранит само закрытие
 

329
00:05:37,199 --> 00:05:39,590
а хранит само закрытие
также обратите внимание, что тело нашего

330
00:05:39,590 --> 00:05:39,600
также обратите внимание, что тело нашего
 

331
00:05:39,600 --> 00:05:41,990
также обратите внимание, что тело нашего
закрытия идентично телу нашей

332
00:05:41,990 --> 00:05:42,000
закрытия идентично телу нашей
 

333
00:05:42,000 --> 00:05:43,670
закрытия идентично телу нашей
дорогой функции,

334
00:05:43,670 --> 00:05:43,680
дорогой функции,
 

335
00:05:43,680 --> 00:05:46,230
дорогой функции,
определенной здесь сейчас  что наше закрытие определено,

336
00:05:46,230 --> 00:05:46,240
определенной здесь сейчас  что наше закрытие определено,
 

337
00:05:46,240 --> 00:05:47,670
определенной здесь сейчас  что наше закрытие определено,
мы можем вызвать его внутри

338
00:05:47,670 --> 00:05:47,680
мы можем вызвать его внутри
 

339
00:05:47,680 --> 00:05:54,550
мы можем вызвать его внутри
наших операторов строки печати,

340
00:05:54,550 --> 00:05:54,560

 

341
00:05:54,560 --> 00:05:56,230

поскольку вы можете видеть, что синтаксис для вызова

342
00:05:56,230 --> 00:05:56,240
поскольку вы можете видеть, что синтаксис для вызова
 

343
00:05:56,240 --> 00:05:58,629
поскольку вы можете видеть, что синтаксис для вызова
нашего закрытия аналогичен синтаксису для

344
00:05:58,629 --> 00:05:58,639
нашего закрытия аналогичен синтаксису для
 

345
00:05:58,639 --> 00:06:00,150
нашего закрытия аналогичен синтаксису для
вызова функции,

346
00:06:00,150 --> 00:06:00,160
вызова функции,
 

347
00:06:00,160 --> 00:06:02,469
вызова функции,
мы указываем имя нашей переменной, которая содержит

348
00:06:02,469 --> 00:06:02,479
мы указываем имя нашей переменной, которая содержит
 

349
00:06:02,479 --> 00:06:03,430
мы указываем имя нашей переменной, которая содержит
наше закрытие,

350
00:06:03,430 --> 00:06:03,440
наше закрытие,
 

351
00:06:03,440 --> 00:06:06,150
наше закрытие,
за которым следуют круглые скобки, а затем передаем

352
00:06:06,150 --> 00:06:06,160
за которым следуют круглые скобки, а затем передаем
 

353
00:06:06,160 --> 00:06:07,590
за которым следуют круглые скобки, а затем передаем
в  входные параметры

354
00:06:07,590 --> 00:06:07,600
в  входные параметры
 

355
00:06:07,600 --> 00:06:09,590
в  входные параметры
теперь наша логика определена в одном месте,

356
00:06:09,590 --> 00:06:09,600
теперь наша логика определена в одном месте,
 

357
00:06:09,600 --> 00:06:11,189
теперь наша логика определена в одном месте,
и мы вызываем нашу дорогостоящую

358
00:06:11,189 --> 00:06:11,199
и мы вызываем нашу дорогостоящую
 

359
00:06:11,199 --> 00:06:12,150
и мы вызываем нашу дорогостоящую
операцию только

360
00:06:12,150 --> 00:06:12,160
операцию только
 

361
00:06:12,160 --> 00:06:14,550
операцию только
тогда, когда это необходимо, но мы вернулись к старой

362
00:06:14,550 --> 00:06:14,560
тогда, когда это необходимо, но мы вернулись к старой
 

363
00:06:14,560 --> 00:06:15,749
тогда, когда это необходимо, но мы вернулись к старой
проблеме, которая заключается в том, что

364
00:06:15,749 --> 00:06:15,759
проблеме, которая заключается в том, что
 

365
00:06:15,759 --> 00:06:17,670
проблеме, которая заключается в том, что
в этом блоке if мы вызываем нашу

366
00:06:17,670 --> 00:06:17,680
в этом блоке if мы вызываем нашу
 

367
00:06:17,680 --> 00:06:19,110
в этом блоке if мы вызываем нашу
дорогостоящую операцию

368
00:06:19,110 --> 00:06:19,120
дорогостоящую операцию
 

369
00:06:19,120 --> 00:06:21,830
дорогостоящую операцию
дважды, что не очень хорошо.  теперь мы могли бы решить

370
00:06:21,830 --> 00:06:21,840
дважды, что не очень хорошо.  теперь мы могли бы решить
 

371
00:06:21,840 --> 00:06:23,590
дважды, что не очень хорошо.  теперь мы могли бы решить
эту проблему, сохранив результат

372
00:06:23,590 --> 00:06:23,600
эту проблему, сохранив результат
 

373
00:06:23,600 --> 00:06:25,189
эту проблему, сохранив результат
нашего дорогостоящего вызова закрытия

374
00:06:25,189 --> 00:06:25,199
нашего дорогостоящего вызова закрытия
 

375
00:06:25,199 --> 00:06:27,350
нашего дорогостоящего вызова закрытия
в верхней части этого оператора if, но

376
00:06:27,350 --> 00:06:27,360
в верхней части этого оператора if, но
 

377
00:06:27,360 --> 00:06:28,710
в верхней части этого оператора if, но
есть и другой способ решить эту

378
00:06:28,710 --> 00:06:28,720
есть и другой способ решить эту
 

379
00:06:28,720 --> 00:06:29,270
есть и другой способ решить эту
проблему,

380
00:06:29,270 --> 00:06:29,280
проблему,
 

381
00:06:29,280 --> 00:06:31,670
проблему,
который мы  поговорим немного,

382
00:06:31,670 --> 00:06:31,680
который мы  поговорим немного,
 

383
00:06:31,680 --> 00:06:33,430
который мы  поговорим немного,
прежде чем мы решим эту проблему,

384
00:06:33,430 --> 00:06:33,440
прежде чем мы решим эту проблему,
 

385
00:06:33,440 --> 00:06:34,870
прежде чем мы решим эту проблему,
вы, возможно, заметили, что нам не

386
00:06:34,870 --> 00:06:34,880
вы, возможно, заметили, что нам не
 

387
00:06:34,880 --> 00:06:36,629
вы, возможно, заметили, что нам не
нужно аннотировать тип входного параметра нашего

388
00:06:36,629 --> 00:06:36,639
нужно аннотировать тип входного параметра нашего
 

389
00:06:36,639 --> 00:06:37,270
нужно аннотировать тип входного параметра нашего
замыкания,

390
00:06:37,270 --> 00:06:37,280
замыкания,
 

391
00:06:37,280 --> 00:06:39,350
замыкания,
а также нам не нужно

392
00:06:39,350 --> 00:06:39,360
а также нам не нужно
 

393
00:06:39,360 --> 00:06:40,710
а также нам не нужно
аннотировать

394
00:06:40,710 --> 00:06:40,720
аннотировать
 

395
00:06:40,720 --> 00:06:42,950
аннотировать
возвращаемое значение нашего замыкания для обычных функций, мы

396
00:06:42,950 --> 00:06:42,960
возвращаемое значение нашего замыкания для обычных функций, мы
 

397
00:06:42,960 --> 00:06:44,790
возвращаемое значение нашего замыкания для обычных функций, мы
должны были бы указать тип  наших

398
00:06:44,790 --> 00:06:44,800
должны были бы указать тип  наших
 

399
00:06:44,800 --> 00:06:45,909
должны были бы указать тип  наших
входных параметров

400
00:06:45,909 --> 00:06:45,919
входных параметров
 

401
00:06:45,919 --> 00:06:48,070
входных параметров
и типа наших возвращаемых значений, и

402
00:06:48,070 --> 00:06:48,080
и типа наших возвращаемых значений, и
 

403
00:06:48,080 --> 00:06:49,990
и типа наших возвращаемых значений, и
это потому, что функции являются частью

404
00:06:49,990 --> 00:06:50,000
это потому, что функции являются частью
 

405
00:06:50,000 --> 00:06:51,350
это потому, что функции являются частью
явного интерфейса,

406
00:06:51,350 --> 00:06:51,360
явного интерфейса,
 

407
00:06:51,360 --> 00:06:53,749
явного интерфейса,
доступного для пользователей, поэтому важно согласование

408
00:06:53,749 --> 00:06:53,759
доступного для пользователей, поэтому важно согласование
 

409
00:06:53,759 --> 00:06:55,110
доступного для пользователей, поэтому важно согласование
типов, которые передаются

410
00:06:55,110 --> 00:06:55,120
типов, которые передаются
 

411
00:06:55,120 --> 00:06:57,830
типов, которые передаются
и возвращаются, замыкания,

412
00:06:57,830 --> 00:06:57,840
и возвращаются, замыкания,
 

413
00:06:57,840 --> 00:06:59,510
и возвращаются, замыкания,
с другой стороны, обычно короткие и

414
00:06:59,510 --> 00:06:59,520
с другой стороны, обычно короткие и
 

415
00:06:59,520 --> 00:07:02,150
с другой стороны, обычно короткие и
актуальны только в узком  контекст, поэтому

416
00:07:02,150 --> 00:07:02,160
актуальны только в узком  контекст, поэтому
 

417
00:07:02,160 --> 00:07:02,550
актуальны только в узком  контекст, поэтому

418
00:07:02,550 --> 00:07:02,560

 

419
00:07:02,560 --> 00:07:04,870

компилятор может определять

420
00:07:04,870 --> 00:07:04,880
компилятор может определять
 

421
00:07:04,880 --> 00:07:05,990
компилятор может определять
типы входных параметров

422
00:07:05,990 --> 00:07:06,000
типы входных параметров
 

423
00:07:06,000 --> 00:07:08,230
типы входных параметров
и типы возвращаемых значений. Это похоже на то,

424
00:07:08,230 --> 00:07:08,240
и типы возвращаемых значений. Это похоже на то,
 

425
00:07:08,240 --> 00:07:10,150
и типы возвращаемых значений. Это похоже на то,
как компилятор может

426
00:07:10,150 --> 00:07:10,160
как компилятор может
 

427
00:07:10,160 --> 00:07:12,070
как компилятор может
определять типы большинства переменных.

428
00:07:12,070 --> 00:07:12,080
определять типы большинства переменных.
 

429
00:07:12,080 --> 00:07:13,749
определять типы большинства переменных.
Обратите внимание, что мы можем сделать типы

430
00:07:13,749 --> 00:07:13,759
Обратите внимание, что мы можем сделать типы
 

431
00:07:13,759 --> 00:07:17,430
Обратите внимание, что мы можем сделать типы
явными, если захотим.

432
00:07:17,430 --> 00:07:17,440
явными, если захотим.
 

433
00:07:17,440 --> 00:07:19,270
явными, если захотим.
за

434
00:07:19,270 --> 00:07:19,280
за
 

435
00:07:19,280 --> 00:07:21,350
за
счет большей детализации

436
00:07:21,350 --> 00:07:21,360
счет большей детализации
 

437
00:07:21,360 --> 00:07:23,189
счет большей детализации
обратите внимание, что определения замыкания могут

438
00:07:23,189 --> 00:07:23,199
обратите внимание, что определения замыкания могут
 

439
00:07:23,199 --> 00:07:25,350
обратите внимание, что определения замыкания могут
иметь только один конкретный тип, выведенный

440
00:07:25,350 --> 00:07:25,360
иметь только один конкретный тип, выведенный
 

441
00:07:25,360 --> 00:07:27,749
иметь только один конкретный тип, выведенный
для каждого входного параметра, например,

442
00:07:27,749 --> 00:07:27,759
для каждого входного параметра, например,
 

443
00:07:27,759 --> 00:07:29,110
для каждого входного параметра, например,
здесь мы  иметь переменную с именем

444
00:07:29,110 --> 00:07:29,120
здесь мы  иметь переменную с именем
 

445
00:07:29,120 --> 00:07:31,189
здесь мы  иметь переменную с именем
example closure, которая равна

446
00:07:31,189 --> 00:07:31,199
example closure, которая равна
 

447
00:07:31,199 --> 00:07:33,270
example closure, которая равна
замыканию, которое принимает x,

448
00:07:33,270 --> 00:07:33,280
замыканию, которое принимает x,
 

449
00:07:33,280 --> 00:07:36,150
замыканию, которое принимает x,
а затем возвращает x сейчас, потому что

450
00:07:36,150 --> 00:07:36,160
а затем возвращает x сейчас, потому что
 

451
00:07:36,160 --> 00:07:37,589
а затем возвращает x сейчас, потому что
замыкание используется

452
00:07:37,589 --> 00:07:37,599
замыкание используется
 

453
00:07:37,599 --> 00:07:40,309
замыкание используется
здесь, в строке 26, со строкой,

454
00:07:40,309 --> 00:07:40,319
здесь, в строке 26, со строкой,
 

455
00:07:40,319 --> 00:07:41,670
здесь, в строке 26, со строкой,
компилятор делает вывод,

456
00:07:41,670 --> 00:07:41,680
компилятор делает вывод,
 

457
00:07:41,680 --> 00:07:43,830
компилятор делает вывод,
что тип входного параметра является

458
00:07:43,830 --> 00:07:43,840
что тип входного параметра является
 

459
00:07:43,840 --> 00:07:46,230
что тип входного параметра является
строкой, но затем прямо под строкой

460
00:07:46,230 --> 00:07:46,240
строкой, но затем прямо под строкой
 

461
00:07:46,240 --> 00:07:47,270
строкой, но затем прямо под строкой
27

462
00:07:47,270 --> 00:07:47,280
27
 

463
00:07:47,280 --> 00:07:50,309
27
мы вызываем переменную замыкания нашего примера

464
00:07:50,309 --> 00:07:50,319
мы вызываем переменную замыкания нашего примера
 

465
00:07:50,319 --> 00:07:53,110
мы вызываем переменную замыкания нашего примера
целым числом, теперь компилятор будет

466
00:07:53,110 --> 00:07:53,120
целым числом, теперь компилятор будет
 

467
00:07:53,120 --> 00:07:53,830
целым числом, теперь компилятор будет
жаловаться,

468
00:07:53,830 --> 00:07:53,840
жаловаться,
 

469
00:07:53,840 --> 00:07:55,350
жаловаться,
а стрелка будет говорить, что у нас есть

470
00:07:55,350 --> 00:07:55,360
а стрелка будет говорить, что у нас есть
 

471
00:07:55,360 --> 00:07:57,510
а стрелка будет говорить, что у нас есть
несоответствующие типы, мы ожидаем

472
00:07:57,510 --> 00:07:57,520
несоответствующие типы, мы ожидаем
 

473
00:07:57,520 --> 00:07:58,550
несоответствующие типы, мы ожидаем
строку, но получаем

474
00:07:58,550 --> 00:07:58,560
строку, но получаем
 

475
00:07:58,560 --> 00:08:00,950
строку, но получаем
целое число, поэтому компилятор работает

476
00:08:00,950 --> 00:08:00,960
целое число, поэтому компилятор работает
 

477
00:08:00,960 --> 00:08:02,869
целое число, поэтому компилятор работает
так, что первый тип передается в наш

478
00:08:02,869 --> 00:08:02,879
так, что первый тип передается в наш
 

479
00:08:02,879 --> 00:08:03,670
так, что первый тип передается в наш
замыкание

480
00:08:03,670 --> 00:08:03,680
замыкание
 

481
00:08:03,680 --> 00:08:06,309
замыкание
будет конкретным типом наших входных

482
00:08:06,309 --> 00:08:06,319
будет конкретным типом наших входных
 

483
00:08:06,319 --> 00:08:07,189
будет конкретным типом наших входных
параметров.

484
00:08:07,189 --> 00:08:07,199
параметров.
 

485
00:08:07,199 --> 00:08:08,790
параметров.
Теперь давайте вернемся к проблеме

486
00:08:08,790 --> 00:08:11,029
Теперь давайте вернемся к проблеме
 

487
00:08:11,029 --> 00:08:11,039

 

488
00:08:11,039 --> 00:08:13,830

повторного вызова нашего дорогостоящего замыкания дважды в этом блоке if, мы могли бы решить

489
00:08:13,830 --> 00:08:13,840
повторного вызова нашего дорогостоящего замыкания дважды в этом блоке if, мы могли бы решить
 

490
00:08:13,840 --> 00:08:15,830
повторного вызова нашего дорогостоящего замыкания дважды в этом блоке if, мы могли бы решить
эту функцию, создав переменную

491
00:08:15,830 --> 00:08:15,840
эту функцию, создав переменную
 

492
00:08:15,840 --> 00:08:16,710
эту функцию, создав переменную
в верхней части нашего

493
00:08:16,710 --> 00:08:16,720
в верхней части нашего
 

494
00:08:16,720 --> 00:08:18,950
в верхней части нашего
блока if и просто сохранив результат

495
00:08:18,950 --> 00:08:18,960
блока if и просто сохранив результат
 

496
00:08:18,960 --> 00:08:20,309
блока if и просто сохранив результат
наше дорогое закрытие,

497
00:08:20,309 --> 00:08:20,319
наше дорогое закрытие,
 

498
00:08:20,319 --> 00:08:22,309
наше дорогое закрытие,
а затем использование этого результата в обоих

499
00:08:22,309 --> 00:08:22,319
а затем использование этого результата в обоих
 

500
00:08:22,319 --> 00:08:23,990
а затем использование этого результата в обоих
этих операторах строки печати,

501
00:08:23,990 --> 00:08:24,000
этих операторах строки печати,
 

502
00:08:24,000 --> 00:08:25,830
этих операторах строки печати,
но мы собираемся сделать что-то еще,

503
00:08:25,830 --> 00:08:25,840
но мы собираемся сделать что-то еще,
 

504
00:08:25,840 --> 00:08:28,070
но мы собираемся сделать что-то еще,
что мы сделаем, это используем шаблон запоминания

505
00:08:28,070 --> 00:08:28,080
что мы сделаем, это используем шаблон запоминания
 

506
00:08:28,080 --> 00:08:28,869
что мы сделаем, это используем шаблон запоминания

507
00:08:28,869 --> 00:08:28,879

 

508
00:08:28,879 --> 00:08:31,670

, создав строку str  uct, который будет содержать наше

509
00:08:31,670 --> 00:08:31,680
, создав строку str  uct, который будет содержать наше
 

510
00:08:31,680 --> 00:08:32,630
, создав строку str  uct, который будет содержать наше
закрытие

511
00:08:32,630 --> 00:08:32,640
закрытие
 

512
00:08:32,640 --> 00:08:35,430
закрытие
и результат нашего закрытия, здесь я

513
00:08:35,430 --> 00:08:35,440
и результат нашего закрытия, здесь я
 

514
00:08:35,440 --> 00:08:37,110
и результат нашего закрытия, здесь я
создал структуру с именем

515
00:08:37,110 --> 00:08:37,120
создал структуру с именем
 

516
00:08:37,120 --> 00:08:40,070
создал структуру с именем
cacher прямо над нашей функцией генерации тренировки

517
00:08:40,070 --> 00:08:40,080
cacher прямо над нашей функцией генерации тренировки
 

518
00:08:40,080 --> 00:08:40,870
cacher прямо над нашей функцией генерации тренировки

519
00:08:40,870 --> 00:08:40,880

 

520
00:08:40,880 --> 00:08:43,670

, чтобы определить перечисления структур или

521
00:08:43,670 --> 00:08:43,680
, чтобы определить перечисления структур или
 

522
00:08:43,680 --> 00:08:45,269
, чтобы определить перечисления структур или
даже параметры функции,

523
00:08:45,269 --> 00:08:45,279
даже параметры функции,
 

524
00:08:45,279 --> 00:08:47,910
даже параметры функции,
которые используют замыкания, нам нужно использовать

525
00:08:47,910 --> 00:08:47,920
которые используют замыкания, нам нужно использовать
 

526
00:08:47,920 --> 00:08:48,870
которые используют замыкания, нам нужно использовать
дженерики

527
00:08:48,870 --> 00:08:48,880
дженерики
 

528
00:08:48,880 --> 00:08:51,590
дженерики
и границы признаков здесь, наш кеш  instruct

529
00:08:51,590 --> 00:08:52,230
и границы признаков здесь, наш кеш  instruct
 

530
00:08:52,230 --> 00:08:52,240

 

531
00:08:52,240 --> 00:08:55,430

использует дженерик с именем t, и ниже мы определяем

532
00:08:55,430 --> 00:08:55,440
использует дженерик с именем t, и ниже мы определяем
 

533
00:08:55,440 --> 00:08:56,949
использует дженерик с именем t, и ниже мы определяем
трейт, связанный с дженериком,

534
00:08:56,949 --> 00:08:56,959
трейт, связанный с дженериком,
 

535
00:08:56,959 --> 00:08:59,590
трейт, связанный с дженериком,
а трейт, который мы используем, теперь является сокращением fn

536
00:08:59,590 --> 00:08:59,600
а трейт, который мы используем, теперь является сокращением fn
 

537
00:08:59,600 --> 00:09:00,150
а трейт, который мы используем, теперь является сокращением fn
от

538
00:09:00,150 --> 00:09:00,160
от
 

539
00:09:00,160 --> 00:09:02,070
от
function, не вдаваясь в то, что такое

540
00:09:02,070 --> 00:09:02,080
function, не вдаваясь в то, что такое
 

541
00:09:02,080 --> 00:09:04,310
function, не вдаваясь в то, что такое
трейт fn, просто знайте, что он

542
00:09:04,310 --> 00:09:04,320
трейт fn, просто знайте, что он
 

543
00:09:04,320 --> 00:09:05,750
трейт fn, просто знайте, что он
предоставляется стандартной библиотекой,

544
00:09:05,750 --> 00:09:05,760
предоставляется стандартной библиотекой,
 

545
00:09:05,760 --> 00:09:07,829
предоставляется стандартной библиотекой,
и все замыкания реализуются  одна из

546
00:09:07,829 --> 00:09:07,839
и все замыкания реализуются  одна из
 

547
00:09:07,839 --> 00:09:09,670
и все замыкания реализуются  одна из
трех черт fn,

548
00:09:09,670 --> 00:09:09,680
трех черт fn,
 

549
00:09:09,680 --> 00:09:12,389
трех черт fn,
одна из них — fn, другая — fn

550
00:09:12,389 --> 00:09:12,399
одна из них — fn, другая — fn
 

551
00:09:12,399 --> 00:09:13,350
одна из них — fn, другая — fn
mute,

552
00:09:13,350 --> 00:09:13,360
mute,
 

553
00:09:13,360 --> 00:09:17,269
mute,
а последняя — fn, как только

554
00:09:17,269 --> 00:09:17,279
а последняя — fn, как только
 

555
00:09:17,279 --> 00:09:19,110
а последняя — fn, как только
мы немного перейдем к различиям между

556
00:09:19,110 --> 00:09:19,120
мы немного перейдем к различиям между
 

557
00:09:19,120 --> 00:09:21,190
мы немного перейдем к различиям между
этими тремя чертами,

558
00:09:21,190 --> 00:09:21,200
этими тремя чертами,
 

559
00:09:21,200 --> 00:09:23,190
этими тремя чертами,
здесь мы добавили типы в лоток fn, чтобы

560
00:09:23,190 --> 00:09:23,200
здесь мы добавили типы в лоток fn, чтобы
 

561
00:09:23,200 --> 00:09:25,030
здесь мы добавили типы в лоток fn, чтобы
представлять  входные

562
00:09:25,030 --> 00:09:25,040
представлять  входные
 

563
00:09:25,040 --> 00:09:27,509
представлять  входные
параметры нашего закрытия, которое будет одним

564
00:09:27,509 --> 00:09:27,519
параметры нашего закрытия, которое будет одним
 

565
00:09:27,519 --> 00:09:29,430
параметры нашего закрытия, которое будет одним
32-битным целым числом без знака,

566
00:09:29,430 --> 00:09:29,440
32-битным целым числом без знака,
 

567
00:09:29,440 --> 00:09:31,670
32-битным целым числом без знака,
а также выходные параметры, которые

568
00:09:31,670 --> 00:09:31,680
а также выходные параметры, которые
 

569
00:09:31,680 --> 00:09:32,630
а также выходные параметры, которые
снова будут

570
00:09:32,630 --> 00:09:32,640
снова будут
 

571
00:09:32,640 --> 00:09:35,269
снова будут
32-битным целым числом без знака, тогда в

572
00:09:35,269 --> 00:09:35,279
32-битным целым числом без знака, тогда в
 

573
00:09:35,279 --> 00:09:37,190
32-битным целым числом без знака, тогда в
теле нашей структуры мы имеем

574
00:09:37,190 --> 00:09:37,200
теле нашей структуры мы имеем
 

575
00:09:37,200 --> 00:09:39,509
теле нашей структуры мы имеем
t  wo поля первое - это вычисление, в

576
00:09:39,509 --> 00:09:39,519
t  wo поля первое - это вычисление, в
 

577
00:09:39,519 --> 00:09:41,350
t  wo поля первое - это вычисление, в
котором будет храниться наш общий тип,

578
00:09:41,350 --> 00:09:41,360
котором будет храниться наш общий тип,
 

579
00:09:41,360 --> 00:09:44,070
котором будет храниться наш общий тип,
поэтому вычисление может быть любым замыканием, которое

580
00:09:44,070 --> 00:09:44,080
поэтому вычисление может быть любым замыканием, которое
 

581
00:09:44,080 --> 00:09:44,949
поэтому вычисление может быть любым замыканием, которое
соответствует этому

582
00:09:44,949 --> 00:09:44,959
соответствует этому
 

583
00:09:44,959 --> 00:09:48,310
соответствует этому
лотку, привязанному здесь, тогда у нас есть

584
00:09:48,310 --> 00:09:48,320
лотку, привязанному здесь, тогда у нас есть
 

585
00:09:48,320 --> 00:09:50,710
лотку, привязанному здесь, тогда у нас есть
значение, которое будет необязательным

586
00:09:50,710 --> 00:09:50,720
значение, которое будет необязательным
 

587
00:09:50,720 --> 00:09:51,670
значение, которое будет необязательным
32-битным

588
00:09:51,670 --> 00:09:51,680
32-битным
 

589
00:09:51,680 --> 00:09:54,230
32-битным
целочисленным значением, является необязательным, потому что, когда

590
00:09:54,230 --> 00:09:54,240
целочисленным значением, является необязательным, потому что, когда
 

591
00:09:54,240 --> 00:09:55,110
целочисленным значением, является необязательным, потому что, когда
наш кэшер

592
00:09:55,110 --> 00:09:55,120
наш кэшер
 

593
00:09:55,120 --> 00:09:57,190
наш кэшер
инициализируется  это будет ни один, а

594
00:09:57,190 --> 00:09:57,200
инициализируется  это будет ни один, а
 

595
00:09:57,200 --> 00:09:59,110
инициализируется  это будет ни один, а
затем, когда мы вызовем наш расчет,

596
00:09:59,110 --> 00:09:59,120
затем, когда мы вызовем наш расчет,
 

597
00:09:59,120 --> 00:10:01,590
затем, когда мы вызовем наш расчет,
мы сохраним возвращаемое значение внутри

598
00:10:01,590 --> 00:10:01,600
мы сохраним возвращаемое значение внутри
 

599
00:10:01,600 --> 00:10:02,870
мы сохраним возвращаемое значение внутри
нашего поля значений.

600
00:10:02,870 --> 00:10:02,880
нашего поля значений.
 

601
00:10:02,880 --> 00:10:05,190
нашего поля значений.
Обратите внимание, что обычные функции также

602
00:10:05,190 --> 00:10:05,200
Обратите внимание, что обычные функции также
 

603
00:10:05,200 --> 00:10:06,710
Обратите внимание, что обычные функции также
реализуют эти три

604
00:10:06,710 --> 00:10:06,720
реализуют эти три
 

605
00:10:06,720 --> 00:10:09,829
реализуют эти три
признака fn, поэтому мы можем сохранить обычную

606
00:10:09,829 --> 00:10:09,839
признака fn, поэтому мы можем сохранить обычную
 

607
00:10:09,839 --> 00:10:10,310
признака fn, поэтому мы можем сохранить обычную
функцию

608
00:10:10,310 --> 00:10:10,320
функцию
 

609
00:10:10,320 --> 00:10:13,190
функцию
внутри нашего поля вычисления, а

610
00:10:13,190 --> 00:10:13,200
внутри нашего поля вычисления, а
 

611
00:10:13,200 --> 00:10:15,190
внутри нашего поля вычисления, а
затем i'  Я вставлю блок реализации

612
00:10:15,190 --> 00:10:15,200
затем i'  Я вставлю блок реализации
 

613
00:10:15,200 --> 00:10:16,949
затем i'  Я вставлю блок реализации
для кеша или структуры,

614
00:10:16,949 --> 00:10:16,959
для кеша или структуры,
 

615
00:10:16,959 --> 00:10:21,110
для кеша или структуры,
и мы поговорим об этом,

616
00:10:21,110 --> 00:10:21,120

 

617
00:10:21,120 --> 00:10:23,269

ладно, давайте пройдемся по этому, у нас есть

618
00:10:23,269 --> 00:10:23,279
ладно, давайте пройдемся по этому, у нас есть
 

619
00:10:23,279 --> 00:10:24,389
ладно, давайте пройдемся по этому, у нас есть
блок реализации

620
00:10:24,389 --> 00:10:24,399
блок реализации
 

621
00:10:24,399 --> 00:10:27,110
блок реализации
для кеша, который имеет ту же общую и трейтовую привязку, что

622
00:10:27,110 --> 00:10:27,120
для кеша, который имеет ту же общую и трейтовую привязку, что
 

623
00:10:27,120 --> 00:10:28,230
для кеша, который имеет ту же общую и трейтовую привязку, что
и

624
00:10:28,230 --> 00:10:28,240
и
 

625
00:10:28,240 --> 00:10:30,630
и
наш кеш или структура, а затем

626
00:10:30,630 --> 00:10:30,640
наш кеш или структура, а затем
 

627
00:10:30,640 --> 00:10:31,590
наш кеш или структура, а затем
первая функция

628
00:10:31,590 --> 00:10:31,600
первая функция
 

629
00:10:31,600 --> 00:10:34,150
первая функция
внутри:  называется new new —

630
00:10:34,150 --> 00:10:34,160
внутри:  называется new new —
 

631
00:10:34,160 --> 00:10:35,750
внутри:  называется new new —
это функция конструктора,

632
00:10:35,750 --> 00:10:35,760
это функция конструктора,
 

633
00:10:35,760 --> 00:10:37,829
это функция конструктора,
которая принимает вычисление типа t

634
00:10:37,829 --> 00:10:37,839
которая принимает вычисление типа t
 

635
00:10:37,839 --> 00:10:39,910
которая принимает вычисление типа t
нашего замыкания, а затем создает новый

636
00:10:39,910 --> 00:10:39,920
нашего замыкания, а затем создает новый
 

637
00:10:39,920 --> 00:10:41,190
нашего замыкания, а затем создает новый
кешировщик,

638
00:10:41,190 --> 00:10:41,200
кешировщик,
 

639
00:10:41,200 --> 00:10:44,069
кешировщик,
передающий вычисление и устанавливающий значение

640
00:10:44,069 --> 00:10:44,079
передающий вычисление и устанавливающий значение
 

641
00:10:44,079 --> 00:10:44,790
передающий вычисление и устанавливающий значение
none

642
00:10:44,790 --> 00:10:44,800
none
 

643
00:10:44,800 --> 00:10:47,910
none
затем у нас есть наш метод значения, и это

644
00:10:47,910 --> 00:10:47,920
затем у нас есть наш метод значения, и это
 

645
00:10:47,920 --> 00:10:49,670
затем у нас есть наш метод значения, и это
метод, потому что первый параметр

646
00:10:49,670 --> 00:10:49,680
метод, потому что первый параметр
 

647
00:10:49,680 --> 00:10:52,389
метод, потому что первый параметр
является ссылкой на себя, и на самом деле у

648
00:10:52,389 --> 00:10:52,399
является ссылкой на себя, и на самом деле у
 

649
00:10:52,399 --> 00:10:54,470
является ссылкой на себя, и на самом деле у
нас есть изменяемая ссылка на себя,

650
00:10:54,470 --> 00:10:54,480
нас есть изменяемая ссылка на себя,
 

651
00:10:54,480 --> 00:10:57,590
нас есть изменяемая ссылка на себя,
следующий параметр - arg, который является

652
00:10:57,590 --> 00:10:57,600
следующий параметр - arg, который является
 

653
00:10:57,600 --> 00:11:00,150
следующий параметр - arg, который является
аргументом, который мы передадим в наше замыкание, и

654
00:11:00,150 --> 00:11:00,160
аргументом, который мы передадим в наше замыкание, и
 

655
00:11:00,160 --> 00:11:02,550
аргументом, который мы передадим в наше замыкание, и
это беззнаковое 32  -битное целое число

656
00:11:02,550 --> 00:11:02,560
это беззнаковое 32  -битное целое число
 

657
00:11:02,560 --> 00:11:05,110
это беззнаковое 32  -битное целое число
возвращаемый тип также является 32-битным целым числом без знака

658
00:11:05,110 --> 00:11:05,120
возвращаемый тип также является 32-битным целым числом без знака
 

659
00:11:05,120 --> 00:11:05,829
возвращаемый тип также является 32-битным целым числом без знака

660
00:11:05,829 --> 00:11:05,839

 

661
00:11:05,839 --> 00:11:08,069

внутри метода значения, мы собираемся

662
00:11:08,069 --> 00:11:08,079
внутри метода значения, мы собираемся
 

663
00:11:08,079 --> 00:11:09,590
внутри метода значения, мы собираемся
выполнить выражение соответствия

664
00:11:09,590 --> 00:11:09,600
выполнить выражение соответствия
 

665
00:11:09,600 --> 00:11:12,710
выполнить выражение соответствия
для значения собственной точки, поэтому мы проверяем тип

666
00:11:12,710 --> 00:11:12,720
для значения собственной точки, поэтому мы проверяем тип
 

667
00:11:12,720 --> 00:11:13,829
для значения собственной точки, поэтому мы проверяем тип
собственной точки

668
00:11:13,829 --> 00:11:13,839
собственной точки
 

669
00:11:13,839 --> 00:11:16,550
собственной точки
и помним, что self.value является

670
00:11:16,550 --> 00:11:16,560
и помним, что self.value является
 

671
00:11:16,560 --> 00:11:17,509
и помним, что self.value является
необязательным типом

672
00:11:17,509 --> 00:11:17,519
необязательным типом
 

673
00:11:17,519 --> 00:11:19,829
необязательным типом
и  когда мы впервые создадим наш кэшер, для него

674
00:11:19,829 --> 00:11:19,839
и  когда мы впервые создадим наш кэшер, для него
 

675
00:11:19,839 --> 00:11:21,269
и  когда мы впервые создадим наш кэшер, для него
будет установлено значение none,

676
00:11:21,269 --> 00:11:21,279
будет установлено значение none,
 

677
00:11:21,279 --> 00:11:24,310
будет установлено значение none,
поэтому мы выполним эту

678
00:11:24,310 --> 00:11:24,320
поэтому мы выполним эту
 

679
00:11:24,320 --> 00:11:26,389
поэтому мы выполним эту
ветвь none внутри ветви none. Мы создаем

680
00:11:26,389 --> 00:11:26,399
ветвь none внутри ветви none. Мы создаем
 

681
00:11:26,399 --> 00:11:27,430
ветвь none внутри ветви none. Мы создаем
переменную с именем v

682
00:11:27,430 --> 00:11:27,440
переменную с именем v
 

683
00:11:27,440 --> 00:11:29,590
переменную с именем v
и устанавливаем ее равной результату

684
00:11:29,590 --> 00:11:29,600
и устанавливаем ее равной результату
 

685
00:11:29,600 --> 00:11:31,350
и устанавливаем ее равной результату
вызова закрытия нашего вычисления

686
00:11:31,350 --> 00:11:31,360
вызова закрытия нашего вычисления
 

687
00:11:31,360 --> 00:11:35,030
вызова закрытия нашего вычисления
и передачи переменной arg.

688
00:11:35,030 --> 00:11:35,040
и передачи переменной arg.
 

689
00:11:35,040 --> 00:11:37,110
и передачи переменной arg.
затем мы изменяем поле

690
00:11:37,110 --> 00:11:37,120
затем мы изменяем поле
 

691
00:11:37,120 --> 00:11:38,710
затем мы изменяем поле
значения текущего кеша или экземпляра

692
00:11:38,710 --> 00:11:38,720
значения текущего кеша или экземпляра
 

693
00:11:38,720 --> 00:11:42,069
значения текущего кеша или экземпляра
и устанавливаем его для некоторого прохождения в v,

694
00:11:42,069 --> 00:11:42,079
и устанавливаем его для некоторого прохождения в v,
 

695
00:11:42,079 --> 00:11:44,069
и устанавливаем его для некоторого прохождения в v,
здесь происходит кеширование, мы

696
00:11:44,069 --> 00:11:44,079
здесь происходит кеширование, мы
 

697
00:11:44,079 --> 00:11:45,829
здесь происходит кеширование, мы
кэшируем возвращаемое значение нашего

698
00:11:45,829 --> 00:11:45,839
кэшируем возвращаемое значение нашего
 

699
00:11:45,839 --> 00:11:46,949
кэшируем возвращаемое значение нашего
вычисления

700
00:11:46,949 --> 00:11:46,959
вычисления
 

701
00:11:46,959 --> 00:11:49,110
вычисления
внутри поля значения, а затем мы

702
00:11:49,110 --> 00:11:49,120
внутри поля значения, а затем мы
 

703
00:11:49,120 --> 00:11:50,710
внутри поля значения, а затем мы
просто возвращаем

704
00:11:50,710 --> 00:11:50,720
просто возвращаем
 

705
00:11:50,720 --> 00:11:53,190
просто возвращаем
v next let  используем наши наличные деньги или структуру

706
00:11:53,190 --> 00:11:53,200
v next let  используем наши наличные деньги или структуру
 

707
00:11:53,200 --> 00:11:55,350
v next let  используем наши наличные деньги или структуру
внутри функции генерации тренировки,

708
00:11:55,350 --> 00:11:55,360
внутри функции генерации тренировки,
 

709
00:11:55,360 --> 00:11:57,430
внутри функции генерации тренировки,
но прежде чем мы это сделаем, давайте сначала запустим

710
00:11:57,430 --> 00:11:57,440
но прежде чем мы это сделаем, давайте сначала запустим
 

711
00:11:57,440 --> 00:12:03,509
но прежде чем мы это сделаем, давайте сначала запустим
нашу программу,

712
00:12:03,509 --> 00:12:03,519

 

713
00:12:03,519 --> 00:12:05,590

как вы можете видеть, наше дорогостоящее закрытие было

714
00:12:05,590 --> 00:12:05,600
как вы можете видеть, наше дорогостоящее закрытие было
 

715
00:12:05,600 --> 00:12:06,710
как вы можете видеть, наше дорогостоящее закрытие было
вызвано дважды,

716
00:12:06,710 --> 00:12:06,720
вызвано дважды,
 

717
00:12:06,720 --> 00:12:08,949
вызвано дважды,
один раз, чтобы вычислить количество отжиманий,

718
00:12:08,949 --> 00:12:08,959
один раз, чтобы вычислить количество отжиманий,
 

719
00:12:08,959 --> 00:12:10,550
один раз, чтобы вычислить количество отжиманий,
а второй раз, чтобы

720
00:12:10,550 --> 00:12:10,560
а второй раз, чтобы
 

721
00:12:10,560 --> 00:12:12,870
а второй раз, чтобы
вычислить количество отжиманий.  приседания, давайте сделаем это

722
00:12:12,870 --> 00:12:12,880
вычислить количество отжиманий.  приседания, давайте сделаем это
 

723
00:12:12,880 --> 00:12:14,710
вычислить количество отжиманий.  приседания, давайте сделаем это
более эффективным, обернув наше

724
00:12:14,710 --> 00:12:14,720
более эффективным, обернув наше
 

725
00:12:14,720 --> 00:12:15,430
более эффективным, обернув наше

726
00:12:15,430 --> 00:12:15,440

 

727
00:12:15,440 --> 00:12:27,990

определение замыкания здесь внутри нашей структуры casher,

728
00:12:27,990 --> 00:12:28,000

 

729
00:12:28,000 --> 00:12:29,750

здесь мы вызываем новую функцию для

730
00:12:29,750 --> 00:12:29,760
здесь мы вызываем новую функцию для
 

731
00:12:29,760 --> 00:12:31,829
здесь мы вызываем новую функцию для
нашей наличности или структуры и передаем

732
00:12:31,829 --> 00:12:31,839
нашей наличности или структуры и передаем
 

733
00:12:31,839 --> 00:12:34,069
нашей наличности или структуры и передаем
наше замыкание, которое будет установлено в

734
00:12:34,069 --> 00:12:34,079
наше замыкание, которое будет установлено в
 

735
00:12:34,079 --> 00:12:35,430
наше замыкание, которое будет установлено в
поле вычисления

736
00:12:35,430 --> 00:12:35,440
поле вычисления
 

737
00:12:35,440 --> 00:12:37,670
поле вычисления
в нашей структуре наличности, давайте  измените

738
00:12:37,670 --> 00:12:37,680
в нашей структуре наличности, давайте  измените
 

739
00:12:37,680 --> 00:12:42,870
в нашей структуре наличности, давайте  измените
имя нашей переменной на кешированный результат,

740
00:12:42,870 --> 00:12:42,880

 

741
00:12:42,880 --> 00:12:44,310

мы также хотим сделать нашу переменную

742
00:12:44,310 --> 00:12:44,320
мы также хотим сделать нашу переменную
 

743
00:12:44,320 --> 00:12:45,910
мы также хотим сделать нашу переменную
изменяемой, потому что мы будем вызывать

744
00:12:45,910 --> 00:12:45,920
изменяемой, потому что мы будем вызывать
 

745
00:12:45,920 --> 00:12:46,790
изменяемой, потому что мы будем вызывать
метод значения,

746
00:12:46,790 --> 00:12:46,800
метод значения,
 

747
00:12:46,800 --> 00:12:52,389
метод значения,
который изменит наш кеш или структуру,

748
00:12:52,389 --> 00:12:52,399
который изменит наш кеш или структуру,
 

749
00:12:52,399 --> 00:12:54,230
который изменит наш кеш или структуру,
затем вместо вызова дорогостоящего

750
00:12:54,230 --> 00:12:54,240
затем вместо вызова дорогостоящего
 

751
00:12:54,240 --> 00:12:55,509
затем вместо вызова дорогостоящего
закрытия мы

752
00:12:55,509 --> 00:12:55,519
закрытия мы
 

753
00:12:55,519 --> 00:13:07,590
закрытия мы
вызовем точечное значение cachedresult,

754
00:13:07,590 --> 00:13:07,600
вызовем точечное значение cachedresult,
 

755
00:13:07,600 --> 00:13:13,269
вызовем точечное значение cachedresult,
давайте продолжим и  снова запустите нашу программу,

756
00:13:13,269 --> 00:13:13,279

 

757
00:13:13,279 --> 00:13:15,269

и, как вы можете видеть, на этот раз мы

758
00:13:15,269 --> 00:13:15,279
и, как вы можете видеть, на этот раз мы
 

759
00:13:15,279 --> 00:13:17,590
и, как вы можете видеть, на этот раз мы
вызываем нашу дорогостоящую операцию

760
00:13:17,590 --> 00:13:17,600
вызываем нашу дорогостоящую операцию
 

761
00:13:17,600 --> 00:13:20,389
вызываем нашу дорогостоящую операцию
только один раз, теперь кэширование значений, как правило, является

762
00:13:20,389 --> 00:13:20,399
только один раз, теперь кэширование значений, как правило, является
 

763
00:13:20,399 --> 00:13:22,470
только один раз, теперь кэширование значений, как правило, является
полезным поведением, поэтому мы можем захотеть использовать

764
00:13:22,470 --> 00:13:22,480
полезным поведением, поэтому мы можем захотеть использовать
 

765
00:13:22,480 --> 00:13:23,350
полезным поведением, поэтому мы можем захотеть использовать
наш кешировщик

766
00:13:23,350 --> 00:13:23,360
наш кешировщик
 

767
00:13:23,360 --> 00:13:25,590
наш кешировщик
в разных  контекстах, но есть две

768
00:13:25,590 --> 00:13:25,600
в разных  контекстах, но есть две
 

769
00:13:25,600 --> 00:13:27,910
в разных  контекстах, но есть две
проблемы, мешающие нам решить эту

770
00:13:27,910 --> 00:13:27,920
проблемы, мешающие нам решить эту
 

771
00:13:27,920 --> 00:13:30,230
проблемы, мешающие нам решить эту
проблему. Номер один: вызов нашего

772
00:13:30,230 --> 00:13:30,240
проблему. Номер один: вызов нашего
 

773
00:13:30,240 --> 00:13:32,069
проблему. Номер один: вызов нашего
метода значения будет возвращать

774
00:13:32,069 --> 00:13:32,079
метода значения будет возвращать
 

775
00:13:32,079 --> 00:13:35,190
метода значения будет возвращать
одно и то же значение независимо от

776
00:13:35,190 --> 00:13:35,200
одно и то же значение независимо от
 

777
00:13:35,200 --> 00:13:37,829
одно и то же значение независимо от
входного параметра arg, например, скажем,

778
00:13:37,829 --> 00:13:37,839
входного параметра arg, например, скажем,
 

779
00:13:37,839 --> 00:13:39,910
входного параметра arg, например, скажем,
при первом вызове метода значения, который

780
00:13:39,910 --> 00:13:39,920
при первом вызове метода значения, который
 

781
00:13:39,920 --> 00:13:43,110
при первом вызове метода значения, который
мы передаем в одном  как значение для arg,

782
00:13:43,110 --> 00:13:43,120
мы передаем в одном  как значение для arg,
 

783
00:13:43,120 --> 00:13:44,389
мы передаем в одном  как значение для arg,
потому что это первый раз, когда мы

784
00:13:44,389 --> 00:13:44,399
потому что это первый раз, когда мы
 

785
00:13:44,399 --> 00:13:46,790
потому что это первый раз, когда мы
вызываем метод значения self.value

786
00:13:46,790 --> 00:13:46,800
вызываем метод значения self.value
 

787
00:13:46,800 --> 00:13:48,230
вызываем метод значения self.value
будет оцениваться как none,

788
00:13:48,230 --> 00:13:48,240
будет оцениваться как none,
 

789
00:13:48,240 --> 00:13:50,150
будет оцениваться как none,
поэтому мы перейдем к ветке none, а

790
00:13:50,150 --> 00:13:50,160
поэтому мы перейдем к ветке none, а
 

791
00:13:50,160 --> 00:13:51,350
поэтому мы перейдем к ветке none, а
затем вызовем наше

792
00:13:51,350 --> 00:13:51,360
затем вызовем наше
 

793
00:13:51,360 --> 00:13:53,910
затем вызовем наше
закрытие с нашим arg, который

794
00:13:53,910 --> 00:13:53,920
закрытие с нашим arg, который
 

795
00:13:53,920 --> 00:13:55,269
закрытие с нашим arg, который
будет равен  на 1.

796
00:13:55,269 --> 00:13:55,279
будет равен  на 1.
 

797
00:13:55,279 --> 00:13:57,670
будет равен  на 1.
затем мы возьмем полученное значение и

798
00:13:57,670 --> 00:13:57,680
затем мы возьмем полученное значение и
 

799
00:13:57,680 --> 00:13:58,870
затем мы возьмем полученное значение и
сохраним его внутри

800
00:13:58,870 --> 00:13:58,880
сохраним его внутри
 

801
00:13:58,880 --> 00:14:01,670
сохраним его внутри
self.value теперь представьте, что мы снова вызываем наш метод значения,

802
00:14:01,670 --> 00:14:01,680
self.value теперь представьте, что мы снова вызываем наш метод значения,
 

803
00:14:01,680 --> 00:14:02,150
self.value теперь представьте, что мы снова вызываем наш метод значения,

804
00:14:02,150 --> 00:14:02,160

 

805
00:14:02,160 --> 00:14:04,870

но на этот раз мы передаем 2, поскольку

806
00:14:04,870 --> 00:14:04,880
но на этот раз мы передаем 2, поскольку
 

807
00:14:04,880 --> 00:14:05,590
но на этот раз мы передаем 2, поскольку
значение для

808
00:14:05,590 --> 00:14:05,600
значение для
 

809
00:14:05,600 --> 00:14:08,470
значение для
arg на этот раз self.value уже существует,

810
00:14:08,470 --> 00:14:08,480
arg на этот раз self.value уже существует,
 

811
00:14:08,480 --> 00:14:10,550
arg на этот раз self.value уже существует,
поэтому мы пойдем  в руку суммы и просто

812
00:14:10,550 --> 00:14:10,560
поэтому мы пойдем  в руку суммы и просто
 

813
00:14:10,560 --> 00:14:13,350
поэтому мы пойдем  в руку суммы и просто
вернуть значение, хранящееся в сумме, это

814
00:14:13,350 --> 00:14:13,360
вернуть значение, хранящееся в сумме, это
 

815
00:14:13,360 --> 00:14:14,389
вернуть значение, хранящееся в сумме, это
проблематично, потому что

816
00:14:14,389 --> 00:14:14,399
проблематично, потому что
 

817
00:14:14,399 --> 00:14:16,790
проблематично, потому что
r передается нашему замыканию, что означает,

818
00:14:16,790 --> 00:14:16,800
r передается нашему замыканию, что означает,
 

819
00:14:16,800 --> 00:14:18,790
r передается нашему замыканию, что означает,
что оно может изменить результирующее значение,

820
00:14:18,790 --> 00:14:18,800
что оно может изменить результирующее значение,
 

821
00:14:18,800 --> 00:14:19,430
что оно может изменить результирующее значение,
полученное

822
00:14:19,430 --> 00:14:19,440
полученное
 

823
00:14:19,440 --> 00:14:21,269
полученное
из нашего замыкания, но с нашей текущей

824
00:14:21,269 --> 00:14:21,279
из нашего замыкания, но с нашей текущей
 

825
00:14:21,279 --> 00:14:23,430
из нашего замыкания, но с нашей текущей
реализацией значение всегда

826
00:14:23,430 --> 00:14:23,440
реализацией значение всегда
 

827
00:14:23,440 --> 00:14:25,590
реализацией значение всегда
будет равно re  Результатом вызова

828
00:14:25,590 --> 00:14:25,600
будет равно re  Результатом вызова
 

829
00:14:25,600 --> 00:14:27,829
будет равно re  Результатом вызова
нашего закрытия с аргументом, переданным

830
00:14:27,829 --> 00:14:27,839
нашего закрытия с аргументом, переданным
 

831
00:14:27,839 --> 00:14:29,110
нашего закрытия с аргументом, переданным
в первый

832
00:14:29,110 --> 00:14:29,120
в первый
 

833
00:14:29,120 --> 00:14:31,350
в первый
вызов значения, я в основном говорю, что

834
00:14:31,350 --> 00:14:31,360
вызов значения, я в основном говорю, что
 

835
00:14:31,360 --> 00:14:33,189
вызов значения, я в основном говорю, что
вместо кэширования одного значения

836
00:14:33,189 --> 00:14:33,199
вместо кэширования одного значения
 

837
00:14:33,199 --> 00:14:35,590
вместо кэширования одного значения
независимо от того, какой аргумент передан,

838
00:14:35,590 --> 00:14:35,600
независимо от того, какой аргумент передан,
 

839
00:14:35,600 --> 00:14:36,710
независимо от того, какой аргумент передан,
нам нужно кэшировать

840
00:14:36,710 --> 00:14:36,720
нам нужно кэшировать
 

841
00:14:36,720 --> 00:14:39,110
нам нужно кэшировать
одно значение для каждого передаваемого аргумента

842
00:14:39,110 --> 00:14:39,120
одно значение для каждого передаваемого аргумента
 

843
00:14:39,120 --> 00:14:40,790
одно значение для каждого передаваемого аргумента
, потому что аргумент

844
00:14:40,790 --> 00:14:40,800
, потому что аргумент
 

845
00:14:40,800 --> 00:14:43,750
, потому что аргумент
влияет на значение в качестве упражнения, вы

846
00:14:43,750 --> 00:14:43,760
влияет на значение в качестве упражнения, вы
 

847
00:14:43,760 --> 00:14:45,910
влияет на значение в качестве упражнения, вы
можете исправить эту реализацию, сохранив

848
00:14:45,910 --> 00:14:45,920
можете исправить эту реализацию, сохранив
 

849
00:14:45,920 --> 00:14:46,629
можете исправить эту реализацию, сохранив
хэш-карту

850
00:14:46,629 --> 00:14:46,639
хэш-карту
 

851
00:14:46,639 --> 00:14:48,949
хэш-карту
вместо одного значения,

852
00:14:48,949 --> 00:14:48,959
вместо одного значения,
 

853
00:14:48,959 --> 00:14:50,389
вместо одного значения,
ключи хэш-карты

854
00:14:50,389 --> 00:14:50,399
ключи хэш-карты
 

855
00:14:50,399 --> 00:14:53,110
ключи хэш-карты
будут аргументом, переданным в значение, а

856
00:14:53,110 --> 00:14:53,120
будут аргументом, переданным в значение, а
 

857
00:14:53,120 --> 00:14:54,470
будут аргументом, переданным в значение, а
значения в вашей хэш-карте

858
00:14:54,470 --> 00:14:54,480
значения в вашей хэш-карте
 

859
00:14:54,480 --> 00:14:57,189
значения в вашей хэш-карте
будут результатом вызова

860
00:14:57,189 --> 00:14:57,199
будут результатом вызова
 

861
00:14:57,199 --> 00:14:58,069
будут результатом вызова
замыкания

862
00:14:58,069 --> 00:14:58,079
замыкания
 

863
00:14:58,079 --> 00:15:00,550
замыкания
с аргументом, затем  внутри

864
00:15:00,550 --> 00:15:00,560
с аргументом, затем  внутри
 

865
00:15:00,560 --> 00:15:01,670
с аргументом, затем  внутри
тела этого метода значения

866
00:15:01,670 --> 00:15:01,680
тела этого метода значения
 

867
00:15:01,680 --> 00:15:04,150
тела этого метода значения
вам нужно будет найти аргумент внутри

868
00:15:04,150 --> 00:15:04,160
вам нужно будет найти аргумент внутри
 

869
00:15:04,160 --> 00:15:05,110
вам нужно будет найти аргумент внутри
вашей хэш-карты,

870
00:15:05,110 --> 00:15:05,120
вашей хэш-карты,
 

871
00:15:05,120 --> 00:15:07,829
вашей хэш-карты,
и если значение для этого аргумента существует,

872
00:15:07,829 --> 00:15:07,839
и если значение для этого аргумента существует,
 

873
00:15:07,839 --> 00:15:09,110
и если значение для этого аргумента существует,
просто

874
00:15:09,110 --> 00:15:09,120
просто
 

875
00:15:09,120 --> 00:15:11,590
просто
верните значение, и если оно не существует, запустите

876
00:15:11,590 --> 00:15:11,600
верните значение, и если оно не существует, запустите
 

877
00:15:11,600 --> 00:15:13,829
верните значение, и если оно не существует, запустите
свой дорогой расчет и сохраните

878
00:15:13,829 --> 00:15:13,839
свой дорогой расчет и сохраните
 

879
00:15:13,839 --> 00:15:14,550
свой дорогой расчет и сохраните
результат

880
00:15:14,550 --> 00:15:14,560
результат
 

881
00:15:14,560 --> 00:15:16,790
результат
внутри  ваша хеш-карта вторая проблема

882
00:15:16,790 --> 00:15:16,800
внутри  ваша хеш-карта вторая проблема
 

883
00:15:16,800 --> 00:15:18,949
внутри  ваша хеш-карта вторая проблема
с нашей реализацией кэшера

884
00:15:18,949 --> 00:15:18,959
с нашей реализацией кэшера
 

885
00:15:18,959 --> 00:15:21,350
с нашей реализацией кэшера
заключается в том, что мы используем жестко закодированные типы,

886
00:15:21,350 --> 00:15:21,360
заключается в том, что мы используем жестко закодированные типы,
 

887
00:15:21,360 --> 00:15:22,710
заключается в том, что мы используем жестко закодированные типы,
например, мы говорим, что наше

888
00:15:22,710 --> 00:15:22,720
например, мы говорим, что наше
 

889
00:15:22,720 --> 00:15:25,189
например, мы говорим, что наше
закрытие должно принимать целое число и

890
00:15:25,189 --> 00:15:25,199
закрытие должно принимать целое число и
 

891
00:15:25,199 --> 00:15:26,470
закрытие должно принимать целое число и
возвращать целое число

892
00:15:26,470 --> 00:15:26,480
возвращать целое число
 

893
00:15:26,480 --> 00:15:28,949
возвращать целое число
и наше значение также должно быть целым числом,

894
00:15:28,949 --> 00:15:28,959
и наше значение также должно быть целым числом,
 

895
00:15:28,959 --> 00:15:29,590
и наше значение также должно быть целым числом,

896
00:15:29,590 --> 00:15:29,600

 

897
00:15:29,600 --> 00:15:32,069

чтобы исправить это, вы можете просто использовать дженерики

898
00:15:32,069 --> 00:15:32,079
чтобы исправить это, вы можете просто использовать дженерики
 

899
00:15:32,079 --> 00:15:32,710
чтобы исправить это, вы можете просто использовать дженерики
вместо

900
00:15:32,710 --> 00:15:32,720
вместо
 

901
00:15:32,720 --> 00:15:34,870
вместо
жестко закодированных значений. Последнее, о чем я

902
00:15:34,870 --> 00:15:34,880
жестко закодированных значений. Последнее, о чем я
 

903
00:15:34,880 --> 00:15:36,629
жестко закодированных значений. Последнее, о чем я
хочу поговорить, это захват

904
00:15:36,629 --> 00:15:36,639
хочу поговорить, это захват
 

905
00:15:36,639 --> 00:15:38,389
хочу поговорить, это захват
среды с помощью замыканий, в

906
00:15:38,389 --> 00:15:38,399
среды с помощью замыканий, в
 

907
00:15:38,399 --> 00:15:41,189
среды с помощью замыканий, в
отличие от замыканий функций, которые имеют доступ к

908
00:15:41,189 --> 00:15:41,199
отличие от замыканий функций, которые имеют доступ к
 

909
00:15:41,199 --> 00:15:42,069
отличие от замыканий функций, которые имеют доступ к
переменным

910
00:15:42,069 --> 00:15:42,079
переменным
 

911
00:15:42,079 --> 00:15:43,990
переменным
, которые определены в пределах  область, в

912
00:15:43,990 --> 00:15:44,000
, которые определены в пределах  область, в
 

913
00:15:44,000 --> 00:15:45,829
, которые определены в пределах  область, в
которой определено закрытие,

914
00:15:45,829 --> 00:15:45,839
которой определено закрытие,
 

915
00:15:45,839 --> 00:15:47,749
которой определено закрытие,
вот простой пример вверху, у

916
00:15:47,749 --> 00:15:47,759
вот простой пример вверху, у
 

917
00:15:47,759 --> 00:15:48,870
вот простой пример вверху, у
нас есть переменная с именем

918
00:15:48,870 --> 00:15:48,880
нас есть переменная с именем
 

919
00:15:48,880 --> 00:15:51,590
нас есть переменная с именем
x, которая равна четырем, затем у нас есть

920
00:15:51,590 --> 00:15:51,600
x, которая равна четырем, затем у нас есть
 

921
00:15:51,600 --> 00:15:53,350
x, которая равна четырем, затем у нас есть
закрытие с именем, равным x,

922
00:15:53,350 --> 00:15:53,360
закрытие с именем, равным x,
 

923
00:15:53,360 --> 00:15:55,749
закрытие с именем, равным x,
которое принимает переменную с именем z, а

924
00:15:55,749 --> 00:15:55,759
которое принимает переменную с именем z, а
 

925
00:15:55,759 --> 00:15:57,509
которое принимает переменную с именем z, а
затем возвращает

926
00:15:57,509 --> 00:15:57,519
затем возвращает
 

927
00:15:57,519 --> 00:15:59,110
затем возвращает
логическое значение, которое будет  чтобы быть равным этому

928
00:15:59,110 --> 00:15:59,120
логическое значение, которое будет  чтобы быть равным этому
 

929
00:15:59,120 --> 00:16:00,949
логическое значение, которое будет  чтобы быть равным этому
выражению z

930
00:16:00,949 --> 00:16:00,959
выражению z
 

931
00:16:00,959 --> 00:16:03,590
выражению z
теперь равен x, хотя x определен

932
00:16:03,590 --> 00:16:03,600
теперь равен x, хотя x определен
 

933
00:16:03,600 --> 00:16:05,110
теперь равен x, хотя x определен
вне нашего замыкания,

934
00:16:05,110 --> 00:16:05,120
вне нашего замыкания,
 

935
00:16:05,120 --> 00:16:07,430
вне нашего замыкания,
наше замыкание по-прежнему имеет доступ к x,

936
00:16:07,430 --> 00:16:07,440
наше замыкание по-прежнему имеет доступ к x,
 

937
00:16:07,440 --> 00:16:09,030
наше замыкание по-прежнему имеет доступ к x,
потому что они оба определены в

938
00:16:09,030 --> 00:16:09,040
потому что они оба определены в
 

939
00:16:09,040 --> 00:16:09,990
потому что они оба определены в
одной и той же области,

940
00:16:09,990 --> 00:16:10,000
одной и той же области,
 

941
00:16:10,000 --> 00:16:11,990
одной и той же области,
тогда мы определяем переменную с именем y и

942
00:16:11,990 --> 00:16:12,000
тогда мы определяем переменную с именем y и
 

943
00:16:12,000 --> 00:16:13,749
тогда мы определяем переменную с именем y и
устанавливаем ее также равной  до четырех,

944
00:16:13,749 --> 00:16:13,759
устанавливаем ее также равной  до четырех,
 

945
00:16:13,759 --> 00:16:16,710
устанавливаем ее также равной  до четырех,
наконец, мы вызываем наше закрытие, передавая y,

946
00:16:16,710 --> 00:16:16,720
наконец, мы вызываем наше закрытие, передавая y,
 

947
00:16:16,720 --> 00:16:18,470
наконец, мы вызываем наше закрытие, передавая y,
вызов нашего закрытия завернут

948
00:16:18,470 --> 00:16:18,480
вызов нашего закрытия завернут
 

949
00:16:18,480 --> 00:16:20,310
вызов нашего закрытия завернут
в макрос assert,

950
00:16:20,310 --> 00:16:20,320
в макрос assert,
 

951
00:16:20,320 --> 00:16:22,629
в макрос assert,
который будет паниковать, если функция вышки

952
00:16:22,629 --> 00:16:22,639
который будет паниковать, если функция вышки
 

953
00:16:22,639 --> 00:16:23,590
который будет паниковать, если функция вышки
вызовов приведет

954
00:16:23,590 --> 00:16:23,600
вызовов приведет
 

955
00:16:23,600 --> 00:16:26,069
вызовов приведет
к ложному результату, поэтому давайте продолжим и запустим нашу

956
00:16:26,069 --> 00:16:26,079
к ложному результату, поэтому давайте продолжим и запустим нашу
 

957
00:16:26,079 --> 00:16:28,710
к ложному результату, поэтому давайте продолжим и запустим нашу
программу

958
00:16:28,710 --> 00:16:28,720

 

959
00:16:28,720 --> 00:16:31,670

и, как вы можете видеть, мы не паниковали, теперь

960
00:16:31,670 --> 00:16:31,680
и, как вы можете видеть, мы не паниковали, теперь
 

961
00:16:31,680 --> 00:16:33,509
и, как вы можете видеть, мы не паниковали, теперь
давайте посмотрим, что произойдет, если мы используем

962
00:16:33,509 --> 00:16:33,519
давайте посмотрим, что произойдет, если мы используем
 

963
00:16:33,519 --> 00:16:34,230
давайте посмотрим, что произойдет, если мы используем
функцию

964
00:16:34,230 --> 00:16:34,240
функцию
 

965
00:16:34,240 --> 00:16:36,710
функцию
вместо замыкания, поэтому мы изменим наше

966
00:16:36,710 --> 00:16:37,670
вместо замыкания, поэтому мы изменим наше
 

967
00:16:37,670 --> 00:16:37,680

 

968
00:16:37,680 --> 00:16:41,829

замыкание, равное x, на функцию.

969
00:16:41,829 --> 00:16:41,839

 

970
00:16:41,839 --> 00:16:43,910

здесь вы можете увидеть несколько красных волнистых линий

971
00:16:43,910 --> 00:16:43,920
здесь вы можете увидеть несколько красных волнистых линий
 

972
00:16:43,920 --> 00:16:45,910
здесь вы можете увидеть несколько красных волнистых линий
под x, и если я  наведите указатель мыши, и вы

973
00:16:45,910 --> 00:16:45,920
под x, и если я  наведите указатель мыши, и вы
 

974
00:16:45,920 --> 00:16:47,030
под x, и если я  наведите указатель мыши, и вы
увидите, что ошибка не

975
00:16:47,030 --> 00:16:47,040
увидите, что ошибка не
 

976
00:16:47,040 --> 00:16:49,509
увидите, что ошибка не
может захватить динамическую среду

977
00:16:49,509 --> 00:16:49,519
может захватить динамическую среду
 

978
00:16:49,519 --> 00:16:50,470
может захватить динамическую среду
внутри функции,

979
00:16:50,470 --> 00:16:50,480
внутри функции,
 

980
00:16:50,480 --> 00:16:52,710
внутри функции,
вместо этого используйте закрытие, поэтому компилятор

981
00:16:52,710 --> 00:16:52,720
вместо этого используйте закрытие, поэтому компилятор
 

982
00:16:52,720 --> 00:16:54,230
вместо этого используйте закрытие, поэтому компилятор
фактически говорит нам

983
00:16:54,230 --> 00:16:54,240
фактически говорит нам
 

984
00:16:54,240 --> 00:16:56,550
фактически говорит нам
использовать закрытие вместо функции, потому что

985
00:16:56,550 --> 00:16:56,560
использовать закрытие вместо функции, потому что
 

986
00:16:56,560 --> 00:16:58,230
использовать закрытие вместо функции, потому что
закрытие может захватить свою

987
00:16:58,230 --> 00:16:58,240
закрытие может захватить свою
 

988
00:16:58,240 --> 00:16:58,949
закрытие может захватить свою
среду,

989
00:16:58,949 --> 00:16:58,959
среду,
 

990
00:16:58,959 --> 00:17:01,189
среду,
им нужно использовать дополнительную память  для хранения

991
00:17:01,189 --> 00:17:01,199
им нужно использовать дополнительную память  для хранения
 

992
00:17:01,199 --> 00:17:02,310
им нужно использовать дополнительную память  для хранения
этого контекста,

993
00:17:02,310 --> 00:17:02,320
этого контекста,
 

994
00:17:02,320 --> 00:17:04,069
этого контекста,
но поскольку функции не фиксируют

995
00:17:04,069 --> 00:17:04,079
но поскольку функции не фиксируют
 

996
00:17:04,079 --> 00:17:06,069
но поскольку функции не фиксируют
свою среду, они не несут тех

997
00:17:06,069 --> 00:17:06,079
свою среду, они не несут тех
 

998
00:17:06,079 --> 00:17:07,429
свою среду, они не несут тех
же накладных расходов, которые

999
00:17:07,429 --> 00:17:07,439
же накладных расходов, которые
 

1000
00:17:07,439 --> 00:17:09,189
же накладных расходов, которые
захватывают значения из своей

1001
00:17:09,189 --> 00:17:09,199
захватывают значения из своей
 

1002
00:17:09,199 --> 00:17:10,870
захватывают значения из своей
среды тремя способами,

1003
00:17:10,870 --> 00:17:10,880
среды тремя способами,
 

1004
00:17:10,880 --> 00:17:13,110
среды тремя способами,
которые напрямую сопоставляются с тремя способами, которыми

1005
00:17:13,110 --> 00:17:13,120
которые напрямую сопоставляются с тремя способами, которыми
 

1006
00:17:13,120 --> 00:17:14,549
которые напрямую сопоставляются с тремя способами, которыми
функция может принимать

1007
00:17:14,549 --> 00:17:14,559
функция может принимать
 

1008
00:17:14,559 --> 00:17:17,590
функция может принимать
входные параметры, взяв на себя ответственность путем

1009
00:17:17,590 --> 00:17:17,600
входные параметры, взяв на себя ответственность путем
 

1010
00:17:17,600 --> 00:17:18,870
входные параметры, взяв на себя ответственность путем
неизменного заимствования

1011
00:17:18,870 --> 00:17:18,880
неизменного заимствования
 

1012
00:17:18,880 --> 00:17:21,909
неизменного заимствования
или путем неизменного заимствования эти три

1013
00:17:21,909 --> 00:17:21,919
или путем неизменного заимствования эти три
 

1014
00:17:21,919 --> 00:17:23,669
или путем неизменного заимствования эти три
способа захвата

1015
00:17:23,669 --> 00:17:23,679
способа захвата
 

1016
00:17:23,679 --> 00:17:26,069
способа захвата
среды закодированы в функциональных чертах,

1017
00:17:26,069 --> 00:17:26,079
среды закодированы в функциональных чертах,
 

1018
00:17:26,079 --> 00:17:27,350
среды закодированы в функциональных чертах,
о которых мы говорили ранее,

1019
00:17:27,350 --> 00:17:27,360
о которых мы говорили ранее,
 

1020
00:17:27,360 --> 00:17:30,470
о которых мы говорили ранее,
а именно: fn один раз f и мю и

1021
00:17:30,470 --> 00:17:30,480
а именно: fn один раз f и мю и
 

1022
00:17:30,480 --> 00:17:33,270
а именно: fn один раз f и мю и
fn один раз fn один раз  берет на себя ответственность за

1023
00:17:33,270 --> 00:17:33,280
fn один раз fn один раз  берет на себя ответственность за
 

1024
00:17:33,280 --> 00:17:34,870
fn один раз fn один раз  берет на себя ответственность за
переменные внутри среды замыканий.

1025
00:17:34,870 --> 00:17:34,880
переменные внутри среды замыканий.
 

1026
00:17:34,880 --> 00:17:36,710
переменные внутри среды замыканий.
Часть имени Once

1027
00:17:36,710 --> 00:17:36,720
Часть имени Once
 

1028
00:17:36,720 --> 00:17:38,630
Часть имени Once
представляет тот факт, что замыкания

1029
00:17:38,630 --> 00:17:38,640
представляет тот факт, что замыкания
 

1030
00:17:38,640 --> 00:17:40,230
представляет тот факт, что замыкания
не могут владеть одними и теми же

1031
00:17:40,230 --> 00:17:40,240
не могут владеть одними и теми же
 

1032
00:17:40,240 --> 00:17:42,150
не могут владеть одними и теми же
переменными более одного раза,

1033
00:17:42,150 --> 00:17:42,160
переменными более одного раза,
 

1034
00:17:42,160 --> 00:17:43,990
переменными более одного раза,
поэтому эти замыкания можно называть только

1035
00:17:43,990 --> 00:17:44,000
поэтому эти замыкания можно называть только
 

1036
00:17:44,000 --> 00:17:45,510
поэтому эти замыкания можно называть только
теми, которые fn

1037
00:17:45,510 --> 00:17:45,520
теми, которые fn
 

1038
00:17:45,520 --> 00:17:48,549
теми, которые fn
mu заимствует значения с изменяемым значением, а fn

1039
00:17:48,549 --> 00:17:48,559
mu заимствует значения с изменяемым значением, а fn
 

1040
00:17:48,559 --> 00:17:51,029
mu заимствует значения с изменяемым значением, а fn
неизменно заимствует значения  когда вы

1041
00:17:51,029 --> 00:17:51,039
неизменно заимствует значения  когда вы
 

1042
00:17:51,039 --> 00:17:52,870
неизменно заимствует значения  когда вы
создаете замыкание, Rust делает вывод, какие из этих

1043
00:17:52,870 --> 00:17:52,880
создаете замыкание, Rust делает вывод, какие из этих
 

1044
00:17:52,880 --> 00:17:54,070
создаете замыкание, Rust делает вывод, какие из этих
трейтов использовать,

1045
00:17:54,070 --> 00:17:54,080
трейтов использовать,
 

1046
00:17:54,080 --> 00:17:56,630
трейтов использовать,
основываясь на том, как вы используете значения

1047
00:17:56,630 --> 00:17:56,640
основываясь на том, как вы используете значения
 

1048
00:17:56,640 --> 00:17:58,230
основываясь на том, как вы используете значения
внутри окружения замыканий,

1049
00:17:58,230 --> 00:17:58,240
внутри окружения замыканий,
 

1050
00:17:58,240 --> 00:18:00,230
внутри окружения замыканий,
однако мы могли бы заставить замыкание взять на

1051
00:18:00,230 --> 00:18:00,240
однако мы могли бы заставить замыкание взять на
 

1052
00:18:00,240 --> 00:18:02,710
однако мы могли бы заставить замыкание взять на
себя ответственность за значения, которые оно использует

1053
00:18:02,710 --> 00:18:02,720
себя ответственность за значения, которые оно использует
 

1054
00:18:02,720 --> 00:18:05,270
себя ответственность за значения, которые оно использует
внутри своего окружения, используя

1055
00:18:05,270 --> 00:18:05,280
внутри своего окружения, используя
 

1056
00:18:05,280 --> 00:18:05,909
внутри своего окружения, используя
ключевое слово move

1057
00:18:05,909 --> 00:18:05,919
ключевое слово move
 

1058
00:18:05,919 --> 00:18:08,070
ключевое слово move
перед тегом  закрытие это в основном

1059
00:18:08,070 --> 00:18:08,080
перед тегом  закрытие это в основном
 

1060
00:18:08,080 --> 00:18:09,590
перед тегом  закрытие это в основном
полезно, когда вы передаете закрытие

1061
00:18:09,590 --> 00:18:09,600
полезно, когда вы передаете закрытие
 

1062
00:18:09,600 --> 00:18:10,470
полезно, когда вы передаете закрытие
из одного потока

1063
00:18:10,470 --> 00:18:10,480
из одного потока
 

1064
00:18:10,480 --> 00:18:12,470
из одного потока
в другой поток, поэтому вы также можете

1065
00:18:12,470 --> 00:18:12,480
в другой поток, поэтому вы также можете
 

1066
00:18:12,480 --> 00:18:14,310
в другой поток, поэтому вы также можете
передать право собственности на переменные из одного

1067
00:18:14,310 --> 00:18:14,320
передать право собственности на переменные из одного
 

1068
00:18:14,320 --> 00:18:14,789
передать право собственности на переменные из одного
потока

1069
00:18:14,789 --> 00:18:14,799
потока
 

1070
00:18:14,799 --> 00:18:17,029
потока
в другой поток, например, в этом

1071
00:18:17,029 --> 00:18:17,039
в другой поток, например, в этом
 

1072
00:18:17,039 --> 00:18:19,029
в другой поток, например, в этом
случае x равен вектору,

1073
00:18:19,029 --> 00:18:19,039
случае x равен вектору,
 

1074
00:18:19,039 --> 00:18:21,750
случае x равен вектору,
у нас есть наше закрытие  который не меняется,

1075
00:18:21,750 --> 00:18:21,760
у нас есть наше закрытие  который не меняется,
 

1076
00:18:21,760 --> 00:18:22,789
у нас есть наше закрытие  который не меняется,
затем мы печатаем

1077
00:18:22,789 --> 00:18:22,799
затем мы печатаем
 

1078
00:18:22,799 --> 00:18:25,990
затем мы печатаем
x, а затем у нас также есть y, равный

1079
00:18:25,990 --> 00:18:26,000
x, а затем у нас также есть y, равный
 

1080
00:18:26,000 --> 00:18:26,950
x, а затем у нас также есть y, равный
вектору,

1081
00:18:26,950 --> 00:18:26,960
вектору,
 

1082
00:18:26,960 --> 00:18:28,950
вектору,
а затем мы снова вызываем наше замыкание,

1083
00:18:28,950 --> 00:18:28,960
а затем мы снова вызываем наше замыкание,
 

1084
00:18:28,960 --> 00:18:31,110
а затем мы снова вызываем наше замыкание,
передавая y и утверждая,

1085
00:18:31,110 --> 00:18:31,120
передавая y и утверждая,
 

1086
00:18:31,120 --> 00:18:33,750
передавая y и утверждая,
что оно retu  Теперь это верно, потому что внутри

1087
00:18:33,750 --> 00:18:33,760
что оно retu  Теперь это верно, потому что внутри
 

1088
00:18:33,760 --> 00:18:34,549
что оно retu  Теперь это верно, потому что внутри
нашего замыкания

1089
00:18:34,549 --> 00:18:34,559
нашего замыкания
 

1090
00:18:34,559 --> 00:18:37,590
нашего замыкания
мы просто оцениваем x по сравнению с z,

1091
00:18:37,590 --> 00:18:37,600
мы просто оцениваем x по сравнению с z,
 

1092
00:18:37,600 --> 00:18:40,150
мы просто оцениваем x по сравнению с z,
мы не берем на себя ответственность за x внутри

1093
00:18:40,150 --> 00:18:40,160
мы не берем на себя ответственность за x внутри
 

1094
00:18:40,160 --> 00:18:41,029
мы не берем на себя ответственность за x внутри
нашего замыкания,

1095
00:18:41,029 --> 00:18:41,039
нашего замыкания,
 

1096
00:18:41,039 --> 00:18:43,350
нашего замыкания,
но опять же мы можем заставить замыкание взять на

1097
00:18:43,350 --> 00:18:43,360
но опять же мы можем заставить замыкание взять на
 

1098
00:18:43,360 --> 00:18:44,390
но опять же мы можем заставить замыкание взять на
себя ответственность

1099
00:18:44,390 --> 00:18:44,400
себя ответственность
 

1100
00:18:44,400 --> 00:18:46,870
себя ответственность
, указав ключевое слово move

1101
00:18:46,870 --> 00:18:46,880
, указав ключевое слово move
 

1102
00:18:46,880 --> 00:18:50,710
, указав ключевое слово move
перед нашим определением замыкания,

1103
00:18:50,710 --> 00:18:50,720

 

1104
00:18:50,720 --> 00:18:53,669

теперь наше замыкание  действительно берет на себя ответственность за x,

1105
00:18:53,669 --> 00:18:53,679
теперь наше замыкание  действительно берет на себя ответственность за x,
 

1106
00:18:53,679 --> 00:18:54,070
теперь наше замыкание  действительно берет на себя ответственность за x,
и

1107
00:18:54,070 --> 00:18:54,080
и
 

1108
00:18:54,080 --> 00:18:56,310
и
мы получаем ошибку в нашем операторе печати

1109
00:18:56,310 --> 00:18:56,320
мы получаем ошибку в нашем операторе печати
 

1110
00:18:56,320 --> 00:18:58,390
мы получаем ошибку в нашем операторе печати
под определением нашего закрытия,

1111
00:18:58,390 --> 00:18:58,400
под определением нашего закрытия,
 

1112
00:18:58,400 --> 00:19:00,310
под определением нашего закрытия,
если я наведу курсор на красные волнистые линии, вы

1113
00:19:00,310 --> 00:19:00,320
если я наведу курсор на красные волнистые линии, вы
 

1114
00:19:00,320 --> 00:19:01,590
если я наведу курсор на красные волнистые линии, вы
увидите, что он говорит,

1115
00:19:01,590 --> 00:19:01,600
увидите, что он говорит,
 

1116
00:19:01,600 --> 00:19:04,230
увидите, что он говорит,
что мы используем заимствованное значение после того, как оно

1117
00:19:04,230 --> 00:19:04,240
что мы используем заимствованное значение после того, как оно
 

1118
00:19:04,240 --> 00:19:04,950
что мы используем заимствованное значение после того, как оно
было перемещено,

1119
00:19:04,950 --> 00:19:04,960
было перемещено,
 

1120
00:19:04,960 --> 00:19:07,350
было перемещено,
это имеет смысл, потому что выше  наше

1121
00:19:07,350 --> 00:19:07,360
это имеет смысл, потому что выше  наше
 

1122
00:19:07,360 --> 00:19:09,270
это имеет смысл, потому что выше  наше
замыкание становится владельцем x,

1123
00:19:09,270 --> 00:19:09,280
замыкание становится владельцем x,
 

1124
00:19:09,280 --> 00:19:12,150
замыкание становится владельцем x,
поэтому мы не можем использовать x после того, как оно было

1125
00:19:12,150 --> 00:19:12,160
поэтому мы не можем использовать x после того, как оно было
 

1126
00:19:12,160 --> 00:19:13,029
поэтому мы не можем использовать x после того, как оно было
перемещено сюда,

1127
00:19:13,029 --> 00:19:13,039
перемещено сюда,
 

1128
00:19:13,039 --> 00:19:14,789
перемещено сюда,
все в порядке, что завершает первую часть

1129
00:19:14,789 --> 00:19:14,799
все в порядке, что завершает первую часть
 

1130
00:19:14,799 --> 00:19:16,870
все в порядке, что завершает первую часть
главы 13, в которой мы рассмотрели

1131
00:19:16,870 --> 00:19:16,880
главы 13, в которой мы рассмотрели
 

1132
00:19:16,880 --> 00:19:19,029
главы 13, в которой мы рассмотрели
замыкания, теперь я знаю, что замыкания могут быть

1133
00:19:19,029 --> 00:19:19,039
замыкания, теперь я знаю, что замыкания могут быть
 

1134
00:19:19,039 --> 00:19:20,470
замыкания, теперь я знаю, что замыкания могут быть
трудными для понимания,

1135
00:19:20,470 --> 00:19:20,480
трудными для понимания,
 

1136
00:19:20,480 --> 00:19:22,230
трудными для понимания,
и мы не прошли через все

1137
00:19:22,230 --> 00:19:22,240
и мы не прошли через все
 

1138
00:19:22,240 --> 00:19:24,070
и мы не прошли через все
возможные способы использования замыканий,

1139
00:19:24,070 --> 00:19:24,080
возможные способы использования замыканий,
 

1140
00:19:24,080 --> 00:19:25,909
возможные способы использования замыканий,
поэтому, если вы хотите увидеть другое видео

1141
00:19:25,909 --> 00:19:25,919
поэтому, если вы хотите увидеть другое видео
 

1142
00:19:25,919 --> 00:19:28,150
поэтому, если вы хотите увидеть другое видео
о замыканиях с большим количеством примеров,

1143
00:19:28,150 --> 00:19:28,160
о замыканиях с большим количеством примеров,
 

1144
00:19:28,160 --> 00:19:30,470
о замыканиях с большим количеством примеров,
прокомментируйте ниже и, конечно, если вам

1145
00:19:30,470 --> 00:19:30,480
прокомментируйте ниже и, конечно, если вам
 

1146
00:19:30,480 --> 00:19:31,510
прокомментируйте ниже и, конечно, если вам
нравится это видео,

1147
00:19:31,510 --> 00:19:31,520
нравится это видео,
 

1148
00:19:31,520 --> 00:19:33,350
нравится это видео,
обязательно поставьте ему лайк в

1149
00:19:33,350 --> 00:19:33,360
обязательно поставьте ему лайк в
 

1150
00:19:33,360 --> 00:19:34,630
обязательно поставьте ему лайк в
следующем видео, которое мы даем  oing над

1151
00:19:34,630 --> 00:19:34,640
следующем видео, которое мы даем  oing над
 

1152
00:19:34,640 --> 00:19:36,870
следующем видео, которое мы даем  oing над
итераторами, поэтому, если вы хотите получать уведомления

1153
00:19:36,870 --> 00:19:36,880
итераторами, поэтому, если вы хотите получать уведомления
 

1154
00:19:36,880 --> 00:19:37,990
итераторами, поэтому, если вы хотите получать уведомления
об этом,

1155
00:19:37,990 --> 00:19:38,000
об этом,
 

1156
00:19:38,000 --> 00:19:40,870
об этом,
обязательно нажмите «подписаться», и с этим я увижу

1157
00:19:40,870 --> 00:19:40,880
обязательно нажмите «подписаться», и с этим я увижу
 

1158
00:19:40,880 --> 00:19:41,590
обязательно нажмите «подписаться», и с этим я увижу
вас

1159
00:19:41,590 --> 00:19:41,600
вас
 

1160
00:19:41,600 --> 00:19:52,470
вас
в следующем, который

1161
00:19:52,470 --> 00:19:52,480
в следующем, который
 

1162
00:19:52,480 --> 00:19:54,559
в следующем, который
вы

